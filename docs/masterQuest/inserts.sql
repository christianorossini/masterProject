-- MySQL dump 10.13  Distrib 5.7.28, for Linux (x86_64)
--
-- Host: localhost    Database: masterquestdb
-- ------------------------------------------------------
-- Server version	5.7.28-0ubuntu0.18.04.4

/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!40101 SET NAMES utf8 */;
/*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */;
/*!40103 SET TIME_ZONE='+00:00' */;
/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;

--
-- Dumping data for table `ms_dtModel`
--

LOCK TABLES `ms_dtModel` WRITE;
/*!40000 ALTER TABLE `ms_dtModel` DISABLE KEYS */;
INSERT INTO `ms_dtModel` VALUES (1,'dt3.png',4,6,'AvgLineBlank,CountDeclClassVariable,CountDeclInstanceVariable,CountLine'),(2,'dt5.png',2,4,'CountClassCoupled,CountDeclInstanceMethod,CountDeclMethodPublic'),(3,'dt9.png',4,6,'CountDeclClassVariable,CountDeclInstanceVariable,CountLineCode,PercentLackOfCohesion,RatioCommentToCode'),(4,'dt4.png',4,6,'CountLineBlank,CountLineCode,CountLineComment'),(5,'dt11.png',3,4,'CountInput,CountLineCodeDecl,CountStmtDecl'),(6,'dt10.png',4,6,'CountDeclClassVariable,CountDeclInstanceVariable,CountLineCode,PercentLackOfCohesion,RatioCommentToCode'),(7,'dt8.png',4,6,'AvgLineBlank,CountDeclClassVariable,CountDeclInstanceVariable,CountLine'),(8,'dt6.png',4,6,'CountLineBlank,CountLineCode,CountLineComment'),(9,'dt12.png',3,4,'CountInput,CountLineCodeDecl,CountStmtDecl'),(10,'dt7.png',2,4,'CountClassCoupled,CountDeclInstanceMethod,CountDeclMethodPublic');
/*!40000 ALTER TABLE `ms_dtModel` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Dumping data for table `ms_task`
--

LOCK TABLES `ms_task` WRITE;
/*!40000 ALTER TABLE `ms_task` DISABLE KEYS */;
INSERT INTO `ms_task` VALUES (3,'C','gc','/*\r\n *  Licensed to the Apache Software Foundation (ASF) under one or more\r\n *  contributor license agreements.  See the NOTICE file distributed with\r\n *  this work for additional information regarding copyright ownership.\r\n *  The ASF licenses this file to You under the Apache License, Version 2.0\r\n *  (the \"License\"); you may not use this file except in compliance with\r\n *  the License.  You may obtain a copy of the License at\r\n *\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n *  Unless required by applicable law or agreed to in writing, software\r\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\r\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n *  See the License for the specific language governing permissions and\r\n *  limitations under the License.\r\n *\r\n */\r\n\r\npackage org.apache.tools.ant;\r\n\r\nimport java.io.File;\r\nimport java.io.IOException;\r\nimport java.util.ArrayList;\r\nimport java.util.Arrays;\r\nimport java.util.HashMap;\r\nimport java.util.HashSet;\r\nimport java.util.Iterator;\r\nimport java.util.LinkedList;\r\nimport java.util.Map;\r\nimport java.util.Set;\r\nimport java.util.Vector;\r\n\r\nimport org.apache.tools.ant.taskdefs.condition.Os;\r\nimport org.apache.tools.ant.types.Resource;\r\nimport org.apache.tools.ant.types.ResourceFactory;\r\nimport org.apache.tools.ant.types.resources.FileResource;\r\nimport org.apache.tools.ant.types.selectors.FileSelector;\r\nimport org.apache.tools.ant.types.selectors.SelectorScanner;\r\nimport org.apache.tools.ant.types.selectors.SelectorUtils;\r\nimport org.apache.tools.ant.types.selectors.TokenizedPath;\r\nimport org.apache.tools.ant.types.selectors.TokenizedPattern;\r\nimport org.apache.tools.ant.util.CollectionUtils;\r\nimport org.apache.tools.ant.util.FileUtils;\r\nimport org.apache.tools.ant.util.SymbolicLinkUtils;\r\nimport org.apache.tools.ant.util.VectorSet;\r\n\r\n/**\r\n * Class for scanning a directory for files/directories which match certain\r\n * criteria.\r\n * <p>\r\n * These criteria consist of selectors and patterns which have been specified.\r\n * With the selectors you can select which files you want to have included.\r\n * Files which are not selected are excluded. With patterns you can include\r\n * or exclude files based on their filename.\r\n * <p>\r\n * The idea is simple. A given directory is recursively scanned for all files\r\n * and directories. Each file/directory is matched against a set of selectors,\r\n * including special support for matching against filenames with include and\r\n * and exclude patterns. Only files/directories which match at least one\r\n * pattern of the include pattern list or other file selector, and don\'t match\r\n * any pattern of the exclude pattern list or fail to match against a required\r\n * selector will be placed in the list of files/directories found.\r\n * <p>\r\n * When no list of include patterns is supplied, \"**\" will be used, which\r\n * means that everything will be matched. When no list of exclude patterns is\r\n * supplied, an empty list is used, such that nothing will be excluded. When\r\n * no selectors are supplied, none are applied.\r\n * <p>\r\n * The filename pattern matching is done as follows:\r\n * The name to be matched is split up in path segments. A path segment is the\r\n * name of a directory or file, which is bounded by\r\n * <code>File.separator</code> (\'/\' under UNIX, \'\\\' under Windows).\r\n * For example, \"abc/def/ghi/xyz.java\" is split up in the segments \"abc\",\r\n * \"def\",\"ghi\" and \"xyz.java\".\r\n * The same is done for the pattern against which should be matched.\r\n * <p>\r\n * The segments of the name and the pattern are then matched against each\r\n * other. When \'**\' is used for a path segment in the pattern, it matches\r\n * zero or more path segments of the name.\r\n * <p>\r\n * There is a special case regarding the use of <code>File.separator</code>s\r\n * at the beginning of the pattern and the string to match:<br>\r\n * When a pattern starts with a <code>File.separator</code>, the string\r\n * to match must also start with a <code>File.separator</code>.\r\n * When a pattern does not start with a <code>File.separator</code>, the\r\n * string to match may not start with a <code>File.separator</code>.\r\n * When one of these rules is not obeyed, the string will not\r\n * match.\r\n * <p>\r\n * When a name path segment is matched against a pattern path segment, the\r\n * following special characters can be used:<br>\r\n * \'*\' matches zero or more characters<br>\r\n * \'?\' matches one character.\r\n * <p>\r\n * Examples:\r\n * <p>\r\n * \"**\\*.class\" matches all .class files/dirs in a directory tree.\r\n * <p>\r\n * \"test\\a??.java\" matches all files/dirs which start with an \'a\', then two\r\n * more characters and then \".java\", in a directory called test.\r\n * <p>\r\n * \"**\" matches everything in a directory tree.\r\n * <p>\r\n * \"**\\test\\**\\XYZ*\" matches all files/dirs which start with \"XYZ\" and where\r\n * there is a parent directory called test (e.g. \"abc\\test\\def\\ghi\\XYZ123\").\r\n * <p>\r\n * Case sensitivity may be turned off if necessary. By default, it is\r\n * turned on.\r\n * <p>\r\n * Example of usage:\r\n * <pre>\r\n *   String[] includes = {\"**\\\\*.class\"};\r\n *   String[] excludes = {\"modules\\\\*\\\\**\"};\r\n *   ds.setIncludes(includes);\r\n *   ds.setExcludes(excludes);\r\n *   ds.setBasedir(new File(\"test\"));\r\n *   ds.setCaseSensitive(true);\r\n *   ds.scan();\r\n *\r\n *   System.out.println(\"FILES:\");\r\n *   String[] files = ds.getIncludedFiles();\r\n *   for (int i = 0; i < files.length; i++) {\r\n *     System.out.println(files[i]);\r\n *   }\r\n * </pre>\r\n * This will scan a directory called test for .class files, but excludes all\r\n * files in all proper subdirectories of a directory called \"modules\"\r\n *\r\n */\r\npublic class DirectoryScanner\r\n       implements FileScanner, SelectorScanner, ResourceFactory {\r\n\r\n    /** Is OpenVMS the operating system we\'re running on? */\r\n    private static final boolean ON_VMS = Os.isFamily(\"openvms\");\r\n\r\n    /**\r\n     * Patterns which should be excluded by default.\r\n     *\r\n     * <p>Note that you can now add patterns to the list of default\r\n     * excludes.  Added patterns will not become part of this array\r\n     * that has only been kept around for backwards compatibility\r\n     * reasons.</p>\r\n     *\r\n     * @deprecated since 1.6.x.\r\n     *             Use the {@link #getDefaultExcludes getDefaultExcludes}\r\n     *             method instead.\r\n     */\r\n    protected static final String[] DEFAULTEXCLUDES = {\r\n        // Miscellaneous typical temporary files\r\n        SelectorUtils.DEEP_TREE_MATCH + \"/*~\",\r\n        SelectorUtils.DEEP_TREE_MATCH + \"/#*#\",\r\n        SelectorUtils.DEEP_TREE_MATCH + \"/.#*\",\r\n        SelectorUtils.DEEP_TREE_MATCH + \"/%*%\",\r\n        SelectorUtils.DEEP_TREE_MATCH + \"/._*\",\r\n\r\n        // CVS\r\n        SelectorUtils.DEEP_TREE_MATCH + \"/CVS\",\r\n        SelectorUtils.DEEP_TREE_MATCH + \"/CVS/\" + SelectorUtils.DEEP_TREE_MATCH,\r\n        SelectorUtils.DEEP_TREE_MATCH + \"/.cvsignore\",\r\n\r\n        // SCCS\r\n        SelectorUtils.DEEP_TREE_MATCH + \"/SCCS\",\r\n        SelectorUtils.DEEP_TREE_MATCH + \"/SCCS/\" + SelectorUtils.DEEP_TREE_MATCH,\r\n\r\n        // Visual SourceSafe\r\n        SelectorUtils.DEEP_TREE_MATCH + \"/vssver.scc\",\r\n\r\n        // Subversion\r\n        SelectorUtils.DEEP_TREE_MATCH + \"/.svn\",\r\n        SelectorUtils.DEEP_TREE_MATCH + \"/.svn/\" + SelectorUtils.DEEP_TREE_MATCH,\r\n\r\n        // Git\r\n        SelectorUtils.DEEP_TREE_MATCH + \"/.git\",\r\n        SelectorUtils.DEEP_TREE_MATCH + \"/.git/\" + SelectorUtils.DEEP_TREE_MATCH,\r\n        SelectorUtils.DEEP_TREE_MATCH + \"/.gitattributes\",\r\n        SelectorUtils.DEEP_TREE_MATCH + \"/.gitignore\",\r\n        SelectorUtils.DEEP_TREE_MATCH + \"/.gitmodules\",\r\n\r\n        // Mercurial\r\n        SelectorUtils.DEEP_TREE_MATCH + \"/.hg\",\r\n        SelectorUtils.DEEP_TREE_MATCH + \"/.hg/\" + SelectorUtils.DEEP_TREE_MATCH,\r\n        SelectorUtils.DEEP_TREE_MATCH + \"/.hgignore\",\r\n        SelectorUtils.DEEP_TREE_MATCH + \"/.hgsub\",\r\n        SelectorUtils.DEEP_TREE_MATCH + \"/.hgsubstate\",\r\n        SelectorUtils.DEEP_TREE_MATCH + \"/.hgtags\",\r\n\r\n        // Bazaar\r\n        SelectorUtils.DEEP_TREE_MATCH + \"/.bzr\",\r\n        SelectorUtils.DEEP_TREE_MATCH + \"/.bzr/\" + SelectorUtils.DEEP_TREE_MATCH,\r\n        SelectorUtils.DEEP_TREE_MATCH + \"/.bzrignore\",\r\n\r\n        // Mac\r\n        SelectorUtils.DEEP_TREE_MATCH + \"/.DS_Store\"\r\n    };\r\n\r\n    /**\r\n     * default value for {@link #maxLevelsOfSymlinks maxLevelsOfSymlinks}\r\n     * @since Ant 1.8.0\r\n     */\r\n    public static final int MAX_LEVELS_OF_SYMLINKS = 5;\r\n    /**\r\n     * The end of the exception message if something that should be\r\n     * there doesn\'t exist.\r\n     */\r\n    public static final String DOES_NOT_EXIST_POSTFIX = \" does not exist.\";\r\n\r\n    /** Helper. */\r\n    private static final FileUtils FILE_UTILS = FileUtils.getFileUtils();\r\n\r\n    /** Helper. */\r\n    private static final SymbolicLinkUtils SYMLINK_UTILS =\r\n        SymbolicLinkUtils.getSymbolicLinkUtils();\r\n\r\n    /**\r\n     * Patterns which should be excluded by default.\r\n     *\r\n     * @see #addDefaultExcludes()\r\n     */\r\n    private static final Set defaultExcludes = new HashSet();\r\n    static {\r\n        resetDefaultExcludes();\r\n    }\r\n\r\n    // CheckStyle:VisibilityModifier OFF - bc\r\n\r\n    /** The base directory to be scanned. */\r\n    protected File basedir;\r\n\r\n    /** The patterns for the files to be included. */\r\n    protected String[] includes;\r\n\r\n    /** The patterns for the files to be excluded. */\r\n    protected String[] excludes;\r\n\r\n    /** Selectors that will filter which files are in our candidate list. */\r\n    protected FileSelector[] selectors = null;\r\n\r\n    /**\r\n     * The files which matched at least one include and no excludes\r\n     * and were selected.\r\n     */\r\n    protected Vector filesIncluded;\r\n\r\n    /** The files which did not match any includes or selectors. */\r\n    protected Vector filesNotIncluded;\r\n\r\n    /**\r\n     * The files which matched at least one include and at least\r\n     * one exclude.\r\n     */\r\n    protected Vector filesExcluded;\r\n\r\n    /**\r\n     * The directories which matched at least one include and no excludes\r\n     * and were selected.\r\n     */\r\n    protected Vector dirsIncluded;\r\n\r\n    /** The directories which were found and did not match any includes. */\r\n    protected Vector dirsNotIncluded;\r\n\r\n    /**\r\n     * The directories which matched at least one include and at least one\r\n     * exclude.\r\n     */\r\n    protected Vector dirsExcluded;\r\n\r\n    /**\r\n     * The files which matched at least one include and no excludes and\r\n     * which a selector discarded.\r\n     */\r\n    protected Vector filesDeselected;\r\n\r\n    /**\r\n     * The directories which matched at least one include and no excludes\r\n     * but which a selector discarded.\r\n     */\r\n    protected Vector dirsDeselected;\r\n\r\n    /** Whether or not our results were built by a slow scan. */\r\n    protected boolean haveSlowResults = false;\r\n\r\n    /**\r\n     * Whether or not the file system should be treated as a case sensitive\r\n     * one.\r\n     */\r\n    protected boolean isCaseSensitive = true;\r\n\r\n    /**\r\n     * Whether a missing base directory is an error.\r\n     * @since Ant 1.7.1\r\n     */\r\n    protected boolean errorOnMissingDir = true;\r\n\r\n    /**\r\n     * Whether or not symbolic links should be followed.\r\n     *\r\n     * @since Ant 1.5\r\n     */\r\n    private boolean followSymlinks = true;\r\n\r\n    /** Whether or not everything tested so far has been included. */\r\n    protected boolean everythingIncluded = true;\r\n\r\n    // CheckStyle:VisibilityModifier ON\r\n\r\n    /**\r\n     * List of all scanned directories.\r\n     *\r\n     * @since Ant 1.6\r\n     */\r\n    private Set scannedDirs = new HashSet();\r\n\r\n    /**\r\n     * Map of all include patterns that are full file names and don\'t\r\n     * contain any wildcards.\r\n     *\r\n     * <p>Maps pattern string to TokenizedPath.</p>\r\n     *\r\n     * <p>If this instance is not case sensitive, the file names get\r\n     * turned to upper case.</p>\r\n     *\r\n     * <p>Gets lazily initialized on the first invocation of\r\n     * isIncluded or isExcluded and cleared at the end of the scan\r\n     * method (cleared in clearCaches, actually).</p>\r\n     *\r\n     * @since Ant 1.8.0\r\n     */\r\n    private Map includeNonPatterns = new HashMap();\r\n\r\n    /**\r\n     * Map of all exclude patterns that are full file names and don\'t\r\n     * contain any wildcards.\r\n     *\r\n     * <p>Maps pattern string to TokenizedPath.</p>\r\n     *\r\n     * <p>If this instance is not case sensitive, the file names get\r\n     * turned to upper case.</p>\r\n     *\r\n     * <p>Gets lazily initialized on the first invocation of\r\n     * isIncluded or isExcluded and cleared at the end of the scan\r\n     * method (cleared in clearCaches, actually).</p>\r\n     *\r\n     * @since Ant 1.8.0\r\n     */\r\n    private Map excludeNonPatterns = new HashMap();\r\n\r\n    /**\r\n     * Array of all include patterns that contain wildcards.\r\n     *\r\n     * <p>Gets lazily initialized on the first invocation of\r\n     * isIncluded or isExcluded and cleared at the end of the scan\r\n     * method (cleared in clearCaches, actually).</p>\r\n     */\r\n    private TokenizedPattern[] includePatterns;\r\n\r\n    /**\r\n     * Array of all exclude patterns that contain wildcards.\r\n     *\r\n     * <p>Gets lazily initialized on the first invocation of\r\n     * isIncluded or isExcluded and cleared at the end of the scan\r\n     * method (cleared in clearCaches, actually).</p>\r\n     */\r\n    private TokenizedPattern[] excludePatterns;\r\n\r\n    /**\r\n     * Have the non-pattern sets and pattern arrays for in- and\r\n     * excludes been initialized?\r\n     *\r\n     * @since Ant 1.6.3\r\n     */\r\n    private boolean areNonPatternSetsReady = false;\r\n\r\n    /**\r\n     * Scanning flag.\r\n     *\r\n     * @since Ant 1.6.3\r\n     */\r\n    private boolean scanning = false;\r\n\r\n    /**\r\n     * Scanning lock.\r\n     *\r\n     * @since Ant 1.6.3\r\n     */\r\n    private Object scanLock = new Object();\r\n\r\n    /**\r\n     * Slow scanning flag.\r\n     *\r\n     * @since Ant 1.6.3\r\n     */\r\n    private boolean slowScanning = false;\r\n\r\n    /**\r\n     * Slow scanning lock.\r\n     *\r\n     * @since Ant 1.6.3\r\n     */\r\n    private Object slowScanLock = new Object();\r\n\r\n    /**\r\n     * Exception thrown during scan.\r\n     *\r\n     * @since Ant 1.6.3\r\n     */\r\n    private IllegalStateException illegal = null;\r\n\r\n    /**\r\n     * The maximum number of times a symbolic link may be followed\r\n     * during a scan.\r\n     *\r\n     * @since Ant 1.8.0\r\n     */\r\n    private int maxLevelsOfSymlinks = MAX_LEVELS_OF_SYMLINKS;\r\n\r\n\r\n    /**\r\n     * Absolute paths of all symlinks that haven\'t been followed but\r\n     * would have been if followsymlinks had been true or\r\n     * maxLevelsOfSymlinks had been higher.\r\n     *\r\n     * @since Ant 1.8.0\r\n     */\r\n    private Set/*<String>*/ notFollowedSymlinks = new HashSet();\r\n\r\n    /**\r\n     * Sole constructor.\r\n     */\r\n    public DirectoryScanner() {\r\n    }\r\n\r\n    /**\r\n     * Test whether or not a given path matches the start of a given\r\n     * pattern up to the first \"**\".\r\n     * <p>\r\n     * This is not a general purpose test and should only be used if you\r\n     * can live with false positives. For example, <code>pattern=**\\a</code>\r\n     * and <code>str=b</code> will yield <code>true</code>.\r\n     *\r\n     * @param pattern The pattern to match against. Must not be\r\n     *                <code>null</code>.\r\n     * @param str     The path to match, as a String. Must not be\r\n     *                <code>null</code>.\r\n     *\r\n     * @return whether or not a given path matches the start of a given\r\n     * pattern up to the first \"**\".\r\n     */\r\n    protected static boolean matchPatternStart(String pattern, String str) {\r\n        return SelectorUtils.matchPatternStart(pattern, str);\r\n    }\r\n\r\n    /**\r\n     * Test whether or not a given path matches the start of a given\r\n     * pattern up to the first \"**\".\r\n     * <p>\r\n     * This is not a general purpose test and should only be used if you\r\n     * can live with false positives. For example, <code>pattern=**\\a</code>\r\n     * and <code>str=b</code> will yield <code>true</code>.\r\n     *\r\n     * @param pattern The pattern to match against. Must not be\r\n     *                <code>null</code>.\r\n     * @param str     The path to match, as a String. Must not be\r\n     *                <code>null</code>.\r\n     * @param isCaseSensitive Whether or not matching should be performed\r\n     *                        case sensitively.\r\n     *\r\n     * @return whether or not a given path matches the start of a given\r\n     * pattern up to the first \"**\".\r\n     */\r\n    protected static boolean matchPatternStart(String pattern, String str,\r\n                                               boolean isCaseSensitive) {\r\n        return SelectorUtils.matchPatternStart(pattern, str, isCaseSensitive);\r\n    }\r\n\r\n    /**\r\n     * Test whether or not a given path matches a given pattern.\r\n     *\r\n     * @param pattern The pattern to match against. Must not be\r\n     *                <code>null</code>.\r\n     * @param str     The path to match, as a String. Must not be\r\n     *                <code>null</code>.\r\n     *\r\n     * @return <code>true</code> if the pattern matches against the string,\r\n     *         or <code>false</code> otherwise.\r\n     */\r\n    protected static boolean matchPath(String pattern, String str) {\r\n        return SelectorUtils.matchPath(pattern, str);\r\n    }\r\n\r\n    /**\r\n     * Test whether or not a given path matches a given pattern.\r\n     *\r\n     * @param pattern The pattern to match against. Must not be\r\n     *                <code>null</code>.\r\n     * @param str     The path to match, as a String. Must not be\r\n     *                <code>null</code>.\r\n     * @param isCaseSensitive Whether or not matching should be performed\r\n     *                        case sensitively.\r\n     *\r\n     * @return <code>true</code> if the pattern matches against the string,\r\n     *         or <code>false</code> otherwise.\r\n     */\r\n    protected static boolean matchPath(String pattern, String str,\r\n                                       boolean isCaseSensitive) {\r\n        return SelectorUtils.matchPath(pattern, str, isCaseSensitive);\r\n    }\r\n\r\n    /**\r\n     * Test whether or not a string matches against a pattern.\r\n     * The pattern may contain two special characters:<br>\r\n     * \'*\' means zero or more characters<br>\r\n     * \'?\' means one and only one character\r\n     *\r\n     * @param pattern The pattern to match against.\r\n     *                Must not be <code>null</code>.\r\n     * @param str     The string which must be matched against the pattern.\r\n     *                Must not be <code>null</code>.\r\n     *\r\n     * @return <code>true</code> if the string matches against the pattern,\r\n     *         or <code>false</code> otherwise.\r\n     */\r\n    public static boolean match(String pattern, String str) {\r\n        return SelectorUtils.match(pattern, str);\r\n    }\r\n\r\n    /**\r\n     * Test whether or not a string matches against a pattern.\r\n     * The pattern may contain two special characters:<br>\r\n     * \'*\' means zero or more characters<br>\r\n     * \'?\' means one and only one character\r\n     *\r\n     * @param pattern The pattern to match against.\r\n     *                Must not be <code>null</code>.\r\n     * @param str     The string which must be matched against the pattern.\r\n     *                Must not be <code>null</code>.\r\n     * @param isCaseSensitive Whether or not matching should be performed\r\n     *                        case sensitively.\r\n     *\r\n     *\r\n     * @return <code>true</code> if the string matches against the pattern,\r\n     *         or <code>false</code> otherwise.\r\n     */\r\n    protected static boolean match(String pattern, String str,\r\n                                   boolean isCaseSensitive) {\r\n        return SelectorUtils.match(pattern, str, isCaseSensitive);\r\n    }\r\n\r\n\r\n    /**\r\n     * Get the list of patterns that should be excluded by default.\r\n     *\r\n     * @return An array of <code>String</code> based on the current\r\n     *         contents of the <code>defaultExcludes</code>\r\n     *         <code>Set</code>.\r\n     *\r\n     * @since Ant 1.6\r\n     */\r\n    public static String[] getDefaultExcludes() {\r\n        synchronized (defaultExcludes) {\r\n            return (String[]) defaultExcludes.toArray(new String[defaultExcludes\r\n                                                                 .size()]);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Add a pattern to the default excludes unless it is already a\r\n     * default exclude.\r\n     *\r\n     * @param s   A string to add as an exclude pattern.\r\n     * @return    <code>true</code> if the string was added;\r\n     *            <code>false</code> if it already existed.\r\n     *\r\n     * @since Ant 1.6\r\n     */\r\n    public static boolean addDefaultExclude(String s) {\r\n        synchronized (defaultExcludes) {\r\n            return defaultExcludes.add(s);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Remove a string if it is a default exclude.\r\n     *\r\n     * @param s   The string to attempt to remove.\r\n     * @return    <code>true</code> if <code>s</code> was a default\r\n     *            exclude (and thus was removed);\r\n     *            <code>false</code> if <code>s</code> was not\r\n     *            in the default excludes list to begin with.\r\n     *\r\n     * @since Ant 1.6\r\n     */\r\n    public static boolean removeDefaultExclude(String s) {\r\n        synchronized (defaultExcludes) {\r\n            return defaultExcludes.remove(s);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Go back to the hardwired default exclude patterns.\r\n     *\r\n     * @since Ant 1.6\r\n     */\r\n    public static void resetDefaultExcludes() {\r\n        synchronized (defaultExcludes) {\r\n            defaultExcludes.clear();\r\n            for (int i = 0; i < DEFAULTEXCLUDES.length; i++) {\r\n                defaultExcludes.add(DEFAULTEXCLUDES[i]);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Set the base directory to be scanned. This is the directory which is\r\n     * scanned recursively. All \'/\' and \'\\\' characters are replaced by\r\n     * <code>File.separatorChar</code>, so the separator used need not match\r\n     * <code>File.separatorChar</code>.\r\n     *\r\n     * @param basedir The base directory to scan.\r\n     */\r\n    public void setBasedir(String basedir) {\r\n        setBasedir(basedir == null ? (File) null\r\n            : new File(basedir.replace(\'/\', File.separatorChar).replace(\r\n            \'\\\\\', File.separatorChar)));\r\n    }\r\n\r\n    /**\r\n     * Set the base directory to be scanned. This is the directory which is\r\n     * scanned recursively.\r\n     *\r\n     * @param basedir The base directory for scanning.\r\n     */\r\n    public synchronized void setBasedir(File basedir) {\r\n        this.basedir = basedir;\r\n    }\r\n\r\n    /**\r\n     * Return the base directory to be scanned.\r\n     * This is the directory which is scanned recursively.\r\n     *\r\n     * @return the base directory to be scanned.\r\n     */\r\n    public synchronized File getBasedir() {\r\n        return basedir;\r\n    }\r\n\r\n    /**\r\n     * Find out whether include exclude patterns are matched in a\r\n     * case sensitive way.\r\n     * @return whether or not the scanning is case sensitive.\r\n     * @since Ant 1.6\r\n     */\r\n    public synchronized boolean isCaseSensitive() {\r\n        return isCaseSensitive;\r\n    }\r\n\r\n    /**\r\n     * Set whether or not include and exclude patterns are matched\r\n     * in a case sensitive way.\r\n     *\r\n     * @param isCaseSensitive whether or not the file system should be\r\n     *                        regarded as a case sensitive one.\r\n     */\r\n    public synchronized void setCaseSensitive(boolean isCaseSensitive) {\r\n        this.isCaseSensitive = isCaseSensitive;\r\n    }\r\n\r\n    /**\r\n     * Sets whether or not a missing base directory is an error\r\n     *\r\n     * @param errorOnMissingDir whether or not a missing base directory\r\n     *                        is an error\r\n     * @since Ant 1.7.1\r\n     */\r\n    public void setErrorOnMissingDir(boolean errorOnMissingDir) {\r\n        this.errorOnMissingDir = errorOnMissingDir;\r\n    }\r\n\r\n    /**\r\n     * Get whether or not a DirectoryScanner follows symbolic links.\r\n     *\r\n     * @return flag indicating whether symbolic links should be followed.\r\n     *\r\n     * @since Ant 1.6\r\n     */\r\n    public synchronized boolean isFollowSymlinks() {\r\n        return followSymlinks;\r\n    }\r\n\r\n    /**\r\n     * Set whether or not symbolic links should be followed.\r\n     *\r\n     * @param followSymlinks whether or not symbolic links should be followed.\r\n     */\r\n    public synchronized void setFollowSymlinks(boolean followSymlinks) {\r\n        this.followSymlinks = followSymlinks;\r\n    }\r\n\r\n    /**\r\n     * The maximum number of times a symbolic link may be followed\r\n     * during a scan.\r\n     *\r\n     * @since Ant 1.8.0\r\n     */\r\n    public void setMaxLevelsOfSymlinks(int max) {\r\n        maxLevelsOfSymlinks = max;\r\n    }\r\n\r\n    /**\r\n     * Set the list of include patterns to use. All \'/\' and \'\\\' characters\r\n     * are replaced by <code>File.separatorChar</code>, so the separator used\r\n     * need not match <code>File.separatorChar</code>.\r\n     * <p>\r\n     * When a pattern ends with a \'/\' or \'\\\', \"**\" is appended.\r\n     *\r\n     * @param includes A list of include patterns.\r\n     *                 May be <code>null</code>, indicating that all files\r\n     *                 should be included. If a non-<code>null</code>\r\n     *                 list is given, all elements must be\r\n     *                 non-<code>null</code>.\r\n     */\r\n    public synchronized void setIncludes(String[] includes) {\r\n        if (includes == null) {\r\n            this.includes = null;\r\n        } else {\r\n            this.includes = new String[includes.length];\r\n            for (int i = 0; i < includes.length; i++) {\r\n                this.includes[i] = normalizePattern(includes[i]);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Set the list of exclude patterns to use. All \'/\' and \'\\\' characters\r\n     * are replaced by <code>File.separatorChar</code>, so the separator used\r\n     * need not match <code>File.separatorChar</code>.\r\n     * <p>\r\n     * When a pattern ends with a \'/\' or \'\\\', \"**\" is appended.\r\n     *\r\n     * @param excludes A list of exclude patterns.\r\n     *                 May be <code>null</code>, indicating that no files\r\n     *                 should be excluded. If a non-<code>null</code> list is\r\n     *                 given, all elements must be non-<code>null</code>.\r\n     */\r\n    public synchronized void setExcludes(String[] excludes) {\r\n        if (excludes == null) {\r\n            this.excludes = null;\r\n        } else {\r\n            this.excludes = new String[excludes.length];\r\n            for (int i = 0; i < excludes.length; i++) {\r\n                this.excludes[i] = normalizePattern(excludes[i]);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Add to the list of exclude patterns to use. All \'/\' and \'\\\'\r\n     * characters are replaced by <code>File.separatorChar</code>, so\r\n     * the separator used need not match <code>File.separatorChar</code>.\r\n     * <p>\r\n     * When a pattern ends with a \'/\' or \'\\\', \"**\" is appended.\r\n     *\r\n     * @param excludes A list of exclude patterns.\r\n     *                 May be <code>null</code>, in which case the\r\n     *                 exclude patterns don\'t get changed at all.\r\n     *\r\n     * @since Ant 1.6.3\r\n     */\r\n    public synchronized void addExcludes(String[] excludes) {\r\n        if (excludes != null && excludes.length > 0) {\r\n            if (this.excludes != null && this.excludes.length > 0) {\r\n                String[] tmp = new String[excludes.length\r\n                                          + this.excludes.length];\r\n                System.arraycopy(this.excludes, 0, tmp, 0,\r\n                                 this.excludes.length);\r\n                for (int i = 0; i < excludes.length; i++) {\r\n                    tmp[this.excludes.length + i] =\r\n                        normalizePattern(excludes[i]);\r\n                }\r\n                this.excludes = tmp;\r\n            } else {\r\n                setExcludes(excludes);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * All \'/\' and \'\\\' characters are replaced by\r\n     * <code>File.separatorChar</code>, so the separator used need not\r\n     * match <code>File.separatorChar</code>.\r\n     *\r\n     * <p> When a pattern ends with a \'/\' or \'\\\', \"**\" is appended.\r\n     *\r\n     * @since Ant 1.6.3\r\n     */\r\n    private static String normalizePattern(String p) {\r\n        String pattern = p.replace(\'/\', File.separatorChar)\r\n            .replace(\'\\\\\', File.separatorChar);\r\n        if (pattern.endsWith(File.separator)) {\r\n            pattern += SelectorUtils.DEEP_TREE_MATCH;\r\n        }\r\n        return pattern;\r\n    }\r\n\r\n    /**\r\n     * Set the selectors that will select the filelist.\r\n     *\r\n     * @param selectors specifies the selectors to be invoked on a scan.\r\n     */\r\n    public synchronized void setSelectors(FileSelector[] selectors) {\r\n        this.selectors = selectors;\r\n    }\r\n\r\n    /**\r\n     * Return whether or not the scanner has included all the files or\r\n     * directories it has come across so far.\r\n     *\r\n     * @return <code>true</code> if all files and directories which have\r\n     *         been found so far have been included.\r\n     */\r\n    public synchronized boolean isEverythingIncluded() {\r\n        return everythingIncluded;\r\n    }\r\n\r\n    /**\r\n     * Scan for files which match at least one include pattern and don\'t match\r\n     * any exclude patterns. If there are selectors then the files must pass\r\n     * muster there, as well.  Scans under basedir, if set; otherwise the\r\n     * include patterns without leading wildcards specify the absolute paths of\r\n     * the files that may be included.\r\n     *\r\n     * @exception IllegalStateException if the base directory was set\r\n     *            incorrectly (i.e. if it doesn\'t exist or isn\'t a directory).\r\n     */\r\n    public void scan() throws IllegalStateException {\r\n        synchronized (scanLock) {\r\n            if (scanning) {\r\n                while (scanning) {\r\n                    try {\r\n                        scanLock.wait();\r\n                    } catch (InterruptedException e) {\r\n                        continue;\r\n                    }\r\n                }\r\n                if (illegal != null) {\r\n                    throw illegal;\r\n                }\r\n                return;\r\n            }\r\n            scanning = true;\r\n        }\r\n        File savedBase = basedir;\r\n        try {\r\n            synchronized (this) {\r\n                illegal = null;\r\n                clearResults();\r\n\r\n                // set in/excludes to reasonable defaults if needed:\r\n                boolean nullIncludes = (includes == null);\r\n                includes = nullIncludes\r\n                    ? new String[] {SelectorUtils.DEEP_TREE_MATCH} : includes;\r\n                boolean nullExcludes = (excludes == null);\r\n                excludes = nullExcludes ? new String[0] : excludes;\r\n\r\n                if (basedir != null && !followSymlinks\r\n                    && SYMLINK_UTILS.isSymbolicLink(basedir)) {\r\n                    notFollowedSymlinks.add(basedir.getAbsolutePath());\r\n                    basedir = null;\r\n                }\r\n\r\n                if (basedir == null) {\r\n                    // if no basedir and no includes, nothing to do:\r\n                    if (nullIncludes) {\r\n                        return;\r\n                    }\r\n                } else {\r\n                    if (!basedir.exists()) {\r\n                        if (errorOnMissingDir) {\r\n                            illegal = new IllegalStateException(\"basedir \"\r\n                                                                + basedir\r\n                                                                + DOES_NOT_EXIST_POSTFIX);\r\n                        } else {\r\n                            // Nothing to do - basedir does not exist\r\n                            return;\r\n                        }\r\n                    } else if (!basedir.isDirectory()) {\r\n                        illegal = new IllegalStateException(\"basedir \"\r\n                                                            + basedir\r\n                                                            + \" is not a\"\r\n                                                            + \" directory.\");\r\n                    }\r\n                    if (illegal != null) {\r\n                        throw illegal;\r\n                    }\r\n                }\r\n                if (isIncluded(TokenizedPath.EMPTY_PATH)) {\r\n                    if (!isExcluded(TokenizedPath.EMPTY_PATH)) {\r\n                        if (isSelected(\"\", basedir)) {\r\n                            dirsIncluded.addElement(\"\");\r\n                        } else {\r\n                            dirsDeselected.addElement(\"\");\r\n                        }\r\n                    } else {\r\n                        dirsExcluded.addElement(\"\");\r\n                    }\r\n                } else {\r\n                    dirsNotIncluded.addElement(\"\");\r\n                }\r\n                checkIncludePatterns();\r\n                clearCaches();\r\n                includes = nullIncludes ? null : includes;\r\n                excludes = nullExcludes ? null : excludes;\r\n            }\r\n        } catch (IOException ex) {\r\n            throw new BuildException(ex);\r\n        } finally {\r\n            basedir = savedBase;\r\n            synchronized (scanLock) {\r\n                scanning = false;\r\n                scanLock.notifyAll();\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * This routine is actually checking all the include patterns in\r\n     * order to avoid scanning everything under base dir.\r\n     * @since Ant 1.6\r\n     */\r\n    private void checkIncludePatterns() {\r\n        ensureNonPatternSetsReady();\r\n        Map newroots = new HashMap();\r\n\r\n        // put in the newroots map the include patterns without\r\n        // wildcard tokens\r\n        for (int i = 0; i < includePatterns.length; i++) {\r\n            String pattern = includePatterns[i].toString();\r\n            if (!shouldSkipPattern(pattern)) {\r\n                newroots.put(includePatterns[i].rtrimWildcardTokens(),\r\n                             pattern);\r\n            }\r\n        }\r\n        for (Iterator iter = includeNonPatterns.entrySet().iterator();\r\n             iter.hasNext(); ) {\r\n            Map.Entry entry = (Map.Entry) iter.next();\r\n            String pattern = (String) entry.getKey();\r\n            if (!shouldSkipPattern(pattern)) {\r\n                newroots.put((TokenizedPath) entry.getValue(), pattern);\r\n            }\r\n        }\r\n\r\n        if (newroots.containsKey(TokenizedPath.EMPTY_PATH)\r\n            && basedir != null) {\r\n            // we are going to scan everything anyway\r\n            scandir(basedir, \"\", true);\r\n        } else {\r\n            // only scan directories that can include matched files or\r\n            // directories\r\n            Iterator it = newroots.entrySet().iterator();\r\n\r\n            File canonBase = null;\r\n            if (basedir != null) {\r\n                try {\r\n                    canonBase = basedir.getCanonicalFile();\r\n                } catch (IOException ex) {\r\n                    throw new BuildException(ex);\r\n                }\r\n            }\r\n            while (it.hasNext()) {\r\n                Map.Entry entry = (Map.Entry) it.next();\r\n                TokenizedPath currentPath = (TokenizedPath) entry.getKey();\r\n                String currentelement = currentPath.toString();\r\n                if (basedir == null\r\n                    && !FileUtils.isAbsolutePath(currentelement)) {\r\n                    continue;\r\n                }\r\n                File myfile = new File(basedir, currentelement);\r\n\r\n                if (myfile.exists()) {\r\n                    // may be on a case insensitive file system.  We want\r\n                    // the results to show what\'s really on the disk, so\r\n                    // we need to double check.\r\n                    try {\r\n                        String path = (basedir == null)\r\n                            ? myfile.getCanonicalPath()\r\n                            : FILE_UTILS.removeLeadingPath(canonBase,\r\n                                         myfile.getCanonicalFile());\r\n                        if (!path.equals(currentelement) || ON_VMS) {\r\n                            myfile = currentPath.findFile(basedir, true);\r\n                            if (myfile != null && basedir != null) {\r\n                                currentelement = FILE_UTILS.removeLeadingPath(\r\n                                    basedir, myfile);\r\n                                if (!currentPath.toString()\r\n                                    .equals(currentelement)) {\r\n                                    currentPath =\r\n                                        new TokenizedPath(currentelement);\r\n                                }\r\n                            }\r\n                        }\r\n                    } catch (IOException ex) {\r\n                        throw new BuildException(ex);\r\n                    }\r\n                }\r\n\r\n                if ((myfile == null || !myfile.exists()) && !isCaseSensitive()) {\r\n                    File f = currentPath.findFile(basedir, false);\r\n                    if (f != null && f.exists()) {\r\n                        // adapt currentelement to the case we\'ve\r\n                        // actually found\r\n                        currentelement = (basedir == null)\r\n                            ? f.getAbsolutePath()\r\n                            : FILE_UTILS.removeLeadingPath(basedir, f);\r\n                        myfile = f;\r\n                        currentPath = new TokenizedPath(currentelement);\r\n                    }\r\n                }\r\n\r\n                if (myfile != null && myfile.exists()) {\r\n                    if (!followSymlinks && currentPath.isSymlink(basedir)) {\r\n                        if (!isExcluded(currentPath)) {\r\n                            notFollowedSymlinks.add(myfile.getAbsolutePath());\r\n                        }\r\n                        continue;\r\n                    }\r\n                    if (myfile.isDirectory()) {\r\n                        if (isIncluded(currentPath)\r\n                            && currentelement.length() > 0) {\r\n                            accountForIncludedDir(currentPath, myfile, true);\r\n                        }  else {\r\n                            scandir(myfile, currentPath, true);\r\n                        }\r\n                    } else {\r\n                        String originalpattern = (String) entry.getValue();\r\n                        boolean included = isCaseSensitive()\r\n                            ? originalpattern.equals(currentelement)\r\n                            : originalpattern.equalsIgnoreCase(currentelement);\r\n                        if (included) {\r\n                            accountForIncludedFile(currentPath, myfile);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * true if the pattern specifies a relative path without basedir\r\n     * or an absolute path not inside basedir.\r\n     *\r\n     * @since Ant 1.8.0\r\n     */\r\n    private boolean shouldSkipPattern(String pattern) {\r\n        if (FileUtils.isAbsolutePath(pattern)) {\r\n            //skip abs. paths not under basedir, if set:\r\n            if (basedir != null\r\n                && !SelectorUtils.matchPatternStart(pattern,\r\n                                                    basedir.getAbsolutePath(),\r\n                                                    isCaseSensitive())) {\r\n                return true;\r\n            }\r\n        } else if (basedir == null) {\r\n            //skip non-abs. paths if basedir == null:\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Clear the result caches for a scan.\r\n     */\r\n    protected synchronized void clearResults() {\r\n        filesIncluded    = new VectorSet();\r\n        filesNotIncluded = new VectorSet();\r\n        filesExcluded    = new VectorSet();\r\n        filesDeselected  = new VectorSet();\r\n        dirsIncluded     = new VectorSet();\r\n        dirsNotIncluded  = new VectorSet();\r\n        dirsExcluded     = new VectorSet();\r\n        dirsDeselected   = new VectorSet();\r\n        everythingIncluded = (basedir != null);\r\n        scannedDirs.clear();\r\n        notFollowedSymlinks.clear();\r\n    }\r\n\r\n    /**\r\n     * Top level invocation for a slow scan. A slow scan builds up a full\r\n     * list of excluded/included files/directories, whereas a fast scan\r\n     * will only have full results for included files, as it ignores\r\n     * directories which can\'t possibly hold any included files/directories.\r\n     * <p>\r\n     * Returns immediately if a slow scan has already been completed.\r\n     */\r\n    protected void slowScan() {\r\n        synchronized (slowScanLock) {\r\n            if (haveSlowResults) {\r\n                return;\r\n            }\r\n            if (slowScanning) {\r\n                while (slowScanning) {\r\n                    try {\r\n                        slowScanLock.wait();\r\n                    } catch (InterruptedException e) {\r\n                        // Empty\r\n                    }\r\n                }\r\n                return;\r\n            }\r\n            slowScanning = true;\r\n        }\r\n        try {\r\n            synchronized (this) {\r\n\r\n                // set in/excludes to reasonable defaults if needed:\r\n                boolean nullIncludes = (includes == null);\r\n                includes = nullIncludes\r\n                    ? new String[] {SelectorUtils.DEEP_TREE_MATCH} : includes;\r\n                boolean nullExcludes = (excludes == null);\r\n                excludes = nullExcludes ? new String[0] : excludes;\r\n\r\n                String[] excl = new String[dirsExcluded.size()];\r\n                dirsExcluded.copyInto(excl);\r\n\r\n                String[] notIncl = new String[dirsNotIncluded.size()];\r\n                dirsNotIncluded.copyInto(notIncl);\r\n\r\n                ensureNonPatternSetsReady();\r\n\r\n                processSlowScan(excl);\r\n                processSlowScan(notIncl);\r\n                clearCaches();\r\n                includes = nullIncludes ? null : includes;\r\n                excludes = nullExcludes ? null : excludes;\r\n            }\r\n        } finally {\r\n            synchronized (slowScanLock) {\r\n                haveSlowResults = true;\r\n                slowScanning = false;\r\n                slowScanLock.notifyAll();\r\n            }\r\n        }\r\n    }\r\n\r\n    private void processSlowScan(String[] arr) {\r\n        for (int i = 0; i < arr.length; i++) {\r\n            TokenizedPath path  = new TokenizedPath(arr[i]);\r\n            if (!couldHoldIncluded(path) || contentsExcluded(path)) {\r\n                scandir(new File(basedir, arr[i]), path, false);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Scan the given directory for files and directories. Found files and\r\n     * directories are placed in their respective collections, based on the\r\n     * matching of includes, excludes, and the selectors.  When a directory\r\n     * is found, it is scanned recursively.\r\n     *\r\n     * @param dir   The directory to scan. Must not be <code>null</code>.\r\n     * @param vpath The path relative to the base directory (needed to\r\n     *              prevent problems with an absolute path when using\r\n     *              dir). Must not be <code>null</code>.\r\n     * @param fast  Whether or not this call is part of a fast scan.\r\n     *\r\n     * @see #filesIncluded\r\n     * @see #filesNotIncluded\r\n     * @see #filesExcluded\r\n     * @see #dirsIncluded\r\n     * @see #dirsNotIncluded\r\n     * @see #dirsExcluded\r\n     * @see #slowScan\r\n     */\r\n    protected void scandir(File dir, String vpath, boolean fast) {\r\n        scandir(dir, new TokenizedPath(vpath), fast);\r\n    }\r\n\r\n    /**\r\n     * Scan the given directory for files and directories. Found files and\r\n     * directories are placed in their respective collections, based on the\r\n     * matching of includes, excludes, and the selectors.  When a directory\r\n     * is found, it is scanned recursively.\r\n     *\r\n     * @param dir   The directory to scan. Must not be <code>null</code>.\r\n     * @param path The path relative to the base directory (needed to\r\n     *              prevent problems with an absolute path when using\r\n     *              dir). Must not be <code>null</code>.\r\n     * @param fast  Whether or not this call is part of a fast scan.\r\n     *\r\n     * @see #filesIncluded\r\n     * @see #filesNotIncluded\r\n     * @see #filesExcluded\r\n     * @see #dirsIncluded\r\n     * @see #dirsNotIncluded\r\n     * @see #dirsExcluded\r\n     * @see #slowScan\r\n     */\r\n    private void scandir(File dir, TokenizedPath path, boolean fast) {\r\n        if (dir == null) {\r\n            throw new BuildException(\"dir must not be null.\");\r\n        }\r\n        String[] newfiles = dir.list();\r\n        if (newfiles == null) {\r\n            if (!dir.exists()) {\r\n                throw new BuildException(dir + DOES_NOT_EXIST_POSTFIX);\r\n            } else if (!dir.isDirectory()) {\r\n                throw new BuildException(dir + \" is not a directory.\");\r\n            } else {\r\n                throw new BuildException(\"IO error scanning directory \'\"\r\n                                         + dir.getAbsolutePath() + \"\'\");\r\n            }\r\n        }\r\n        scandir(dir, path, fast, newfiles, new LinkedList());\r\n    }\r\n\r\n    private void scandir(File dir, TokenizedPath path, boolean fast,\r\n                         String[] newfiles, LinkedList directoryNamesFollowed) {\r\n        String vpath = path.toString();\r\n        if (vpath.length() > 0 && !vpath.endsWith(File.separator)) {\r\n            vpath += File.separator;\r\n        }\r\n\r\n        // avoid double scanning of directories, can only happen in fast mode\r\n        if (fast && hasBeenScanned(vpath)) {\r\n            return;\r\n        }\r\n        if (!followSymlinks) {\r\n            ArrayList noLinks = new ArrayList();\r\n            for (int i = 0; i < newfiles.length; i++) {\r\n                try {\r\n                    if (SYMLINK_UTILS.isSymbolicLink(dir, newfiles[i])) {\r\n                        String name = vpath + newfiles[i];\r\n                        File file = new File(dir, newfiles[i]);\r\n                        (file.isDirectory()\r\n                            ? dirsExcluded : filesExcluded).addElement(name);\r\n                        if (!isExcluded(name)) {\r\n                            notFollowedSymlinks.add(file.getAbsolutePath());\r\n                        }\r\n                    } else {\r\n                        noLinks.add(newfiles[i]);\r\n                    }\r\n                } catch (IOException ioe) {\r\n                    String msg = \"IOException caught while checking \"\r\n                        + \"for links, couldn\'t get canonical path!\";\r\n                    // will be caught and redirected to Ant\'s logging system\r\n                    System.err.println(msg);\r\n                    noLinks.add(newfiles[i]);\r\n                }\r\n            }\r\n            newfiles = (String[]) (noLinks.toArray(new String[noLinks.size()]));\r\n        } else {\r\n            directoryNamesFollowed.addFirst(dir.getName());\r\n        }\r\n\r\n        for (int i = 0; i < newfiles.length; i++) {\r\n            String name = vpath + newfiles[i];\r\n            TokenizedPath newPath = new TokenizedPath(path, newfiles[i]);\r\n            File file = new File(dir, newfiles[i]);\r\n            String[] children = file.list();\r\n            if (children == null || (children.length == 0 && file.isFile())) {\r\n                if (isIncluded(newPath)) {\r\n                    accountForIncludedFile(newPath, file);\r\n                } else {\r\n                    everythingIncluded = false;\r\n                    filesNotIncluded.addElement(name);\r\n                }\r\n            } else { // dir\r\n\r\n                if (followSymlinks\r\n                    && causesIllegalSymlinkLoop(newfiles[i], dir,\r\n                                                directoryNamesFollowed)) {\r\n                    // will be caught and redirected to Ant\'s logging system\r\n                    System.err.println(\"skipping symbolic link \"\r\n                                       + file.getAbsolutePath()\r\n                                       + \" -- too many levels of symbolic\"\r\n                                       + \" links.\");\r\n                    notFollowedSymlinks.add(file.getAbsolutePath());\r\n                    continue;\r\n                }\r\n\r\n                if (isIncluded(newPath)) {\r\n                    accountForIncludedDir(newPath, file, fast, children,\r\n                                          directoryNamesFollowed);\r\n                } else {\r\n                    everythingIncluded = false;\r\n                    dirsNotIncluded.addElement(name);\r\n                    if (fast && couldHoldIncluded(newPath)\r\n                        && !contentsExcluded(newPath)) {\r\n                        scandir(file, newPath, fast, children,\r\n                                directoryNamesFollowed);\r\n                    }\r\n                }\r\n                if (!fast) {\r\n                    scandir(file, newPath, fast, children, directoryNamesFollowed);\r\n                }\r\n            }\r\n        }\r\n\r\n        if (followSymlinks) {\r\n            directoryNamesFollowed.removeFirst();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Process included file.\r\n     * @param name  path of the file relative to the directory of the FileSet.\r\n     * @param file  included File.\r\n     */\r\n    private void accountForIncludedFile(TokenizedPath name, File file) {\r\n        processIncluded(name, file, filesIncluded, filesExcluded,\r\n                        filesDeselected);\r\n    }\r\n\r\n    /**\r\n     * Process included directory.\r\n     * @param name path of the directory relative to the directory of\r\n     *             the FileSet.\r\n     * @param file directory as File.\r\n     * @param fast whether to perform fast scans.\r\n     */\r\n    private void accountForIncludedDir(TokenizedPath name, File file,\r\n                                       boolean fast) {\r\n        processIncluded(name, file, dirsIncluded, dirsExcluded, dirsDeselected);\r\n        if (fast && couldHoldIncluded(name) && !contentsExcluded(name)) {\r\n            scandir(file, name, fast);\r\n        }\r\n    }\r\n\r\n    private void accountForIncludedDir(TokenizedPath name,\r\n                                       File file, boolean fast,\r\n                                       String[] children,\r\n                                       LinkedList directoryNamesFollowed) {\r\n        processIncluded(name, file, dirsIncluded, dirsExcluded, dirsDeselected);\r\n        if (fast && couldHoldIncluded(name) && !contentsExcluded(name)) {\r\n            scandir(file, name, fast, children, directoryNamesFollowed);\r\n        }\r\n    }\r\n\r\n    private void processIncluded(TokenizedPath path,\r\n                                 File file, Vector inc, Vector exc,\r\n                                 Vector des) {\r\n        String name = path.toString();\r\n        if (inc.contains(name) || exc.contains(name) || des.contains(name)) {\r\n            return;\r\n        }\r\n\r\n        boolean included = false;\r\n        if (isExcluded(path)) {\r\n            exc.add(name);\r\n        } else if (isSelected(name, file)) {\r\n            included = true;\r\n            inc.add(name);\r\n        } else {\r\n            des.add(name);\r\n        }\r\n        everythingIncluded &= included;\r\n    }\r\n\r\n    /**\r\n     * Test whether or not a name matches against at least one include\r\n     * pattern.\r\n     *\r\n     * @param name The name to match. Must not be <code>null</code>.\r\n     * @return <code>true</code> when the name matches against at least one\r\n     *         include pattern, or <code>false</code> otherwise.\r\n     */\r\n    protected boolean isIncluded(String name) {\r\n        return isIncluded(new TokenizedPath(name));\r\n    }\r\n\r\n    /**\r\n     * Test whether or not a name matches against at least one include\r\n     * pattern.\r\n     *\r\n     * @param name The name to match. Must not be <code>null</code>.\r\n     * @return <code>true</code> when the name matches against at least one\r\n     *         include pattern, or <code>false</code> otherwise.\r\n     */\r\n    private boolean isIncluded(TokenizedPath path) {\r\n        ensureNonPatternSetsReady();\r\n\r\n        if (isCaseSensitive()\r\n            ? includeNonPatterns.containsKey(path.toString())\r\n            : includeNonPatterns.containsKey(path.toString().toUpperCase())) {\r\n            return true;\r\n        }\r\n        for (int i = 0; i < includePatterns.length; i++) {\r\n            if (includePatterns[i].matchPath(path, isCaseSensitive())) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Test whether or not a name matches the start of at least one include\r\n     * pattern.\r\n     *\r\n     * @param name The name to match. Must not be <code>null</code>.\r\n     * @return <code>true</code> when the name matches against the start of at\r\n     *         least one include pattern, or <code>false</code> otherwise.\r\n     */\r\n    protected boolean couldHoldIncluded(String name) {\r\n        return couldHoldIncluded(new TokenizedPath(name));\r\n    }\r\n\r\n    /**\r\n     * Test whether or not a name matches the start of at least one include\r\n     * pattern.\r\n     *\r\n     * @param tokenizedName The name to match. Must not be <code>null</code>.\r\n     * @return <code>true</code> when the name matches against the start of at\r\n     *         least one include pattern, or <code>false</code> otherwise.\r\n     */\r\n    private boolean couldHoldIncluded(TokenizedPath tokenizedName) {\r\n        for (int i = 0; i < includePatterns.length; i++) {\r\n            if (couldHoldIncluded(tokenizedName, includePatterns[i])) {\r\n                return true;\r\n            }\r\n        }\r\n        for (Iterator iter = includeNonPatterns.values().iterator();\r\n             iter.hasNext(); ) {\r\n            if (couldHoldIncluded(tokenizedName,\r\n                                  ((TokenizedPath) iter.next()).toPattern())) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Test whether or not a name matches the start of the given\r\n     * include pattern.\r\n     *\r\n     * @param tokenizedName The name to match. Must not be <code>null</code>.\r\n     * @return <code>true</code> when the name matches against the start of the\r\n     *         include pattern, or <code>false</code> otherwise.\r\n     */\r\n    private boolean couldHoldIncluded(TokenizedPath tokenizedName,\r\n                                      TokenizedPattern tokenizedInclude) {\r\n        return tokenizedInclude.matchStartOf(tokenizedName, isCaseSensitive())\r\n            && isMorePowerfulThanExcludes(tokenizedName.toString())\r\n            && isDeeper(tokenizedInclude, tokenizedName);\r\n    }\r\n\r\n    /**\r\n     * Verify that a pattern specifies files deeper\r\n     * than the level of the specified file.\r\n     * @param pattern the pattern to check.\r\n     * @param name the name to check.\r\n     * @return whether the pattern is deeper than the name.\r\n     * @since Ant 1.6.3\r\n     */\r\n    private boolean isDeeper(TokenizedPattern pattern, TokenizedPath name) {\r\n        return pattern.containsPattern(SelectorUtils.DEEP_TREE_MATCH)\r\n            || pattern.depth() > name.depth();\r\n    }\r\n\r\n    /**\r\n     *  Find out whether one particular include pattern is more powerful\r\n     *  than all the excludes.\r\n     *  Note:  the power comparison is based on the length of the include pattern\r\n     *  and of the exclude patterns without the wildcards.\r\n     *  Ideally the comparison should be done based on the depth\r\n     *  of the match; that is to say how many file separators have been matched\r\n     *  before the first ** or the end of the pattern.\r\n     *\r\n     *  IMPORTANT : this function should return false \"with care\".\r\n     *\r\n     *  @param name the relative path to test.\r\n     *  @return true if there is no exclude pattern more powerful than\r\n     *  this include pattern.\r\n     *  @since Ant 1.6\r\n     */\r\n    private boolean isMorePowerfulThanExcludes(String name) {\r\n        final String soughtexclude =\r\n            name + File.separatorChar + SelectorUtils.DEEP_TREE_MATCH;\r\n        for (int counter = 0; counter < excludePatterns.length; counter++) {\r\n            if (excludePatterns[counter].toString().equals(soughtexclude))  {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Test whether all contents of the specified directory must be excluded.\r\n     * @param path the path to check.\r\n     * @return whether all the specified directory\'s contents are excluded.\r\n     */\r\n    /* package */ boolean contentsExcluded(TokenizedPath path) {\r\n        for (int i = 0; i < excludePatterns.length; i++) {\r\n            if (excludePatterns[i].endsWith(SelectorUtils.DEEP_TREE_MATCH)\r\n                && excludePatterns[i].withoutLastToken()\r\n                   .matchPath(path, isCaseSensitive())) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Test whether or not a name matches against at least one exclude\r\n     * pattern.\r\n     *\r\n     * @param name The name to match. Must not be <code>null</code>.\r\n     * @return <code>true</code> when the name matches against at least one\r\n     *         exclude pattern, or <code>false</code> otherwise.\r\n     */\r\n    protected boolean isExcluded(String name) {\r\n        return isExcluded(new TokenizedPath(name));\r\n    }\r\n\r\n    /**\r\n     * Test whether or not a name matches against at least one exclude\r\n     * pattern.\r\n     *\r\n     * @param name The name to match. Must not be <code>null</code>.\r\n     * @return <code>true</code> when the name matches against at least one\r\n     *         exclude pattern, or <code>false</code> otherwise.\r\n     */\r\n    private boolean isExcluded(TokenizedPath name) {\r\n        ensureNonPatternSetsReady();\r\n\r\n        if (isCaseSensitive()\r\n            ? excludeNonPatterns.containsKey(name.toString())\r\n            : excludeNonPatterns.containsKey(name.toString().toUpperCase())) {\r\n            return true;\r\n        }\r\n        for (int i = 0; i < excludePatterns.length; i++) {\r\n            if (excludePatterns[i].matchPath(name, isCaseSensitive())) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Test whether a file should be selected.\r\n     *\r\n     * @param name the filename to check for selecting.\r\n     * @param file the java.io.File object for this filename.\r\n     * @return <code>false</code> when the selectors says that the file\r\n     *         should not be selected, <code>true</code> otherwise.\r\n     */\r\n    protected boolean isSelected(String name, File file) {\r\n        if (selectors != null) {\r\n            for (int i = 0; i < selectors.length; i++) {\r\n                if (!selectors[i].isSelected(basedir, name, file)) {\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Return the names of the files which matched at least one of the\r\n     * include patterns and none of the exclude patterns.\r\n     * The names are relative to the base directory.\r\n     *\r\n     * @return the names of the files which matched at least one of the\r\n     *         include patterns and none of the exclude patterns.\r\n     */\r\n    public String[] getIncludedFiles() {\r\n        String[] files;\r\n        synchronized (this) {\r\n            if (filesIncluded == null) {\r\n                throw new IllegalStateException(\"Must call scan() first\");\r\n            }\r\n            files = new String[filesIncluded.size()];\r\n            filesIncluded.copyInto(files);\r\n        }\r\n        Arrays.sort(files);\r\n        return files;\r\n    }\r\n\r\n    /**\r\n     * Return the count of included files.\r\n     * @return <code>int</code>.\r\n     * @since Ant 1.6.3\r\n     */\r\n    public synchronized int getIncludedFilesCount() {\r\n        if (filesIncluded == null) {\r\n            throw new IllegalStateException(\"Must call scan() first\");\r\n        }\r\n        return filesIncluded.size();\r\n    }\r\n\r\n    /**\r\n     * Return the names of the files which matched none of the include\r\n     * patterns. The names are relative to the base directory. This involves\r\n     * performing a slow scan if one has not already been completed.\r\n     *\r\n     * @return the names of the files which matched none of the include\r\n     *         patterns.\r\n     *\r\n     * @see #slowScan\r\n     */\r\n    public synchronized String[] getNotIncludedFiles() {\r\n        slowScan();\r\n        String[] files = new String[filesNotIncluded.size()];\r\n        filesNotIncluded.copyInto(files);\r\n        return files;\r\n    }\r\n\r\n    /**\r\n     * Return the names of the files which matched at least one of the\r\n     * include patterns and at least one of the exclude patterns.\r\n     * The names are relative to the base directory. This involves\r\n     * performing a slow scan if one has not already been completed.\r\n     *\r\n     * @return the names of the files which matched at least one of the\r\n     *         include patterns and at least one of the exclude patterns.\r\n     *\r\n     * @see #slowScan\r\n     */\r\n    public synchronized String[] getExcludedFiles() {\r\n        slowScan();\r\n        String[] files = new String[filesExcluded.size()];\r\n        filesExcluded.copyInto(files);\r\n        return files;\r\n    }\r\n\r\n    /**\r\n     * <p>Return the names of the files which were selected out and\r\n     * therefore not ultimately included.</p>\r\n     *\r\n     * <p>The names are relative to the base directory. This involves\r\n     * performing a slow scan if one has not already been completed.</p>\r\n     *\r\n     * @return the names of the files which were deselected.\r\n     *\r\n     * @see #slowScan\r\n     */\r\n    public synchronized String[] getDeselectedFiles() {\r\n        slowScan();\r\n        String[] files = new String[filesDeselected.size()];\r\n        filesDeselected.copyInto(files);\r\n        return files;\r\n    }\r\n\r\n    /**\r\n     * Return the names of the directories which matched at least one of the\r\n     * include patterns and none of the exclude patterns.\r\n     * The names are relative to the base directory.\r\n     *\r\n     * @return the names of the directories which matched at least one of the\r\n     * include patterns and none of the exclude patterns.\r\n     */\r\n    public String[] getIncludedDirectories() {\r\n        String[] directories;\r\n        synchronized (this) {\r\n            if (dirsIncluded == null) {\r\n                throw new IllegalStateException(\"Must call scan() first\");\r\n            }\r\n            directories = new String[dirsIncluded.size()];\r\n            dirsIncluded.copyInto(directories);\r\n        }\r\n        Arrays.sort(directories);\r\n        return directories;\r\n    }\r\n\r\n    /**\r\n     * Return the count of included directories.\r\n     * @return <code>int</code>.\r\n     * @since Ant 1.6.3\r\n     */\r\n    public synchronized int getIncludedDirsCount() {\r\n        if (dirsIncluded == null) {\r\n            throw new IllegalStateException(\"Must call scan() first\");\r\n        }\r\n        return dirsIncluded.size();\r\n    }\r\n\r\n    /**\r\n     * Return the names of the directories which matched none of the include\r\n     * patterns. The names are relative to the base directory. This involves\r\n     * performing a slow scan if one has not already been completed.\r\n     *\r\n     * @return the names of the directories which matched none of the include\r\n     * patterns.\r\n     *\r\n     * @see #slowScan\r\n     */\r\n    public synchronized String[] getNotIncludedDirectories() {\r\n        slowScan();\r\n        String[] directories = new String[dirsNotIncluded.size()];\r\n        dirsNotIncluded.copyInto(directories);\r\n        return directories;\r\n    }\r\n\r\n    /**\r\n     * Return the names of the directories which matched at least one of the\r\n     * include patterns and at least one of the exclude patterns.\r\n     * The names are relative to the base directory. This involves\r\n     * performing a slow scan if one has not already been completed.\r\n     *\r\n     * @return the names of the directories which matched at least one of the\r\n     * include patterns and at least one of the exclude patterns.\r\n     *\r\n     * @see #slowScan\r\n     */\r\n    public synchronized String[] getExcludedDirectories() {\r\n        slowScan();\r\n        String[] directories = new String[dirsExcluded.size()];\r\n        dirsExcluded.copyInto(directories);\r\n        return directories;\r\n    }\r\n\r\n    /**\r\n     * <p>Return the names of the directories which were selected out and\r\n     * therefore not ultimately included.</p>\r\n     *\r\n     * <p>The names are relative to the base directory. This involves\r\n     * performing a slow scan if one has not already been completed.</p>\r\n     *\r\n     * @return the names of the directories which were deselected.\r\n     *\r\n     * @see #slowScan\r\n     */\r\n    public synchronized String[] getDeselectedDirectories() {\r\n        slowScan();\r\n        String[] directories = new String[dirsDeselected.size()];\r\n        dirsDeselected.copyInto(directories);\r\n        return directories;\r\n    }\r\n\r\n    /**\r\n     * Absolute paths of all symbolic links that haven\'t been followed\r\n     * but would have been followed had followsymlinks been true or\r\n     * maxLevelsOfSymlinks been bigger.\r\n     *\r\n     * @since Ant 1.8.0\r\n     */\r\n    public synchronized String[] getNotFollowedSymlinks() {\r\n        String[] links;\r\n        synchronized (this) {\r\n            links = (String[]) notFollowedSymlinks\r\n                .toArray(new String[notFollowedSymlinks.size()]);\r\n        }\r\n        Arrays.sort(links);\r\n        return links;\r\n    }\r\n\r\n    /**\r\n     * Add default exclusions to the current exclusions set.\r\n     */\r\n    public synchronized void addDefaultExcludes() {\r\n        int excludesLength = excludes == null ? 0 : excludes.length;\r\n        String[] newExcludes;\r\n        String[] defaultExcludesTemp = getDefaultExcludes();\r\n        newExcludes = new String[excludesLength + defaultExcludesTemp.length];\r\n        if (excludesLength > 0) {\r\n            System.arraycopy(excludes, 0, newExcludes, 0, excludesLength);\r\n        }\r\n        for (int i = 0; i < defaultExcludesTemp.length; i++) {\r\n            newExcludes[i + excludesLength] =\r\n                defaultExcludesTemp[i].replace(\'/\', File.separatorChar)\r\n                .replace(\'\\\\\', File.separatorChar);\r\n        }\r\n        excludes = newExcludes;\r\n    }\r\n\r\n    /**\r\n     * Get the named resource.\r\n     * @param name path name of the file relative to the dir attribute.\r\n     *\r\n     * @return the resource with the given name.\r\n     * @since Ant 1.5.2\r\n     */\r\n    public synchronized Resource getResource(String name) {\r\n        return new FileResource(basedir, name);\r\n    }\r\n\r\n    /**\r\n     * Has the directory with the given path relative to the base\r\n     * directory already been scanned?\r\n     *\r\n     * <p>Registers the given directory as scanned as a side effect.</p>\r\n     *\r\n     * @since Ant 1.6\r\n     */\r\n    private boolean hasBeenScanned(String vpath) {\r\n        return !scannedDirs.add(vpath);\r\n    }\r\n\r\n    /**\r\n     * This method is of interest for testing purposes.  The returned\r\n     * Set is live and should not be modified.\r\n     * @return the Set of relative directory names that have been scanned.\r\n     */\r\n    /* package-private */ Set getScannedDirs() {\r\n        return scannedDirs;\r\n    }\r\n\r\n    /**\r\n     * Clear internal caches.\r\n     *\r\n     * @since Ant 1.6\r\n     */\r\n    private synchronized void clearCaches() {\r\n        includeNonPatterns.clear();\r\n        excludeNonPatterns.clear();\r\n        includePatterns = null;\r\n        excludePatterns = null;\r\n        areNonPatternSetsReady = false;\r\n    }\r\n\r\n    /**\r\n     * Ensure that the in|exclude &quot;patterns&quot;\r\n     * have been properly divided up.\r\n     *\r\n     * @since Ant 1.6.3\r\n     */\r\n    /* package */ synchronized void ensureNonPatternSetsReady() {\r\n        if (!areNonPatternSetsReady) {\r\n            includePatterns = fillNonPatternSet(includeNonPatterns, includes);\r\n            excludePatterns = fillNonPatternSet(excludeNonPatterns, excludes);\r\n            areNonPatternSetsReady = true;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Add all patterns that are not real patterns (do not contain\r\n     * wildcards) to the set and returns the real patterns.\r\n     *\r\n     * @param map Map to populate.\r\n     * @param patterns String[] of patterns.\r\n     * @since Ant 1.8.0\r\n     */\r\n    private TokenizedPattern[] fillNonPatternSet(Map map, String[] patterns) {\r\n        ArrayList al = new ArrayList(patterns.length);\r\n        for (int i = 0; i < patterns.length; i++) {\r\n            if (!SelectorUtils.hasWildcards(patterns[i])) {\r\n                String s = isCaseSensitive()\r\n                    ? patterns[i] : patterns[i].toUpperCase();\r\n                map.put(s, new TokenizedPath(s));\r\n            } else {\r\n                al.add(new TokenizedPattern(patterns[i]));\r\n            }\r\n        }\r\n        return (TokenizedPattern[]) al.toArray(new TokenizedPattern[al.size()]);\r\n    }\r\n\r\n    /**\r\n     * Would following the given directory cause a loop of symbolic\r\n     * links deeper than allowed?\r\n     *\r\n     * <p>Can only happen if the given directory has been seen at\r\n     * least more often than allowed during the current scan and it is\r\n     * a symbolic link and enough other occurences of the same name\r\n     * higher up are symbolic links that point to the same place.</p>\r\n     *\r\n     * @since Ant 1.8.0\r\n     */\r\n    private boolean causesIllegalSymlinkLoop(String dirName, File parent,\r\n                                             LinkedList directoryNamesFollowed) {\r\n        try {\r\n            if (directoryNamesFollowed.size() >= maxLevelsOfSymlinks\r\n                && CollectionUtils.frequency(directoryNamesFollowed, dirName)\r\n                   >= maxLevelsOfSymlinks\r\n                && SYMLINK_UTILS.isSymbolicLink(parent, dirName)) {\r\n\r\n                ArrayList files = new ArrayList();\r\n                File f = FILE_UTILS.resolveFile(parent, dirName);\r\n                String target = f.getCanonicalPath();\r\n                files.add(target);\r\n\r\n                String relPath = \"\";\r\n                for (Iterator i = directoryNamesFollowed.iterator();\r\n                     i.hasNext(); ) {\r\n                    relPath += \"../\";\r\n                    String dir = (String) i.next();\r\n                    if (dirName.equals(dir)) {\r\n                        f = FILE_UTILS.resolveFile(parent, relPath + dir);\r\n                        files.add(f.getCanonicalPath());\r\n                        if (files.size() > maxLevelsOfSymlinks\r\n                            && CollectionUtils.frequency(files, target)\r\n                                 > maxLevelsOfSymlinks) {\r\n                            return true;\r\n                        }\r\n                    }\r\n                }\r\n\r\n            }\r\n            return false;\r\n        } catch (IOException ex) {\r\n            throw new BuildException(\"Caught error while checking for\"\r\n                                     + \" symbolic links\", ex);\r\n        }\r\n    }\r\n\r\n}','Public Class','ant','org.apache.tools.ant.DirectoryScanner',1,1,0),(4,'M','lm','public ResolvedModuleRevision getDependency(DependencyDescriptor dd, ResolveData data) throws ParseException {\r\n	IvyContext context = IvyContext.pushNewCopyContext();\r\n	try {\r\n		ResolvedModuleRevision mr = data.getCurrentResolvedModuleRevision();\r\n		if (mr != null) {\r\n			if (shouldReturnResolvedModule(dd, mr)) {\r\n				return mr;\r\n			}\r\n		}\r\n		\r\n		if (isForce()) {\r\n			dd = dd.clone(ModuleRevisionId.newInstance(\r\n			dd.getDependencyRevisionId(), \"latest.integration\"));\r\n		}\r\n		DependencyDescriptor systemDd = dd;\r\n		DependencyDescriptor nsDd = fromSystem(dd);\r\n		context.setDependencyDescriptor(systemDd);\r\n		context.setResolveData(data);\r\n		\r\n		clearIvyAttempts();\r\n		clearArtifactAttempts();\r\n		ModuleRevisionId systemMrid = systemDd.getDependencyRevisionId();\r\n		ModuleRevisionId nsMrid = nsDd.getDependencyRevisionId();\r\n		\r\n		checkRevision(systemMrid);\r\n\r\n		boolean isDynamic = getAndCheckIsDynamic(systemMrid);\r\n\r\n		// we first search for the dependency in cache\r\n		ResolvedModuleRevision rmr = null;\r\n		rmr = findModuleInCache(systemDd, data);\r\n		if (rmr != null) {\r\n			if (rmr.getDescriptor().isDefault() && rmr.getResolver() != this) {\r\n				Message.verbose(\"\\t\" + getName() + \": found revision in cache: \" \r\n				+ systemMrid\r\n				+ \" (resolved by \" + rmr.getResolver().getName()\r\n				+ \"): but it\'s a default one, maybe we can find a better one\");\r\n			} else if (isForce() && rmr.getResolver() != this) {\r\n				Message.verbose(\"\\t\" + getName() + \": found revision in cache: \" \r\n				+ systemMrid\r\n				+ \" (resolved by \" + rmr.getResolver().getName()\r\n				+ \"): but we are in force mode, let\'s try to find one ourself\");\r\n			} else {\r\n				Message.verbose(\"\\t\" + getName() + \": revision in cache: \" + systemMrid);\r\n				return checkLatest(systemDd, checkForcedResolvedModuleRevision(rmr), data);\r\n			}\r\n		}\r\n		\r\n		checkInterrupted();\r\n		\r\n		ResolvedResource ivyRef = findIvyFileRef(nsDd, data);\r\n		checkInterrupted();\r\n\r\n		// get module descriptor\r\n		ModuleDescriptor nsMd;\r\n		ModuleDescriptor systemMd = null;\r\n		if (ivyRef == null) {\r\n			if (!isAllownomd()) {\r\n				throw new UnresolvedDependencyException(\r\n				\"\\t\" + getName() + \": no ivy file found for \" + systemMrid, false);\r\n			}\r\n			nsMd = DefaultModuleDescriptor.newDefaultInstance(nsMrid, nsDd\r\n			.getAllDependencyArtifacts());\r\n			ResolvedResource artifactRef = findFirstArtifactRef(nsMd, nsDd, data);\r\n			checkInterrupted();\r\n			if (artifactRef == null) {\r\n				throw new UnresolvedDependencyException(\"\\t\" + getName() \r\n				+ \": no ivy file nor artifact found for \" + systemMrid, false);\r\n			} else {\r\n				long lastModified = artifactRef.getLastModified();\r\n				if (lastModified != 0 && nsMd instanceof DefaultModuleDescriptor) {\r\n					((DefaultModuleDescriptor) nsMd).setLastModified(lastModified);\r\n				}\r\n				Message.verbose(\"\\t\" + getName() + \": no ivy file found for \" + systemMrid\r\n				+ \": using default data\");\r\n				if (isDynamic) {\r\n					nsMd.setResolvedModuleRevisionId(ModuleRevisionId.newInstance(nsMrid,\r\n					artifactRef.getRevision()));\r\n				}\r\n				systemMd = toSystem(nsMd);\r\n				MetadataArtifactDownloadReport madr = \r\n				new MetadataArtifactDownloadReport(systemMd.getMetadataArtifact());\r\n				madr.setDownloadStatus(DownloadStatus.NO);\r\n				madr.setSearched(true);\r\n				rmr = new ResolvedModuleRevision(this, this, systemMd, madr, isForce());\r\n			}\r\n		} else {\r\n			if (ivyRef instanceof MDResolvedResource) {\r\n				rmr = ((MDResolvedResource) ivyRef).getResolvedModuleRevision();\r\n			}\r\n			if (rmr == null) {\r\n				rmr = parse(ivyRef, systemDd, data);\r\n				if (rmr == null) {\r\n					throw new UnresolvedDependencyException();\r\n				}\r\n			}\r\n			if (!rmr.getReport().isDownloaded() \r\n					&& rmr.getReport().getLocalFile() != null) {\r\n				return checkLatest(systemDd, checkForcedResolvedModuleRevision(rmr), data);\r\n			} else {\r\n				nsMd = rmr.getDescriptor();\r\n\r\n				// check descriptor data is in sync with resource revision and names\r\n				systemMd = toSystem(nsMd);\r\n				if (isCheckconsistency()) {\r\n					checkDescriptorConsistency(systemMrid, systemMd, ivyRef);\r\n					checkDescriptorConsistency(nsMrid, nsMd, ivyRef);\r\n				} else {\r\n					if (systemMd instanceof DefaultModuleDescriptor) {\r\n						DefaultModuleDescriptor defaultMd = (DefaultModuleDescriptor) systemMd;\r\n						ModuleRevisionId revision = getRevision(ivyRef, systemMrid, systemMd);\r\n						defaultMd.setModuleRevisionId(revision);\r\n						defaultMd.setResolvedModuleRevisionId(revision);\r\n					} else {\r\n						Message.warn(\r\n						\"consistency disabled with instance of non DefaultModuleDescriptor...\"\r\n						+ \" module info can\'t be updated, so consistency check will be done\");\r\n						checkDescriptorConsistency(nsMrid, nsMd, ivyRef);\r\n						checkDescriptorConsistency(systemMrid, systemMd, ivyRef);\r\n					}\r\n				}\r\n				rmr = new ResolvedModuleRevision(\r\n				this, this, systemMd, toSystem(rmr.getReport()), isForce());\r\n			}\r\n		}\r\n\r\n		resolveAndCheckRevision(systemMd, systemMrid, ivyRef, isDynamic);\r\n		resolveAndCheckPublicationDate(systemDd, systemMd, systemMrid, data);\r\n		checkNotConvertedExclusionRule(systemMd, ivyRef, data);\r\n\r\n		cacheModuleDescriptor(systemMd, systemMrid, ivyRef, rmr);            \r\n		\r\n		return checkLatest(systemDd, checkForcedResolvedModuleRevision(rmr), data);\r\n	} catch (UnresolvedDependencyException ex) {\r\n		if (ex.getMessage().length() > 0) {\r\n			if (ex.isError()) {\r\n				Message.error(ex.getMessage());\r\n			} else {\r\n				Message.verbose(ex.getMessage());\r\n			}\r\n		}\r\n		return data.getCurrentResolvedModuleRevision();\r\n	} finally {\r\n		IvyContext.popContext();\r\n	}\r\n}','Public Method','ivy','org.apache.ivy.plugins.resolver.BasicResolver.getDependency',1,4,0),(5,'C','mm','/*\r\n*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*\r\n*/\r\npackage org.apache.qpid.tools.report;\r\n\r\nimport java.io.PrintStream;\r\n\r\nimport org.apache.qpid.tools.report.Statistics.Throughput;\r\nimport org.apache.qpid.tools.report.Statistics.ThroughputAndLatency;\r\n\r\npublic class MercuryReporter extends BasicReporter\r\n{\r\n	MercuryStatistics stats;\r\n\r\n	public MercuryReporter(Class<? extends MercuryStatistics> clazz, PrintStream out,\r\n	int batchSize, boolean printHeader) throws Exception\r\n	{\r\n		super(clazz, out, batchSize, printHeader);\r\n		stats = (MercuryStatistics)overall;\r\n	}\r\n\r\n	public double getRate()\r\n	{\r\n		return stats.getRate();\r\n	}\r\n\r\n	public double getAvgLatency()\r\n	{\r\n		return stats.getAvgLatency();\r\n	}\r\n\r\n	public double getStdDev()\r\n	{\r\n		return stats.getStdDev();\r\n	}\r\n\r\n	public double getMinLatency()\r\n	{\r\n		return stats.getMinLatency();\r\n	}\r\n\r\n	public double getMaxLatency()\r\n	{\r\n		return stats.getMaxLatency();\r\n	}\r\n\r\n	public int getSampleSize()\r\n	{\r\n		return stats.getSampleSize();\r\n	}\r\n\r\n	public interface MercuryStatistics extends Statistics\r\n	{\r\n		public double getRate();\r\n		public long getMinLatency();\r\n		public long getMaxLatency();\r\n		public double getAvgLatency();\r\n		public double getStdDev();\r\n		public int getSampleSize();\r\n	}\r\n\r\n	public static class MercuryThroughput extends Throughput implements MercuryStatistics\r\n	{\r\n		double rate = 0;\r\n\r\n		@Override\r\n		public void report(PrintStream out)\r\n		{\r\n			long elapsed = System.currentTimeMillis() - start;\r\n			rate = (double)messages/(double)elapsed;\r\n		}\r\n\r\n		@Override\r\n		public void clear()\r\n		{\r\n			super.clear();\r\n			rate = 0;\r\n		}\r\n\r\n		public double getRate()\r\n		{\r\n			return rate;\r\n		}\r\n\r\n		public int getSampleSize()\r\n		{\r\n			return messages;\r\n		}\r\n\r\n		public long getMinLatency() { return 0; }\r\n		public long getMaxLatency() { return 0; }\r\n		public double getAvgLatency(){ return 0; }\r\n		public double getStdDev(){ return 0; }\r\n\r\n	}\r\n\r\n	public static class MercuryThroughputAndLatency extends ThroughputAndLatency implements MercuryStatistics\r\n	{\r\n		double rate = 0;\r\n		double avgLatency = 0;\r\n		double stdDev;\r\n\r\n		@Override\r\n		public void report(PrintStream out)\r\n		{\r\n			long elapsed = System.currentTimeMillis() - start;\r\n			rate = (double)messages/(double)elapsed;\r\n			avgLatency = totalLatency/(double)sampleCount;\r\n		}\r\n\r\n		@Override\r\n		public void clear()\r\n		{\r\n			super.clear();\r\n			rate = 0;\r\n			avgLatency = 0;\r\n		}\r\n\r\n		public double getRate()\r\n		{\r\n			return rate;\r\n		}\r\n\r\n		public long getMinLatency()\r\n		{ \r\n			return minLatency; \r\n		}\r\n\r\n		public long getMaxLatency() \r\n		{ \r\n			return maxLatency; \r\n		}\r\n\r\n		public double getAvgLatency()\r\n		{ \r\n			return avgLatency; \r\n		}\r\n\r\n		public double getStdDev()\r\n		{ \r\n			return stdDev; \r\n		}\r\n\r\n		public int getSampleSize()\r\n		{\r\n			return messages;\r\n		}\r\n	}\r\n\r\n}','Public Class','qpid','org.apache.qpid.tools.report.MercuryReporter',2,2,0),(6,'M','lm','@Override\r\n    public boolean check(List<LogicalOperator> nodes) throws OptimizerException {\r\n        try {\r\n            LOFilter filter = (LOFilter) getOperator(nodes);\r\n            List<LogicalOperator> predecessors = (mPlan.getPredecessors(filter) == null ? null\r\n                    : new ArrayList<LogicalOperator>(mPlan\r\n                            .getPredecessors(filter)));\r\n\r\n            // if there are no predecessors return false\r\n            if (predecessors == null) {\r\n                return false;\r\n            }\r\n\r\n            // if the filter has no predecessors or more than one predecessor\r\n            // return false\r\n            if (predecessors.size() == 0 || predecessors.size() > 1) {\r\n                return false;\r\n            }\r\n                \r\n            LogicalOperator predecessor = predecessors.get(0);\r\n\r\n            // if the predecessor is one of LOLoad/LOStore/LOStream/LOLimit/LONative\r\n            // return false\r\n            if (predecessor instanceof LOLoad || predecessor instanceof LOStore\r\n                    || predecessor instanceof LOStream\r\n                    || predecessor instanceof LOLimit \r\n                    || predecessor instanceof LONative) {\r\n                return false;\r\n            }\r\n            \r\n            // TODO\r\n            // for now filters cannot be combined\r\n            // remove this check when filters can be combined\r\n            if (predecessor instanceof LOFilter)\r\n                return false;\r\n\r\n            // TODO\r\n            // same rule as filters\r\n            if (predecessor instanceof LOSplitOutput) {\r\n                return false;\r\n            }\r\n            if (predecessor instanceof LOSplit) {\r\n                return false;\r\n            }\r\n\r\n            UDFFinder udfFinder = new UDFFinder(filter.getComparisonPlan());\r\n            udfFinder.visit();\r\n\r\n            // if the filter\'s inner plan contains any UDF then return false\r\n            if (udfFinder.foundAnyUDF()) {\r\n                return false;\r\n            }\r\n\r\n            CastFinder castFinder = new CastFinder(filter.getComparisonPlan());\r\n            castFinder.visit();\r\n\r\n            // if the filter\'s inner plan contains any casts then return false\r\n            if (castFinder.foundAnyCast()) {\r\n                return false;\r\n            }\r\n\r\n            List<RequiredFields> filterRequiredFields = filter\r\n                    .getRequiredFields();\r\n            if (filterRequiredFields == null) {\r\n                return false;\r\n            }\r\n            RequiredFields requiredField = filterRequiredFields.get(0);\r\n\r\n            // the filter\'s conditions contain constant expression\r\n            // return false\r\n            if (requiredField.needNoFields()) {\r\n                return false;\r\n            }\r\n\r\n            // if the predecessor is a multi-input operator then detailed\r\n            // checks are required\r\n            if (predecessor instanceof LOCross\r\n                    || predecessor instanceof LOUnion\r\n                    || predecessor instanceof LOCogroup\r\n                    || predecessor instanceof LOJoin) {\r\n\r\n                // check if the filter\'s required fields in conjunction with the\r\n                // predecessor\'s projection map. If the filter needs more than\r\n                // one input then the filter\'s expressions have to be split\r\n\r\n                List<LogicalOperator> grandParents = mPlan\r\n                        .getPredecessors(predecessor);\r\n\r\n                // if the predecessor does not have predecessors return false\r\n                if (grandParents == null || grandParents.size() == 0) {\r\n                    return false;\r\n                }\r\n                \r\n                // check if the predecessor is a group by\r\n                if (grandParents.size() == 1) {\r\n                    if (predecessor instanceof LOCogroup) {\r\n                        mSwap = true;\r\n                        return true;\r\n                    } else {\r\n                        // only a group by can have a single input\r\n                        return false;\r\n                    }\r\n                }\r\n\r\n                if (requiredField.needAllFields()) {\r\n                    return false;\r\n                }\r\n\r\n                Pair<Boolean, Set<Integer>> mappingResult = isRequiredFieldMapped(requiredField, predecessor.getProjectionMap());\r\n                boolean mapped = mappingResult.first;\r\n                Set<Integer> grandParentIndexes = mappingResult.second;\r\n                if (!mapped) {\r\n                    return false;\r\n                }\r\n                \r\n                // TODO\r\n                // the filter\'s conditions requires more than one input of its\r\n                // predecessor\r\n                // when the filter\'s conditions are splittable return true\r\n                if ((grandParentIndexes == null)\r\n                        || (grandParentIndexes.size() == 0)\r\n                        || (grandParentIndexes.size() > 1)) {\r\n                    return false;\r\n                }\r\n\r\n                if (predecessor instanceof LOCogroup) {\r\n                    // check for outer\r\n                    if (isAnyOuter((LOCogroup) predecessor)) {\r\n                        return false;\r\n                    }\r\n                }\r\n                \r\n                mPushBeforeInput = grandParentIndexes.iterator().next();\r\n                \r\n                if (predecessor instanceof LOJoin) {\r\n                    boolean otherBranchContainOuter = false;\r\n                    boolean sawInner = false;\r\n                    for (int i=0;i<=mPlan.getSuccessors(predecessor).size();i++) {\r\n                        // We do not push filter if any other branch is outer\r\n                        // See PIG-1289\r\n                        // Also in LOJoin, innerFlag==true indicate that branch is the outer join side\r\n                        // which has the exact opposite semantics\r\n                        // If all innerFlag is true, that implies a regular join\r\n                        // If all innerFlag is false, means a outer join, in this case, we can not push up filter for any path (See PIG-1507)\r\n                        if (i!=mPushBeforeInput && ((LOJoin)predecessor).getInnerFlags()[i]) {\r\n                            otherBranchContainOuter = true;\r\n                        }\r\n                        if (((LOJoin)predecessor).getInnerFlags()[i]==false) {\r\n                            sawInner = true;\r\n                        }\r\n                    }\r\n                    if (!otherBranchContainOuter && ((LOJoin)predecessor).getInnerFlags()[mPushBeforeInput]==false) // all innerFlag is false, implies an outer join\r\n                    {\r\n                        mPushBeforeInput = -1;\r\n                        return false;\r\n                    }\r\n                    if (otherBranchContainOuter && sawInner) // If it is not a regular join and the path we push is on inner side\r\n                    {\r\n                        mPushBeforeInput = -1;\r\n                        return false;\r\n                    }\r\n                }\r\n                \r\n                mPushBefore = true;\r\n                return true;\r\n\r\n            } else if (predecessor instanceof LOForEach) {\r\n\r\n                LOForEach loForEach = (LOForEach) predecessor;\r\n                List<Boolean> mFlatten = loForEach.getFlatten();\r\n                boolean hasFlatten = false;\r\n                for (Boolean b : mFlatten) {\r\n                    if (b.equals(true)) {\r\n                        hasFlatten = true;\r\n                    }\r\n                }\r\n\r\n                // TODO\r\n                // A better check is to examine each column in the filter\'s\r\n                // required fields. If the column is the result of a flatten\r\n                // then\r\n                // return false else return true\r\n\r\n                // for now if the foreach has a flatten then return false\r\n                if (hasFlatten) {\r\n                    return false;\r\n                }\r\n\r\n                Pair<Boolean, Set<Integer>> mappingResult = isRequiredFieldMapped(requiredField, predecessor.getProjectionMap());\r\n                boolean mapped = mappingResult.first;\r\n                \r\n                // Check if it is a direct mapping, that is, project optionally followed by cast, so if project->project, it is not\r\n                // considered as a mapping\r\n                for (Pair<Integer, Integer> pair : requiredField.getFields())\r\n                {\r\n                    if (!isFieldSimple(loForEach.getForEachPlans().get(pair.second)))\r\n                    {\r\n                        mapped = false;\r\n                        break;\r\n                    }\r\n                }\r\n                \r\n                if (!mapped) {\r\n                    return false;\r\n                }\r\n            }\r\n\r\n            mSwap = true;\r\n            return true;\r\n        } catch (OptimizerException oe) {\r\n            throw oe;\r\n        } catch (Exception e) {\r\n            int errCode = 2149;\r\n            String msg = \"Internal error while trying to check if filters can be pushed up.\";\r\n            throw new OptimizerException(msg, errCode, PigException.BUG, e);\r\n        }\r\n    }','Public Method','pig','org.apache.pig.impl.logicalLayer.optimizer.PushUpFilter.check',2,8,0),(7,'C','mm','/*******************************************************************************\r\n* Copyright (c) 2000, 2003 IBM Corporation and others.\r\n* All rights reserved. This program and the accompanying materials \r\n* are made available under the terms of the Common Public License v1.0\r\n* which accompanies this distribution, and is available at\r\n* http://www.eclipse.org/legal/cpl-v10.html\r\n* \r\n* Contributors:\r\n*     IBM Corporation - initial API and implementation\r\n*******************************************************************************/\r\npackage org.eclipse.jdt.internal.core.search;\r\n\r\nimport java.util.HashSet;\r\nimport java.util.Iterator;\r\n\r\nimport org.eclipse.core.resources.IFile;\r\nimport org.eclipse.core.resources.IWorkspace;\r\nimport org.eclipse.core.runtime.IPath;\r\nimport org.eclipse.core.runtime.Path;\r\n\r\n/**\r\n* Collects the resource paths reported by a client to this search requestor.\r\n*/\r\npublic class PathCollector implements IIndexSearchRequestor {\r\n	\r\n	/* a set of resource paths */\r\n	public HashSet paths = new HashSet(5);\r\n	/**\r\n* @see IIndexSearchRequestor\r\n*/\r\n	public void acceptClassDeclaration(String resourcePath, char[] simpleTypeName, char[][] enclosingTypeNames, char[] packageName) {\r\n		this.paths.add( resourcePath);\r\n	}\r\n	/**\r\n* @see IIndexSearchRequestor\r\n*/\r\n	public void acceptConstructorDeclaration(String resourcePath, char[] typeName, int parameterCount) {\r\n		\r\n		this.paths.add(resourcePath);\r\n	}\r\n	/**\r\n* @see IIndexSearchRequestor\r\n*/\r\n	public void acceptConstructorReference(String resourcePath, char[] typeName, int parameterCount) {\r\n		\r\n		this.paths.add(resourcePath);\r\n	}\r\n	/**\r\n* @see IIndexSearchRequestor\r\n*/\r\n	public void acceptFieldDeclaration(String resourcePath, char[] fieldName) {\r\n		this.paths.add(resourcePath);\r\n	}\r\n	/**\r\n* @see IIndexSearchRequestor\r\n*/\r\n	public void acceptFieldReference(String resourcePath, char[] fieldName) {\r\n		\r\n		this.paths.add(resourcePath);\r\n	}\r\n	/**\r\n* @see IIndexSearchRequestor\r\n*/\r\n	public void acceptInterfaceDeclaration(String resourcePath, char[] simpleTypeName, char[][] enclosingTypeNames, char[] packageName) {\r\n		\r\n		this.paths.add(resourcePath);\r\n	}\r\n	/**\r\n* @see IIndexSearchRequestor\r\n*/\r\n	public void acceptMethodDeclaration(String resourcePath, char[] methodName, int parameterCount) {\r\n		\r\n		this.paths.add(resourcePath);\r\n	}\r\n	/**\r\n* @see IIndexSearchRequestor\r\n*/\r\n	public void acceptMethodReference(String resourcePath, char[] methodName, int parameterCount) {\r\n		\r\n		this.paths.add(resourcePath);\r\n	}\r\n	/**\r\n* @see IIndexSearchRequestor\r\n*/\r\n	public void acceptPackageReference(String resourcePath, char[] packageName) {\r\n		\r\n		this.paths.add(resourcePath);\r\n	}\r\n	/**\r\n* @see IIndexSearchRequestor\r\n*/\r\n	public void acceptSuperTypeReference(String resourcePath, char[] qualification, char[] typeName, char[] enclosingTypeName, char classOrInterface, char[] superQualification, char[] superTypeName, char superClassOrInterface, int modifiers) {\r\n		this.paths.add(resourcePath);\r\n	}\r\n	/**\r\n* @see IIndexSearchRequestor\r\n*/\r\n	public void acceptSuperTypeReference(String resourcePath, char[] qualification, char[] typeName, char classOrInterface, char[] superQualification, char[] superTypeName, char superClassOrInterface, int modifiers) {\r\n		this.paths.add(resourcePath);\r\n	}\r\n	/**\r\n* @see IIndexSearchRequestor\r\n*/\r\n	public void acceptTypeReference(String resourcePath, char[] typeName) {\r\n		this.paths.add(resourcePath);\r\n	}\r\n	/**\r\n* Returns the files that correspond to the paths that have been collected.\r\n*/\r\n	public IFile[] getFiles(IWorkspace workspace) {\r\n		IFile[] result = new IFile[this.paths.size()];\r\n		int i = 0;\r\n		for (Iterator iter = this.paths.iterator(); iter.hasNext();) {\r\n			String resourcePath = (String)iter.next();\r\n			IPath path = new Path(resourcePath);\r\n			result[i++] = workspace.getRoot().getFile(path);\r\n		}\r\n		return result;\r\n	}\r\n	/**\r\n* Returns the paths that have been collected.\r\n*/\r\n	public String[] getPaths() {\r\n		String[] result = new String[this.paths.size()];\r\n		int i = 0;\r\n		for (Iterator iter = this.paths.iterator(); iter.hasNext();) {\r\n			result[i++] = (String)iter.next();\r\n		}\r\n		return result;\r\n	}\r\n}','Public Class','eclipse.jdt.core','org.eclipse.jdt.internal.core.search.PathCollector',1,10,0),(8,'C','gc','/*******************************************************************************\r\n* Copyright (c) 2000, 2003 IBM Corporation and others.\r\n* All rights reserved. This program and the accompanying materials \r\n* are made available under the terms of the Common Public License v1.0\r\n* which accompanies this distribution, and is available at\r\n* http://www.eclipse.org/legal/cpl-v10.html\r\n* \r\n* Contributors:\r\n*     IBM Corporation - initial API and implementation\r\n*******************************************************************************/\r\npackage org.eclipse.jdt.internal.core.util;\r\n\r\nimport java.util.Iterator;\r\n\r\nimport org.eclipse.jdt.core.compiler.CharOperation;\r\nimport org.eclipse.jdt.core.compiler.IScanner;\r\nimport org.eclipse.jdt.core.compiler.ITerminalSymbols;\r\nimport org.eclipse.jdt.core.compiler.InvalidInputException;\r\nimport org.eclipse.jdt.internal.compiler.ast.StringLiteral;\r\nimport org.eclipse.jdt.internal.compiler.classfmt.ClassFileConstants;\r\nimport org.eclipse.jdt.internal.compiler.parser.NLSLine;\r\n\r\npublic class PublicScanner implements IScanner, ITerminalSymbols {\r\n\r\n	/* APIs ares\r\n	- getNextToken() which return the current type of the token\r\n	(this value is not memorized by the scanner)\r\n	- getCurrentTokenSource() which provides with the token \"REAL\" source\r\n	(aka all unicode have been transformed into a correct char)\r\n	- sourceStart gives the position into the stream\r\n	- currentPosition-1 gives the sourceEnd position into the stream \r\n	*/\r\n\r\n	// 1.4 feature \r\n	private boolean assertMode = false;\r\n	public boolean useAssertAsAnIndentifier = false;\r\n	//flag indicating if processed source contains occurrences of keyword assert \r\n	public boolean containsAssertKeyword = false; \r\n	\r\n	public boolean recordLineSeparator = false;\r\n	public char currentCharacter;\r\n	public int startPosition;\r\n	public int currentPosition;\r\n	public int initialPosition, eofPosition;\r\n	// after this position eof are generated instead of real token from the source\r\n\r\n	public boolean tokenizeComments = false;\r\n	public boolean tokenizeWhiteSpace = false;\r\n\r\n	//source should be viewed as a window (aka a part)\r\n	//of a entire very large stream\r\n	public char source[];\r\n\r\n	//unicode support\r\n	public char[] withoutUnicodeBuffer;\r\n	public int withoutUnicodePtr; //when == 0 ==> no unicode in the current token\r\n	public boolean unicodeAsBackSlash = false;\r\n\r\n	public boolean scanningFloatLiteral = false;\r\n\r\n	//support for /** comments\r\n	public int[] commentStops = new int[10];\r\n	public int[] commentStarts = new int[10];\r\n	public int commentPtr = -1; // no comment test with commentPtr value -1\r\n	\r\n	// task tag support\r\n	public char[][] foundTaskTags = null;\r\n	public char[][] foundTaskMessages;\r\n	public char[][] foundTaskPriorities = null;\r\n	public int[][] foundTaskPositions;\r\n	public int foundTaskCount = 0;\r\n	public char[][] taskTags = null;\r\n	public char[][] taskPriorities = null;\r\n	\r\n	//diet parsing support - jump over some method body when requested\r\n	public boolean diet = false;\r\n\r\n	//support for the  poor-line-debuggers ....\r\n	//remember the position of the cr/lf\r\n	public int[] lineEnds = new int[250];\r\n	public int linePtr = -1;\r\n	public boolean wasAcr = false;\r\n\r\n	public static final String END_OF_SOURCE = \"End_Of_Source\"; //$NON-NLS-1$\r\n\r\n	public static final String INVALID_HEXA = \"Invalid_Hexa_Literal\"; //$NON-NLS-1$\r\n	public static final String INVALID_OCTAL = \"Invalid_Octal_Literal\"; //$NON-NLS-1$\r\n	public static final String INVALID_CHARACTER_CONSTANT = \"Invalid_Character_Constant\";  //$NON-NLS-1$\r\n	public static final String INVALID_ESCAPE = \"Invalid_Escape\"; //$NON-NLS-1$\r\n	public static final String INVALID_INPUT = \"Invalid_Input\"; //$NON-NLS-1$\r\n	public static final String INVALID_UNICODE_ESCAPE = \"Invalid_Unicode_Escape\"; //$NON-NLS-1$\r\n	public static final String INVALID_FLOAT = \"Invalid_Float_Literal\"; //$NON-NLS-1$\r\n\r\n	public static final String NULL_SOURCE_STRING = \"Null_Source_String\"; //$NON-NLS-1$\r\n	public static final String UNTERMINATED_STRING = \"Unterminated_String\"; //$NON-NLS-1$\r\n	public static final String UNTERMINATED_COMMENT = \"Unterminated_Comment\"; //$NON-NLS-1$\r\n	public static final String INVALID_CHAR_IN_STRING = \"Invalid_Char_In_String\"; //$NON-NLS-1$\r\n\r\n	//----------------optimized identifier managment------------------\r\n	static final char[] charArray_a = new char[] {\'a\'}, \r\n	charArray_b = new char[] {\'b\'}, \r\n	charArray_c = new char[] {\'c\'}, \r\n	charArray_d = new char[] {\'d\'}, \r\n	charArray_e = new char[] {\'e\'}, \r\n	charArray_f = new char[] {\'f\'}, \r\n	charArray_g = new char[] {\'g\'}, \r\n	charArray_h = new char[] {\'h\'}, \r\n	charArray_i = new char[] {\'i\'}, \r\n	charArray_j = new char[] {\'j\'}, \r\n	charArray_k = new char[] {\'k\'}, \r\n	charArray_l = new char[] {\'l\'}, \r\n	charArray_m = new char[] {\'m\'}, \r\n	charArray_n = new char[] {\'n\'}, \r\n	charArray_o = new char[] {\'o\'}, \r\n	charArray_p = new char[] {\'p\'}, \r\n	charArray_q = new char[] {\'q\'}, \r\n	charArray_r = new char[] {\'r\'}, \r\n	charArray_s = new char[] {\'s\'}, \r\n	charArray_t = new char[] {\'t\'}, \r\n	charArray_u = new char[] {\'u\'}, \r\n	charArray_v = new char[] {\'v\'}, \r\n	charArray_w = new char[] {\'w\'}, \r\n	charArray_x = new char[] {\'x\'}, \r\n	charArray_y = new char[] {\'y\'}, \r\n	charArray_z = new char[] {\'z\'}; \r\n\r\n	static final char[] initCharArray = \r\n	new char[] {\'\\u0000\', \'\\u0000\', \'\\u0000\', \'\\u0000\', \'\\u0000\', \'\\u0000\'}; \r\n	static final int TableSize = 30, InternalTableSize = 6; //30*6 = 180 entries\r\n	public static final int OptimizedLength = 6;\r\n	public /*static*/ final char[][][][] charArray_length = \r\n	new char[OptimizedLength][TableSize][InternalTableSize][]; \r\n	// support for detecting non-externalized string literals\r\n	int currentLineNr= -1;\r\n	int previousLineNr= -1;\r\n	NLSLine currentLine= null;\r\n	public static final String TAG_PREFIX= \"//$NON-NLS-\"; //$NON-NLS-1$\r\n	public static final int TAG_PREFIX_LENGTH= TAG_PREFIX.length();\r\n	public static final String TAG_POSTFIX= \"$\"; //$NON-NLS-1$\r\n	public static final int TAG_POSTFIX_LENGTH= TAG_POSTFIX.length();\r\n	public StringLiteral[] nonNLSStrings = null;\r\n	public boolean checkNonExternalizedStringLiterals = false;\r\n	public boolean wasNonExternalizedStringLiteral = false;\r\n	\r\n	/*static*/ {\r\n		for (int i = 0; i < 6; i++) {\r\n			for (int j = 0; j < TableSize; j++) {\r\n				for (int k = 0; k < InternalTableSize; k++) {\r\n					charArray_length[i][j][k] = initCharArray;\r\n				}\r\n			}\r\n		}\r\n	}\r\n	static int newEntry2 = 0, \r\n	newEntry3 = 0, \r\n	newEntry4 = 0, \r\n	newEntry5 = 0, \r\n	newEntry6 = 0;\r\n\r\n	public static final int RoundBracket = 0;\r\n	public static final int SquareBracket = 1;\r\n	public static final int CurlyBracket = 2;	\r\n	public static final int BracketKinds = 3;\r\n\r\n	public PublicScanner() {\r\n		this(false /*comment*/, false /*whitespace*/, false /*nls*/, ClassFileConstants.JDK1_3 /*sourceLevel*/, null/*taskTag*/, null/*taskPriorities*/);\r\n	}\r\n\r\n	public PublicScanner(\r\n	boolean tokenizeComments, \r\n	boolean tokenizeWhiteSpace, \r\n	boolean checkNonExternalizedStringLiterals, \r\n	long sourceLevel,\r\n	char[][] taskTags,\r\n	char[][] taskPriorities) {\r\n\r\n		this.eofPosition = Integer.MAX_VALUE;\r\n		this.tokenizeComments = tokenizeComments;\r\n		this.tokenizeWhiteSpace = tokenizeWhiteSpace;\r\n		this.checkNonExternalizedStringLiterals = checkNonExternalizedStringLiterals;\r\n		this.assertMode = sourceLevel >= ClassFileConstants.JDK1_4;\r\n		this.taskTags = taskTags;\r\n		this.taskPriorities = taskPriorities;\r\n	}\r\n\r\n	public  final boolean atEnd() {\r\n		// This code is not relevant if source is \r\n		// Only a part of the real stream input\r\n\r\n		return source.length == currentPosition;\r\n	}\r\n\r\n	private void checkNonExternalizedString()  throws InvalidInputException {\r\n		if (currentLine == null) \r\n		return;\r\n		parseTags(currentLine);\r\n	}\r\n\r\n	// chech presence of task: tags\r\n	public void checkTaskTag(int commentStart, int commentEnd) {\r\n		char[] src = this.source;\r\n		\r\n		// only look for newer task: tags\r\n		if (this.foundTaskCount > 0\r\n				&& this.foundTaskPositions[this.foundTaskCount - 1][0] >= commentStart) {\r\n			return;\r\n		}\r\n		int foundTaskIndex = this.foundTaskCount;\r\n		char previous = \'/\';\r\n		nextChar : for (\r\n		int i = commentStart + 1; i < commentEnd && i < this.eofPosition; i++) {\r\n			char[] tag = null;\r\n			char[] priority = null;\r\n			// check for tag occurrence\r\n			nextTag : for (int itag = 0; itag < this.taskTags.length; itag++) {\r\n				tag = this.taskTags[itag];\r\n				int tagLength = tag.length;\r\n				if (tagLength == 0) continue nextTag;\r\n\r\n				// ensure tag is not leaded with letter if tag starts with a letter\r\n				if (Character.isLetterOrDigit(tag[0])) {\r\n					if (Character.isLetterOrDigit(previous)) {\r\n						continue nextTag;\r\n					}\r\n				}\r\n\r\n				for (int t = 0; t < tagLength; t++) {\r\n					if (src[i + t] != tag[t])\r\n					continue nextTag;\r\n				}\r\n				// ensure tag is not followed with letter if tag finishes with a letter\r\n				if (i+tagLength < commentEnd && Character.isLetterOrDigit(src[i+tagLength-1])) {\r\n					if (Character.isLetterOrDigit(src[i + tagLength]))\r\n					continue nextTag;\r\n				}\r\n				if (this.foundTaskTags == null) {\r\n					this.foundTaskTags = new char[5][];\r\n					this.foundTaskMessages = new char[5][];\r\n					this.foundTaskPriorities = new char[5][];\r\n					this.foundTaskPositions = new int[5][];\r\n				} else if (this.foundTaskCount == this.foundTaskTags.length) {\r\n					System.arraycopy(this.foundTaskTags, 0, this.foundTaskTags = new char[this.foundTaskCount * 2][], 0, this.foundTaskCount);\r\n					System.arraycopy(this.foundTaskMessages, 0, this.foundTaskMessages = new char[this.foundTaskCount * 2][], 0, this.foundTaskCount);\r\n					System.arraycopy(this.foundTaskPriorities, 0, this.foundTaskPriorities = new char[this.foundTaskCount * 2][], 0, this.foundTaskCount);\r\n					System.arraycopy(this.foundTaskPositions, 0, this.foundTaskPositions = new int[this.foundTaskCount * 2][], 0, this.foundTaskCount);\r\n				}\r\n				\r\n				priority = this.taskPriorities != null && itag < this.taskPriorities.length\r\n				? this.taskPriorities[itag]\r\n				: null;\r\n				\r\n				this.foundTaskTags[this.foundTaskCount] = tag;\r\n				this.foundTaskPriorities[this.foundTaskCount] = priority;\r\n				this.foundTaskPositions[this.foundTaskCount] = new int[] { i, i + tagLength - 1 };\r\n				this.foundTaskMessages[this.foundTaskCount] = CharOperation.NO_CHAR;\r\n				this.foundTaskCount++;\r\n				i += tagLength - 1; // will be incremented when looping\r\n				break nextTag;\r\n			}\r\n			previous = src[i];\r\n		}\r\n		for (int i = foundTaskIndex; i < this.foundTaskCount; i++) {\r\n			// retrieve message start and end positions\r\n			int msgStart = this.foundTaskPositions[i][0] + this.foundTaskTags[i].length;\r\n			int max_value = i + 1 < this.foundTaskCount\r\n			? this.foundTaskPositions[i + 1][0] - 1\r\n			: commentEnd - 1;\r\n			// at most beginning of next task\r\n			if (max_value < msgStart) {\r\n				max_value = msgStart; // would only occur if tag is before EOF.\r\n			}\r\n			int end = -1;\r\n			char c;\r\n			for (int j = msgStart; j < max_value; j++) {\r\n				if ((c = src[j]) == \'\\n\' || c == \'\\r\') {\r\n					end = j - 1;\r\n					break;\r\n				}\r\n			}\r\n			if (end == -1) {\r\n				for (int j = max_value; j > msgStart; j--) {\r\n					if ((c = src[j]) == \'*\') {\r\n						end = j - 1;\r\n						break;\r\n					}\r\n				}\r\n				if (end == -1)\r\n				end = max_value;\r\n			}\r\n			if (msgStart == end)\r\n			continue; // empty\r\n			// trim the message\r\n			while (CharOperation.isWhitespace(src[end]) && msgStart <= end)\r\n			end--;\r\n			while (CharOperation.isWhitespace(src[msgStart]) && msgStart <= end)\r\n			msgStart++;\r\n			// update the end position of the task\r\n			this.foundTaskPositions[i][1] = end;\r\n			// get the message source\r\n			final int messageLength = end - msgStart + 1;\r\n			char[] message = new char[messageLength];\r\n			System.arraycopy(src, msgStart, message, 0, messageLength);\r\n			this.foundTaskMessages[i] = message;\r\n		}\r\n	}\r\n	public char[] getCurrentIdentifierSource() {\r\n		//return the token REAL source (aka unicodes are precomputed)\r\n\r\n		char[] result;\r\n		if (withoutUnicodePtr != 0)\r\n		//0 is used as a fast test flag so the real first char is in position 1\r\n		System.arraycopy(\r\n		withoutUnicodeBuffer, \r\n		1, \r\n		result = new char[withoutUnicodePtr], \r\n		0, \r\n		withoutUnicodePtr); \r\n		else {\r\n			int length = currentPosition - startPosition;\r\n			switch (length) { // see OptimizedLength\r\n			case 1 :\r\n				return optimizedCurrentTokenSource1();\r\n			case 2 :\r\n				return optimizedCurrentTokenSource2();\r\n			case 3 :\r\n				return optimizedCurrentTokenSource3();\r\n			case 4 :\r\n				return optimizedCurrentTokenSource4();\r\n			case 5 :\r\n				return optimizedCurrentTokenSource5();\r\n			case 6 :\r\n				return optimizedCurrentTokenSource6();\r\n			}\r\n			//no optimization\r\n			System.arraycopy(source, startPosition, result = new char[length], 0, length);\r\n		}\r\n		return result;\r\n	}\r\n	public int getCurrentTokenEndPosition(){\r\n		return this.currentPosition - 1;\r\n	}\r\n	public final char[] getCurrentTokenSource() {\r\n		// Return the token REAL source (aka unicodes are precomputed)\r\n\r\n		char[] result;\r\n		if (withoutUnicodePtr != 0)\r\n		// 0 is used as a fast test flag so the real first char is in position 1\r\n		System.arraycopy(\r\n		withoutUnicodeBuffer, \r\n		1, \r\n		result = new char[withoutUnicodePtr], \r\n		0, \r\n		withoutUnicodePtr); \r\n		else {\r\n			int length;\r\n			System.arraycopy(\r\n			source, \r\n			startPosition, \r\n			result = new char[length = currentPosition - startPosition], \r\n			0, \r\n			length); \r\n		}\r\n		return result;\r\n	}\r\n	public final char[] getCurrentTokenSourceString() {\r\n		//return the token REAL source (aka unicodes are precomputed).\r\n		//REMOVE the two \" that are at the beginning and the end.\r\n\r\n		char[] result;\r\n		if (withoutUnicodePtr != 0)\r\n		//0 is used as a fast test flag so the real first char is in position 1\r\n		System.arraycopy(withoutUnicodeBuffer, 2,\r\n		//2 is 1 (real start) + 1 (to jump over the \")\r\n		result = new char[withoutUnicodePtr - 2], 0, withoutUnicodePtr - 2);\r\n		else {\r\n			int length;\r\n			System.arraycopy(\r\n			source, \r\n			startPosition + 1, \r\n			result = new char[length = currentPosition - startPosition - 2], \r\n			0, \r\n			length); \r\n		}\r\n		return result;\r\n	}\r\n\r\n	public final char[] getRawTokenSource() {\r\n		int length = this.currentPosition - this.startPosition;\r\n		char[] tokenSource = new char[length];\r\n		System.arraycopy(source, this.startPosition, tokenSource, 0, length);\r\n		return tokenSource;	\r\n	}\r\n	\r\n	public int getCurrentTokenStartPosition(){\r\n		return this.startPosition;\r\n	}\r\n	/*\r\n* Search the source position corresponding to the end of a given line number\r\n*\r\n* Line numbers are 1-based, and relative to the scanner initialPosition. \r\n* Character positions are 0-based.\r\n*\r\n* In case the given line number is inconsistent, answers -1.\r\n*/\r\n	public final int getLineEnd(int lineNumber) {\r\n\r\n		if (lineEnds == null) return -1;\r\n		if (lineNumber >= lineEnds.length) return -1;\r\n		if (lineNumber <= 0) return -1;\r\n		\r\n		if (lineNumber == lineEnds.length - 1) return eofPosition;\r\n		return lineEnds[lineNumber-1]; // next line start one character behind the lineEnd of the previous line\r\n	}\r\n\r\n	public final int[] getLineEnds() {\r\n		//return a bounded copy of this.lineEnds \r\n\r\n		int[] copy;\r\n		System.arraycopy(lineEnds, 0, copy = new int[linePtr + 1], 0, linePtr + 1);\r\n		return copy;\r\n	}\r\n\r\n	/**\r\n* Search the source position corresponding to the beginning of a given line number\r\n*\r\n* Line numbers are 1-based, and relative to the scanner initialPosition. \r\n* Character positions are 0-based.\r\n*\r\n* e.g.	getLineStart(1) --> 0	indicates that the first line starts at character 0.\r\n*\r\n* In case the given line number is inconsistent, answers -1.\r\n*/\r\n	public final int getLineStart(int lineNumber) {\r\n\r\n		if (lineEnds == null) return -1;\r\n		if (lineNumber >= lineEnds.length) return -1;\r\n		if (lineNumber <= 0) return -1;\r\n		\r\n		if (lineNumber == 1) return initialPosition;\r\n		return lineEnds[lineNumber-2]+1; // next line start one character behind the lineEnd of the previous line\r\n	}\r\n	public final boolean getNextChar(char testedChar) {\r\n		//BOOLEAN\r\n		//handle the case of unicode.\r\n		//when a unicode appears then we must use a buffer that holds char internal values\r\n		//At the end of this method currentCharacter holds the new visited char\r\n		//and currentPosition points right next after it\r\n		//Both previous lines are true if the currentCharacter is == to the testedChar\r\n		//On false, no side effect has occured.\r\n\r\n		//ALL getNextChar.... ARE OPTIMIZED COPIES \r\n\r\n		int temp = currentPosition;\r\n		try {\r\n			if (((currentCharacter = source[currentPosition++]) == \'\\\\\')\r\n					&& (source[currentPosition] == \'u\')) {\r\n				//-------------unicode traitement ------------\r\n				int c1, c2, c3, c4;\r\n				int unicodeSize = 6;\r\n				currentPosition++;\r\n				while (source[currentPosition] == \'u\') {\r\n					currentPosition++;\r\n					unicodeSize++;\r\n				}\r\n\r\n				if (((c1 = Character.getNumericValue(source[currentPosition++])) > 15\r\n							|| c1 < 0)\r\n						|| ((c2 = Character.getNumericValue(source[currentPosition++])) > 15 || c2 < 0)\r\n						|| ((c3 = Character.getNumericValue(source[currentPosition++])) > 15 || c3 < 0)\r\n						|| ((c4 = Character.getNumericValue(source[currentPosition++])) > 15 || c4 < 0)) {\r\n					currentPosition = temp;\r\n					return false;\r\n				}\r\n\r\n				currentCharacter = (char) (((c1 * 16 + c2) * 16 + c3) * 16 + c4);\r\n				if (currentCharacter != testedChar) {\r\n					currentPosition = temp;\r\n					return false;\r\n				}\r\n				unicodeAsBackSlash = currentCharacter == \'\\\\\';\r\n\r\n				//need the unicode buffer\r\n				if (withoutUnicodePtr == 0) {\r\n					//buffer all the entries that have been left aside....\r\n					withoutUnicodePtr = currentPosition - unicodeSize - startPosition;\r\n					System.arraycopy(\r\n					source, \r\n					startPosition, \r\n					withoutUnicodeBuffer, \r\n					1, \r\n					withoutUnicodePtr); \r\n				}\r\n				//fill the buffer with the char\r\n				withoutUnicodeBuffer[++withoutUnicodePtr] = currentCharacter;\r\n				return true;\r\n\r\n			} //-------------end unicode traitement--------------\r\n			else {\r\n				if (currentCharacter != testedChar) {\r\n					currentPosition = temp;\r\n					return false;\r\n				}\r\n				unicodeAsBackSlash = false;\r\n				if (withoutUnicodePtr != 0)\r\n				withoutUnicodeBuffer[++withoutUnicodePtr] = currentCharacter;\r\n				return true;\r\n			}\r\n		} catch (IndexOutOfBoundsException e) {\r\n			unicodeAsBackSlash = false;\r\n			currentPosition = temp;\r\n			return false;\r\n		}\r\n	}\r\n	public final int getNextChar(char testedChar1, char testedChar2) {\r\n		//INT 0 : testChar1 \\\\\\\\///\\\\\\\\ 1 : testedChar2 \\\\\\\\///\\\\\\\\ -1 : others\r\n		//test can be done with (x==0) for the first and (x>0) for the second\r\n		//handle the case of unicode.\r\n		//when a unicode appears then we must use a buffer that holds char internal values\r\n		//At the end of this method currentCharacter holds the new visited char\r\n		//and currentPosition points right next after it\r\n		//Both previous lines are true if the currentCharacter is == to the testedChar1/2\r\n		//On false, no side effect has occured.\r\n\r\n		//ALL getNextChar.... ARE OPTIMIZED COPIES \r\n\r\n		int temp = currentPosition;\r\n		try {\r\n			int result;\r\n			if (((currentCharacter = source[currentPosition++]) == \'\\\\\')\r\n					&& (source[currentPosition] == \'u\')) {\r\n				//-------------unicode traitement ------------\r\n				int c1, c2, c3, c4;\r\n				int unicodeSize = 6;\r\n				currentPosition++;\r\n				while (source[currentPosition] == \'u\') {\r\n					currentPosition++;\r\n					unicodeSize++;\r\n				}\r\n\r\n				if (((c1 = Character.getNumericValue(source[currentPosition++])) > 15\r\n							|| c1 < 0)\r\n						|| ((c2 = Character.getNumericValue(source[currentPosition++])) > 15 || c2 < 0)\r\n						|| ((c3 = Character.getNumericValue(source[currentPosition++])) > 15 || c3 < 0)\r\n						|| ((c4 = Character.getNumericValue(source[currentPosition++])) > 15 || c4 < 0)) {\r\n					currentPosition = temp;\r\n					return 2;\r\n				}\r\n\r\n				currentCharacter = (char) (((c1 * 16 + c2) * 16 + c3) * 16 + c4);\r\n				if (currentCharacter == testedChar1)\r\n				result = 0;\r\n				else\r\n				if (currentCharacter == testedChar2)\r\n				result = 1;\r\n				else {\r\n					currentPosition = temp;\r\n					return -1;\r\n				}\r\n\r\n				//need the unicode buffer\r\n				if (withoutUnicodePtr == 0) {\r\n					//buffer all the entries that have been left aside....\r\n					withoutUnicodePtr = currentPosition - unicodeSize - startPosition;\r\n					System.arraycopy(\r\n					source, \r\n					startPosition, \r\n					withoutUnicodeBuffer, \r\n					1, \r\n					withoutUnicodePtr); \r\n				}\r\n				//fill the buffer with the char\r\n				withoutUnicodeBuffer[++withoutUnicodePtr] = currentCharacter;\r\n				return result;\r\n			} //-------------end unicode traitement--------------\r\n			else {\r\n				if (currentCharacter == testedChar1)\r\n				result = 0;\r\n				else\r\n				if (currentCharacter == testedChar2)\r\n				result = 1;\r\n				else {\r\n					currentPosition = temp;\r\n					return -1;\r\n				}\r\n\r\n				if (withoutUnicodePtr != 0)\r\n				withoutUnicodeBuffer[++withoutUnicodePtr] = currentCharacter;\r\n				return result;\r\n			}\r\n		} catch (IndexOutOfBoundsException e) {\r\n			currentPosition = temp;\r\n			return -1;\r\n		}\r\n	}\r\n	public final boolean getNextCharAsDigit() {\r\n		//BOOLEAN\r\n		//handle the case of unicode.\r\n		//when a unicode appears then we must use a buffer that holds char internal values\r\n		//At the end of this method currentCharacter holds the new visited char\r\n		//and currentPosition points right next after it\r\n		//Both previous lines are true if the currentCharacter is a digit\r\n		//On false, no side effect has occured.\r\n\r\n		//ALL getNextChar.... ARE OPTIMIZED COPIES \r\n\r\n		int temp = currentPosition;\r\n		try {\r\n			if (((currentCharacter = source[currentPosition++]) == \'\\\\\')\r\n					&& (source[currentPosition] == \'u\')) {\r\n				//-------------unicode traitement ------------\r\n				int c1, c2, c3, c4;\r\n				int unicodeSize = 6;\r\n				currentPosition++;\r\n				while (source[currentPosition] == \'u\') {\r\n					currentPosition++;\r\n					unicodeSize++;\r\n				}\r\n\r\n				if (((c1 = Character.getNumericValue(source[currentPosition++])) > 15\r\n							|| c1 < 0)\r\n						|| ((c2 = Character.getNumericValue(source[currentPosition++])) > 15 || c2 < 0)\r\n						|| ((c3 = Character.getNumericValue(source[currentPosition++])) > 15 || c3 < 0)\r\n						|| ((c4 = Character.getNumericValue(source[currentPosition++])) > 15 || c4 < 0)) {\r\n					currentPosition = temp;\r\n					return false;\r\n				}\r\n\r\n				currentCharacter = (char) (((c1 * 16 + c2) * 16 + c3) * 16 + c4);\r\n				if (!Character.isDigit(currentCharacter)) {\r\n					currentPosition = temp;\r\n					return false;\r\n				}\r\n\r\n				//need the unicode buffer\r\n				if (withoutUnicodePtr == 0) {\r\n					//buffer all the entries that have been left aside....\r\n					withoutUnicodePtr = currentPosition - unicodeSize - startPosition;\r\n					System.arraycopy(\r\n					source, \r\n					startPosition, \r\n					withoutUnicodeBuffer, \r\n					1, \r\n					withoutUnicodePtr); \r\n				}\r\n				//fill the buffer with the char\r\n				withoutUnicodeBuffer[++withoutUnicodePtr] = currentCharacter;\r\n				return true;\r\n			} //-------------end unicode traitement--------------\r\n			else {\r\n				if (!Character.isDigit(currentCharacter)) {\r\n					currentPosition = temp;\r\n					return false;\r\n				}\r\n				if (withoutUnicodePtr != 0)\r\n				withoutUnicodeBuffer[++withoutUnicodePtr] = currentCharacter;\r\n				return true;\r\n			}\r\n		} catch (IndexOutOfBoundsException e) {\r\n			currentPosition = temp;\r\n			return false;\r\n		}\r\n	}\r\n	public final boolean getNextCharAsDigit(int radix) {\r\n		//BOOLEAN\r\n		//handle the case of unicode.\r\n		//when a unicode appears then we must use a buffer that holds char internal values\r\n		//At the end of this method currentCharacter holds the new visited char\r\n		//and currentPosition points right next after it\r\n		//Both previous lines are true if the currentCharacter is a digit base on radix\r\n		//On false, no side effect has occured.\r\n\r\n		//ALL getNextChar.... ARE OPTIMIZED COPIES \r\n\r\n		int temp = currentPosition;\r\n		try {\r\n			if (((currentCharacter = source[currentPosition++]) == \'\\\\\')\r\n					&& (source[currentPosition] == \'u\')) {\r\n				//-------------unicode traitement ------------\r\n				int c1, c2, c3, c4;\r\n				int unicodeSize = 6;\r\n				currentPosition++;\r\n				while (source[currentPosition] == \'u\') {\r\n					currentPosition++;\r\n					unicodeSize++;\r\n				}\r\n\r\n				if (((c1 = Character.getNumericValue(source[currentPosition++])) > 15\r\n							|| c1 < 0)\r\n						|| ((c2 = Character.getNumericValue(source[currentPosition++])) > 15 || c2 < 0)\r\n						|| ((c3 = Character.getNumericValue(source[currentPosition++])) > 15 || c3 < 0)\r\n						|| ((c4 = Character.getNumericValue(source[currentPosition++])) > 15 || c4 < 0)) {\r\n					currentPosition = temp;\r\n					return false;\r\n				}\r\n\r\n				currentCharacter = (char) (((c1 * 16 + c2) * 16 + c3) * 16 + c4);\r\n				if (Character.digit(currentCharacter, radix) == -1) {\r\n					currentPosition = temp;\r\n					return false;\r\n				}\r\n\r\n				//need the unicode buffer\r\n				if (withoutUnicodePtr == 0) {\r\n					//buffer all the entries that have been left aside....\r\n					withoutUnicodePtr = currentPosition - unicodeSize - startPosition;\r\n					System.arraycopy(\r\n					source, \r\n					startPosition, \r\n					withoutUnicodeBuffer, \r\n					1, \r\n					withoutUnicodePtr); \r\n				}\r\n				//fill the buffer with the char\r\n				withoutUnicodeBuffer[++withoutUnicodePtr] = currentCharacter;\r\n				return true;\r\n			} //-------------end unicode traitement--------------\r\n			else {\r\n				if (Character.digit(currentCharacter, radix) == -1) {\r\n					currentPosition = temp;\r\n					return false;\r\n				}\r\n				if (withoutUnicodePtr != 0)\r\n				withoutUnicodeBuffer[++withoutUnicodePtr] = currentCharacter;\r\n				return true;\r\n			}\r\n		} catch (IndexOutOfBoundsException e) {\r\n			currentPosition = temp;\r\n			return false;\r\n		}\r\n	}\r\n	public boolean getNextCharAsJavaIdentifierPart() {\r\n		//BOOLEAN\r\n		//handle the case of unicode.\r\n		//when a unicode appears then we must use a buffer that holds char internal values\r\n		//At the end of this method currentCharacter holds the new visited char\r\n		//and currentPosition points right next after it\r\n		//Both previous lines are true if the currentCharacter is a JavaIdentifierPart\r\n		//On false, no side effect has occured.\r\n\r\n		//ALL getNextChar.... ARE OPTIMIZED COPIES \r\n\r\n		int temp = currentPosition;\r\n		try {\r\n			if (((currentCharacter = source[currentPosition++]) == \'\\\\\')\r\n					&& (source[currentPosition] == \'u\')) {\r\n				//-------------unicode traitement ------------\r\n				int c1, c2, c3, c4;\r\n				int unicodeSize = 6;\r\n				currentPosition++;\r\n				while (source[currentPosition] == \'u\') {\r\n					currentPosition++;\r\n					unicodeSize++;\r\n				}\r\n\r\n				if (((c1 = Character.getNumericValue(source[currentPosition++])) > 15\r\n							|| c1 < 0)\r\n						|| ((c2 = Character.getNumericValue(source[currentPosition++])) > 15 || c2 < 0)\r\n						|| ((c3 = Character.getNumericValue(source[currentPosition++])) > 15 || c3 < 0)\r\n						|| ((c4 = Character.getNumericValue(source[currentPosition++])) > 15 || c4 < 0)) {\r\n					currentPosition = temp;\r\n					return false;\r\n				}\r\n\r\n				currentCharacter = (char) (((c1 * 16 + c2) * 16 + c3) * 16 + c4);\r\n				if (!Character.isJavaIdentifierPart(currentCharacter)) {\r\n					currentPosition = temp;\r\n					return false;\r\n				}\r\n\r\n				//need the unicode buffer\r\n				if (withoutUnicodePtr == 0) {\r\n					//buffer all the entries that have been left aside....\r\n					withoutUnicodePtr = currentPosition - unicodeSize - startPosition;\r\n					System.arraycopy(\r\n					source, \r\n					startPosition, \r\n					withoutUnicodeBuffer, \r\n					1, \r\n					withoutUnicodePtr); \r\n				}\r\n				//fill the buffer with the char\r\n				withoutUnicodeBuffer[++withoutUnicodePtr] = currentCharacter;\r\n				return true;\r\n			} //-------------end unicode traitement--------------\r\n			else {\r\n				if (!Character.isJavaIdentifierPart(currentCharacter)) {\r\n					currentPosition = temp;\r\n					return false;\r\n				}\r\n\r\n				if (withoutUnicodePtr != 0)\r\n				withoutUnicodeBuffer[++withoutUnicodePtr] = currentCharacter;\r\n				return true;\r\n			}\r\n		} catch (IndexOutOfBoundsException e) {\r\n			currentPosition = temp;\r\n			return false;\r\n		}\r\n	}\r\n	public int getNextToken() throws InvalidInputException {\r\n\r\n		this.wasAcr = false;\r\n		if (diet) {\r\n			jumpOverMethodBody();\r\n			diet = false;\r\n			return currentPosition > source.length ? TokenNameEOF : TokenNameRBRACE;\r\n		}\r\n		int whiteStart = 0;\r\n		try {\r\n			while (true) { //loop for jumping over comments\r\n				withoutUnicodePtr = 0;\r\n				//start with a new token (even comment written with unicode )\r\n\r\n				// ---------Consume white space and handles startPosition---------\r\n				whiteStart = currentPosition;\r\n				boolean isWhiteSpace, hasWhiteSpaces = false;\r\n				int offset = 0;\r\n				do {\r\n					startPosition = currentPosition;\r\n					boolean checkIfUnicode = false;\r\n					try {\r\n						checkIfUnicode = ((currentCharacter = source[currentPosition++]) == \'\\\\\')\r\n						&& (source[currentPosition] == \'u\');\r\n					} catch(IndexOutOfBoundsException e) {\r\n						if (tokenizeWhiteSpace && (whiteStart != currentPosition - 1)) {\r\n							// reposition scanner in case we are interested by spaces as tokens\r\n							currentPosition--;\r\n							startPosition = whiteStart;\r\n							return TokenNameWHITESPACE;\r\n						}\r\n						if (currentPosition > eofPosition)\r\n						return TokenNameEOF;\r\n					}\r\n					if (checkIfUnicode) {\r\n						isWhiteSpace = jumpOverUnicodeWhiteSpace();\r\n						offset = 6;\r\n					} else {\r\n						offset = 1;\r\n						if ((currentCharacter == \'\\r\') || (currentCharacter == \'\\n\')) {\r\n							checkNonExternalizedString();\r\n							if (recordLineSeparator) {\r\n								pushLineSeparator();\r\n							} else {\r\n								currentLine = null;\r\n							}\r\n						}\r\n						isWhiteSpace = \r\n						(currentCharacter == \' \') || CharOperation.isWhitespace(currentCharacter); \r\n					}\r\n					if (isWhiteSpace) {\r\n						hasWhiteSpaces = true;\r\n					}\r\n				} while (isWhiteSpace);\r\n				if (tokenizeWhiteSpace && hasWhiteSpaces) {\r\n					// reposition scanner in case we are interested by spaces as tokens\r\n					currentPosition-=offset;\r\n					startPosition = whiteStart;\r\n					return TokenNameWHITESPACE;\r\n				}\r\n				//little trick to get out in the middle of a source compuation\r\n				if (currentPosition > eofPosition)\r\n				return TokenNameEOF;\r\n\r\n				// ---------Identify the next token-------------\r\n\r\n				switch (currentCharacter) {\r\n				case \'(\' :\r\n					return TokenNameLPAREN;\r\n				case \')\' :\r\n					return TokenNameRPAREN;\r\n				case \'{\' :\r\n					return TokenNameLBRACE;\r\n				case \'}\' :\r\n					return TokenNameRBRACE;\r\n				case \'[\' :\r\n					return TokenNameLBRACKET;\r\n				case \']\' :\r\n					return TokenNameRBRACKET;\r\n				case \';\' :\r\n					return TokenNameSEMICOLON;\r\n				case \',\' :\r\n					return TokenNameCOMMA;\r\n				case \'.\' :\r\n					if (getNextCharAsDigit())\r\n					return scanNumber(true);\r\n					return TokenNameDOT;\r\n				case \'+\' :\r\n					{\r\n						int test;\r\n						if ((test = getNextChar(\'+\', \'=\')) == 0)\r\n						return TokenNamePLUS_PLUS;\r\n						if (test > 0)\r\n						return TokenNamePLUS_EQUAL;\r\n						return TokenNamePLUS;\r\n					}\r\n				case \'-\' :\r\n					{\r\n						int test;\r\n						if ((test = getNextChar(\'-\', \'=\')) == 0)\r\n						return TokenNameMINUS_MINUS;\r\n						if (test > 0)\r\n						return TokenNameMINUS_EQUAL;\r\n						return TokenNameMINUS;\r\n					}\r\n				case \'~\' :\r\n					return TokenNameTWIDDLE;\r\n				case \'!\' :\r\n					if (getNextChar(\'=\'))\r\n					return TokenNameNOT_EQUAL;\r\n					return TokenNameNOT;\r\n				case \'*\' :\r\n					if (getNextChar(\'=\'))\r\n					return TokenNameMULTIPLY_EQUAL;\r\n					return TokenNameMULTIPLY;\r\n				case \'%\' :\r\n					if (getNextChar(\'=\'))\r\n					return TokenNameREMAINDER_EQUAL;\r\n					return TokenNameREMAINDER;\r\n				case \'<\' :\r\n					{\r\n						int test;\r\n						if ((test = getNextChar(\'=\', \'<\')) == 0)\r\n						return TokenNameLESS_EQUAL;\r\n						if (test > 0) {\r\n							if (getNextChar(\'=\'))\r\n							return TokenNameLEFT_SHIFT_EQUAL;\r\n							return TokenNameLEFT_SHIFT;\r\n						}\r\n						return TokenNameLESS;\r\n					}\r\n				case \'>\' :\r\n					{\r\n						int test;\r\n						if ((test = getNextChar(\'=\', \'>\')) == 0)\r\n						return TokenNameGREATER_EQUAL;\r\n						if (test > 0) {\r\n							if ((test = getNextChar(\'=\', \'>\')) == 0)\r\n							return TokenNameRIGHT_SHIFT_EQUAL;\r\n							if (test > 0) {\r\n								if (getNextChar(\'=\'))\r\n								return TokenNameUNSIGNED_RIGHT_SHIFT_EQUAL;\r\n								return TokenNameUNSIGNED_RIGHT_SHIFT;\r\n							}\r\n							return TokenNameRIGHT_SHIFT;\r\n						}\r\n						return TokenNameGREATER;\r\n					}\r\n				case \'=\' :\r\n					if (getNextChar(\'=\'))\r\n					return TokenNameEQUAL_EQUAL;\r\n					return TokenNameEQUAL;\r\n				case \'&\' :\r\n					{\r\n						int test;\r\n						if ((test = getNextChar(\'&\', \'=\')) == 0)\r\n						return TokenNameAND_AND;\r\n						if (test > 0)\r\n						return TokenNameAND_EQUAL;\r\n						return TokenNameAND;\r\n					}\r\n				case \'|\' :\r\n					{\r\n						int test;\r\n						if ((test = getNextChar(\'|\', \'=\')) == 0)\r\n						return TokenNameOR_OR;\r\n						if (test > 0)\r\n						return TokenNameOR_EQUAL;\r\n						return TokenNameOR;\r\n					}\r\n				case \'^\' :\r\n					if (getNextChar(\'=\'))\r\n					return TokenNameXOR_EQUAL;\r\n					return TokenNameXOR;\r\n				case \'?\' :\r\n					return TokenNameQUESTION;\r\n				case \':\' :\r\n					return TokenNameCOLON;\r\n				case \'\\\'\' :\r\n					{\r\n						int test;\r\n						if ((test = getNextChar(\'\\n\', \'\\r\')) == 0) {\r\n							throw new InvalidInputException(INVALID_CHARACTER_CONSTANT);\r\n						}\r\n						if (test > 0) {\r\n							// relocate if finding another quote fairly close: thus unicode \'/u000D\' will be fully consumed\r\n							for (int lookAhead = 0; lookAhead < 3; lookAhead++) {\r\n								if (currentPosition + lookAhead == source.length)\r\n								break;\r\n								if (source[currentPosition + lookAhead] == \'\\n\')\r\n								break;\r\n								if (source[currentPosition + lookAhead] == \'\\\'\') {\r\n									currentPosition += lookAhead + 1;\r\n									break;\r\n								}\r\n							}\r\n							throw new InvalidInputException(INVALID_CHARACTER_CONSTANT);\r\n						}\r\n					}\r\n					if (getNextChar(\'\\\'\')) {\r\n						// relocate if finding another quote fairly close: thus unicode \'/u000D\' will be fully consumed\r\n						for (int lookAhead = 0; lookAhead < 3; lookAhead++) {\r\n							if (currentPosition + lookAhead == source.length)\r\n							break;\r\n							if (source[currentPosition + lookAhead] == \'\\n\')\r\n							break;\r\n							if (source[currentPosition + lookAhead] == \'\\\'\') {\r\n								currentPosition += lookAhead + 1;\r\n								break;\r\n							}\r\n						}\r\n						throw new InvalidInputException(INVALID_CHARACTER_CONSTANT);\r\n					}\r\n					if (getNextChar(\'\\\\\'))\r\n					scanEscapeCharacter();\r\n					else { // consume next character\r\n						unicodeAsBackSlash = false;\r\n						boolean checkIfUnicode = false;\r\n						try {\r\n							checkIfUnicode = ((currentCharacter = source[currentPosition++]) == \'\\\\\')\r\n							&& (source[currentPosition] == \'u\');\r\n						} catch(IndexOutOfBoundsException e) {\r\n							if (currentPosition > eofPosition)\r\n							return TokenNameEOF;\r\n							throw new InvalidInputException(INVALID_CHARACTER_CONSTANT);\r\n						}\r\n						if (checkIfUnicode) {\r\n							getNextUnicodeChar();\r\n						} else {\r\n							if (withoutUnicodePtr != 0) {\r\n								withoutUnicodeBuffer[++withoutUnicodePtr] = currentCharacter;\r\n							}\r\n						}\r\n					}\r\n					if (getNextChar(\'\\\'\'))\r\n					return TokenNameCharacterLiteral;\r\n					// relocate if finding another quote fairly close: thus unicode \'/u000D\' will be fully consumed\r\n					for (int lookAhead = 0; lookAhead < 20; lookAhead++) {\r\n						if (currentPosition + lookAhead == source.length)\r\n						break;\r\n						if (source[currentPosition + lookAhead] == \'\\n\')\r\n						break;\r\n						if (source[currentPosition + lookAhead] == \'\\\'\') {\r\n							currentPosition += lookAhead + 1;\r\n							break;\r\n						}\r\n					}\r\n					throw new InvalidInputException(INVALID_CHARACTER_CONSTANT);\r\n				case \'\"\' :\r\n					try {\r\n						// consume next character\r\n						unicodeAsBackSlash = false;\r\n						if (((currentCharacter = source[currentPosition++]) == \'\\\\\')\r\n								&& (source[currentPosition] == \'u\')) {\r\n							getNextUnicodeChar();\r\n						} else {\r\n							if (withoutUnicodePtr != 0) {\r\n								withoutUnicodeBuffer[++withoutUnicodePtr] = currentCharacter;\r\n							}\r\n						}\r\n\r\n						while (currentCharacter != \'\"\') {\r\n							/**** \\r and \\n are not valid in string literals ****/\r\n							if ((currentCharacter == \'\\n\') || (currentCharacter == \'\\r\')) {\r\n								// relocate if finding another quote fairly close: thus unicode \'/u000D\' will be fully consumed\r\n								for (int lookAhead = 0; lookAhead < 50; lookAhead++) {\r\n									if (currentPosition + lookAhead == source.length)\r\n									break;\r\n									if (source[currentPosition + lookAhead] == \'\\n\')\r\n									break;\r\n									if (source[currentPosition + lookAhead] == \'\\\"\') {\r\n										currentPosition += lookAhead + 1;\r\n										break;\r\n									}\r\n								}\r\n								throw new InvalidInputException(INVALID_CHAR_IN_STRING);\r\n							}\r\n							if (currentCharacter == \'\\\\\') {\r\n								int escapeSize = currentPosition;\r\n								boolean backSlashAsUnicodeInString = unicodeAsBackSlash;\r\n								//scanEscapeCharacter make a side effect on this value and we need the previous value few lines down this one\r\n								scanEscapeCharacter();\r\n								escapeSize = currentPosition - escapeSize;\r\n								if (withoutUnicodePtr == 0) {\r\n									//buffer all the entries that have been left aside....\r\n									withoutUnicodePtr = currentPosition - escapeSize - 1 - startPosition;\r\n									System.arraycopy(\r\n									source, \r\n									startPosition, \r\n									withoutUnicodeBuffer, \r\n									1, \r\n									withoutUnicodePtr); \r\n									withoutUnicodeBuffer[++withoutUnicodePtr] = currentCharacter;\r\n								} else { //overwrite the / in the buffer\r\n									withoutUnicodeBuffer[withoutUnicodePtr] = currentCharacter;\r\n									if (backSlashAsUnicodeInString) { //there are TWO \\ in the stream where only one is correct\r\n										withoutUnicodePtr--;\r\n									}\r\n								}\r\n							}\r\n							// consume next character\r\n							unicodeAsBackSlash = false;\r\n							if (((currentCharacter = source[currentPosition++]) == \'\\\\\')\r\n									&& (source[currentPosition] == \'u\')) {\r\n								getNextUnicodeChar();\r\n							} else {\r\n								if (withoutUnicodePtr != 0) {\r\n									withoutUnicodeBuffer[++withoutUnicodePtr] = currentCharacter;\r\n								}\r\n							}\r\n\r\n						}\r\n					} catch (IndexOutOfBoundsException e) {\r\n						throw new InvalidInputException(UNTERMINATED_STRING);\r\n					} catch (InvalidInputException e) {\r\n						if (e.getMessage().equals(INVALID_ESCAPE)) {\r\n							// relocate if finding another quote fairly close: thus unicode \'/u000D\' will be fully consumed\r\n							for (int lookAhead = 0; lookAhead < 50; lookAhead++) {\r\n								if (currentPosition + lookAhead == source.length)\r\n								break;\r\n								if (source[currentPosition + lookAhead] == \'\\n\')\r\n								break;\r\n								if (source[currentPosition + lookAhead] == \'\\\"\') {\r\n									currentPosition += lookAhead + 1;\r\n									break;\r\n								}\r\n							}\r\n\r\n						}\r\n						throw e; // rethrow\r\n					}\r\n					if (checkNonExternalizedStringLiterals){ // check for presence of	NLS tags //$NON-NLS-?$ where ? is an int.\r\n						if (currentLine == null) {\r\n							currentLine = new NLSLine();\r\n						}\r\n						currentLine.add(\r\n						new StringLiteral(\r\n						getCurrentTokenSourceString(), \r\n						startPosition, \r\n						currentPosition - 1));\r\n					}\r\n					return TokenNameStringLiteral;\r\n				case \'/\' :\r\n					{\r\n						int test;\r\n						if ((test = getNextChar(\'/\', \'*\')) == 0) { //line comment \r\n							try { //get the next char \r\n								if (((currentCharacter = source[currentPosition++]) == \'\\\\\')\r\n										&& (source[currentPosition] == \'u\')) {\r\n									//-------------unicode traitement ------------\r\n									int c1 = 0, c2 = 0, c3 = 0, c4 = 0;\r\n									currentPosition++;\r\n									while (source[currentPosition] == \'u\') {\r\n										currentPosition++;\r\n									}\r\n									if ((c1 = Character.getNumericValue(source[currentPosition++])) > 15\r\n											|| c1 < 0\r\n											|| (c2 = Character.getNumericValue(source[currentPosition++])) > 15\r\n											|| c2 < 0\r\n											|| (c3 = Character.getNumericValue(source[currentPosition++])) > 15\r\n											|| c3 < 0\r\n											|| (c4 = Character.getNumericValue(source[currentPosition++])) > 15\r\n											|| c4 < 0) {\r\n										throw new InvalidInputException(INVALID_UNICODE_ESCAPE);\r\n									} else {\r\n										currentCharacter = (char) (((c1 * 16 + c2) * 16 + c3) * 16 + c4);\r\n									}\r\n								}\r\n\r\n								//handle the \\\\u case manually into comment\r\n								if (currentCharacter == \'\\\\\') {\r\n									if (source[currentPosition] == \'\\\\\')\r\n									currentPosition++;\r\n								} //jump over the \\\\\r\n								boolean isUnicode = false;\r\n								while (currentCharacter != \'\\r\' && currentCharacter != \'\\n\') {\r\n									//get the next char\r\n									isUnicode = false;									\r\n									if (((currentCharacter = source[currentPosition++]) == \'\\\\\')\r\n											&& (source[currentPosition] == \'u\')) {\r\n										isUnicode = true;											\r\n										//-------------unicode traitement ------------\r\n										int c1 = 0, c2 = 0, c3 = 0, c4 = 0;\r\n										currentPosition++;\r\n										while (source[currentPosition] == \'u\') {\r\n											currentPosition++;\r\n										}\r\n										if ((c1 = Character.getNumericValue(source[currentPosition++])) > 15\r\n												|| c1 < 0\r\n												|| (c2 = Character.getNumericValue(source[currentPosition++])) > 15\r\n												|| c2 < 0\r\n												|| (c3 = Character.getNumericValue(source[currentPosition++])) > 15\r\n												|| c3 < 0\r\n												|| (c4 = Character.getNumericValue(source[currentPosition++])) > 15\r\n												|| c4 < 0) {\r\n											throw new InvalidInputException(INVALID_UNICODE_ESCAPE);\r\n										} else {\r\n											currentCharacter = (char) (((c1 * 16 + c2) * 16 + c3) * 16 + c4);\r\n										}\r\n									}\r\n									//handle the \\\\u case manually into comment\r\n									if (currentCharacter == \'\\\\\') {\r\n										if (source[currentPosition] == \'\\\\\')\r\n										currentPosition++;\r\n									} //jump over the \\\\\r\n								}\r\n								/*\r\n								* We need to completely consume the line break\r\n								*/\r\n								if (currentCharacter == \'\\r\'\r\n										&& source.length > currentPosition) {\r\n									if (source[currentPosition] == \'\\n\') {\r\n										currentPosition++;\r\n										currentCharacter = \'\\n\';\r\n									} else if ((source[currentPosition] == \'\\\\\')\r\n											&& (source[currentPosition + 1] == \'u\')) {\r\n										isUnicode = true;\r\n										char unicodeChar;\r\n										int index = currentPosition + 1;\r\n										index++;\r\n										while (source[index] == \'u\') {\r\n											index++;\r\n										}\r\n										//-------------unicode traitement ------------\r\n										int c1 = 0, c2 = 0, c3 = 0, c4 = 0;\r\n										if ((c1 = Character.getNumericValue(source[index++])) > 15\r\n												|| c1 < 0\r\n												|| (c2 = Character.getNumericValue(source[index++])) > 15\r\n												|| c2 < 0\r\n												|| (c3 = Character.getNumericValue(source[index++])) > 15\r\n												|| c3 < 0\r\n												|| (c4 = Character.getNumericValue(source[index++])) > 15\r\n												|| c4 < 0) {\r\n											currentPosition = index;\r\n											throw new InvalidInputException(INVALID_UNICODE_ESCAPE);\r\n										} else {\r\n											unicodeChar = (char) (((c1 * 16 + c2) * 16 + c3) * 16 + c4);\r\n										}\r\n										if (unicodeChar == \'\\n\') {\r\n											currentPosition = index;\r\n											currentCharacter = \'\\n\';\r\n										}\r\n									}\r\n								}\r\n								recordComment(false);\r\n								if (this.taskTags != null) checkTaskTag(this.startPosition, this.currentPosition);\r\n								if ((currentCharacter == \'\\r\') || (currentCharacter == \'\\n\')) {\r\n									checkNonExternalizedString();\r\n									if (recordLineSeparator) {\r\n										if (isUnicode) {\r\n											pushUnicodeLineSeparator();\r\n										} else {\r\n											pushLineSeparator();\r\n										}\r\n									} else {\r\n										currentLine = null;\r\n									}\r\n								}\r\n								if (tokenizeComments) {\r\n									return TokenNameCOMMENT_LINE;\r\n								}\r\n							} catch (IndexOutOfBoundsException e) {\r\n								recordComment(false);\r\n								if (this.taskTags != null) checkTaskTag(this.startPosition, this.currentPosition-1);\r\n								if (tokenizeComments) {\r\n									this.currentPosition--; // reset one character behind\r\n									return TokenNameCOMMENT_LINE;\r\n								}\r\n							}\r\n							break;\r\n						}\r\n						if (test > 0) { //traditional and annotation comment\r\n							try { //get the next char\r\n								boolean isJavadoc = false, star = false;\r\n								boolean isUnicode = false;\r\n								// consume next character\r\n								unicodeAsBackSlash = false;\r\n								if (((currentCharacter = source[currentPosition++]) == \'\\\\\')\r\n										&& (source[currentPosition] == \'u\')) {\r\n									getNextUnicodeChar();\r\n									isUnicode = true;\r\n								} else {\r\n									isUnicode = false;\r\n									if (withoutUnicodePtr != 0) {\r\n										withoutUnicodeBuffer[++withoutUnicodePtr] = currentCharacter;\r\n									}\r\n								}\r\n								\r\n								if (currentCharacter == \'*\') {\r\n									isJavadoc = true;\r\n									star = true;\r\n								}\r\n								if ((currentCharacter == \'\\r\') || (currentCharacter == \'\\n\')) {\r\n									checkNonExternalizedString();\r\n									if (recordLineSeparator) {\r\n										if (!isUnicode) {\r\n											pushLineSeparator();\r\n										}\r\n									} else {\r\n										currentLine = null;\r\n									}\r\n								}\r\n								isUnicode = false;\r\n								if (((currentCharacter = source[currentPosition++]) == \'\\\\\')\r\n										&& (source[currentPosition] == \'u\')) {\r\n									//-------------unicode traitement ------------\r\n									getNextUnicodeChar();\r\n									isUnicode = true;\r\n								} else {\r\n									isUnicode = false;\r\n								}\r\n								//handle the \\\\u case manually into comment\r\n								if (currentCharacter == \'\\\\\') {\r\n									if (source[currentPosition] == \'\\\\\')\r\n									currentPosition++; //jump over the \\\\\r\n								}\r\n								//loop until end of comment */\r\n								while ((currentCharacter != \'/\') || (!star)) {\r\n									if ((currentCharacter == \'\\r\') || (currentCharacter == \'\\n\')) {\r\n										checkNonExternalizedString();\r\n										if (recordLineSeparator) {\r\n											if (!isUnicode) {\r\n												pushLineSeparator();\r\n											}\r\n										} else {\r\n											currentLine = null;\r\n										}\r\n									}\r\n									star = currentCharacter == \'*\';\r\n									//get next char\r\n									if (((currentCharacter = source[currentPosition++]) == \'\\\\\')\r\n											&& (source[currentPosition] == \'u\')) {\r\n										//-------------unicode traitement ------------\r\n										getNextUnicodeChar();\r\n										isUnicode = true;\r\n									} else {\r\n										isUnicode = false;\r\n									}\r\n									//handle the \\\\u case manually into comment\r\n									if (currentCharacter == \'\\\\\') {\r\n										if (source[currentPosition] == \'\\\\\')\r\n										currentPosition++;\r\n									} //jump over the \\\\\r\n								}\r\n								recordComment(isJavadoc);\r\n								if (this.taskTags != null) checkTaskTag(this.startPosition, this.currentPosition);\r\n								if (tokenizeComments) {\r\n									if (isJavadoc)\r\n									return TokenNameCOMMENT_JAVADOC;\r\n									return TokenNameCOMMENT_BLOCK;\r\n								}\r\n							} catch (IndexOutOfBoundsException e) {\r\n								throw new InvalidInputException(UNTERMINATED_COMMENT);\r\n							}\r\n							break;\r\n						}\r\n						if (getNextChar(\'=\'))\r\n						return TokenNameDIVIDE_EQUAL;\r\n						return TokenNameDIVIDE;\r\n					}\r\n				case \'\\u001a\' :\r\n					if (atEnd())\r\n					return TokenNameEOF;\r\n					//the atEnd may not be <currentPosition == source.length> if source is only some part of a real (external) stream\r\n					throw new InvalidInputException(\"Ctrl-Z\"); //$NON-NLS-1$\r\n\r\n					default :\r\n					if (Character.isJavaIdentifierStart(currentCharacter))\r\n					return scanIdentifierOrKeyword();\r\n					if (Character.isDigit(currentCharacter))\r\n					return scanNumber(false);\r\n					return TokenNameERROR;\r\n				}\r\n			}\r\n		} //-----------------end switch while try--------------------\r\n		catch (IndexOutOfBoundsException e) {\r\n			if (tokenizeWhiteSpace && (whiteStart != currentPosition - 1)) {\r\n				// reposition scanner in case we are interested by spaces as tokens\r\n				currentPosition--;\r\n				startPosition = whiteStart;\r\n				return TokenNameWHITESPACE;\r\n			}\r\n		}\r\n		return TokenNameEOF;\r\n	}\r\n	public final void getNextUnicodeChar()\r\n	throws IndexOutOfBoundsException, InvalidInputException {\r\n		//VOID\r\n		//handle the case of unicode.\r\n		//when a unicode appears then we must use a buffer that holds char internal values\r\n		//At the end of this method currentCharacter holds the new visited char\r\n		//and currentPosition points right next after it\r\n\r\n		//ALL getNextChar.... ARE OPTIMIZED COPIES \r\n\r\n		int c1 = 0, c2 = 0, c3 = 0, c4 = 0, unicodeSize = 6;\r\n		currentPosition++;\r\n		while (source[currentPosition] == \'u\') {\r\n			currentPosition++;\r\n			unicodeSize++;\r\n		}\r\n\r\n		if ((c1 = Character.getNumericValue(source[currentPosition++])) > 15\r\n				|| c1 < 0\r\n				|| (c2 = Character.getNumericValue(source[currentPosition++])) > 15\r\n				|| c2 < 0\r\n				|| (c3 = Character.getNumericValue(source[currentPosition++])) > 15\r\n				|| c3 < 0\r\n				|| (c4 = Character.getNumericValue(source[currentPosition++])) > 15\r\n				|| c4 < 0){\r\n			throw new InvalidInputException(INVALID_UNICODE_ESCAPE);\r\n		} else {\r\n			currentCharacter = (char) (((c1 * 16 + c2) * 16 + c3) * 16 + c4);\r\n			//need the unicode buffer\r\n			if (withoutUnicodePtr == 0) {\r\n				//buffer all the entries that have been left aside....\r\n				withoutUnicodePtr = currentPosition - unicodeSize - startPosition;\r\n				System.arraycopy(\r\n				source, \r\n				startPosition, \r\n				withoutUnicodeBuffer, \r\n				1, \r\n				withoutUnicodePtr); \r\n			}\r\n			//fill the buffer with the char\r\n			withoutUnicodeBuffer[++withoutUnicodePtr] = currentCharacter;\r\n		}\r\n		unicodeAsBackSlash = currentCharacter == \'\\\\\';\r\n	}\r\n\r\n	public char[] getSource(){\r\n		return this.source;\r\n	}\r\n\r\n	/* Tokenize a method body, assuming that curly brackets are properly balanced.\r\n*/\r\n	public final void jumpOverMethodBody() {\r\n\r\n		this.wasAcr = false;\r\n		int found = 1;\r\n		try {\r\n			while (true) { //loop for jumping over comments\r\n				// ---------Consume white space and handles startPosition---------\r\n				boolean isWhiteSpace;\r\n				do {\r\n					startPosition = currentPosition;\r\n					if (((currentCharacter = source[currentPosition++]) == \'\\\\\')\r\n							&& (source[currentPosition] == \'u\')) {\r\n						isWhiteSpace = jumpOverUnicodeWhiteSpace();\r\n					} else {\r\n						if (recordLineSeparator\r\n								&& ((currentCharacter == \'\\r\') || (currentCharacter == \'\\n\')))\r\n						pushLineSeparator();\r\n						isWhiteSpace = CharOperation.isWhitespace(currentCharacter);\r\n					}\r\n				} while (isWhiteSpace);\r\n\r\n				// -------consume token until } is found---------\r\n				switch (currentCharacter) {\r\n				case \'{\' :\r\n					found++;\r\n					break;\r\n				case \'}\' :\r\n					found--;\r\n					if (found == 0)\r\n					return;\r\n					break;\r\n				case \'\\\'\' :\r\n					{\r\n						boolean test;\r\n						test = getNextChar(\'\\\\\');\r\n						if (test) {\r\n							try {\r\n								scanEscapeCharacter();\r\n							} catch (InvalidInputException ex) {\r\n							}\r\n						} else {\r\n							try { // consume next character\r\n								unicodeAsBackSlash = false;\r\n								if (((currentCharacter = source[currentPosition++]) == \'\\\\\')\r\n										&& (source[currentPosition] == \'u\')) {\r\n									getNextUnicodeChar();\r\n								} else {\r\n									if (withoutUnicodePtr != 0) {\r\n										withoutUnicodeBuffer[++withoutUnicodePtr] = currentCharacter;\r\n									}\r\n								}\r\n							} catch (InvalidInputException ex) {\r\n							}\r\n						}\r\n						getNextChar(\'\\\'\');\r\n						break;\r\n					}\r\n				case \'\"\' :\r\n					try {\r\n						try { // consume next character\r\n							unicodeAsBackSlash = false;\r\n							if (((currentCharacter = source[currentPosition++]) == \'\\\\\')\r\n									&& (source[currentPosition] == \'u\')) {\r\n								getNextUnicodeChar();\r\n							} else {\r\n								if (withoutUnicodePtr != 0) {\r\n									withoutUnicodeBuffer[++withoutUnicodePtr] = currentCharacter;\r\n								}\r\n							}\r\n						} catch (InvalidInputException ex) {\r\n						}\r\n						while (currentCharacter != \'\"\') {\r\n							if (currentCharacter == \'\\r\'){\r\n								if (source[currentPosition] == \'\\n\') currentPosition++;\r\n								break; // the string cannot go further that the line\r\n							}\r\n							if (currentCharacter == \'\\n\'){\r\n								break; // the string cannot go further that the line\r\n							}\r\n							if (currentCharacter == \'\\\\\') {\r\n								try {\r\n									scanEscapeCharacter();\r\n								} catch (InvalidInputException ex) {\r\n								}\r\n							}\r\n							try { // consume next character\r\n								unicodeAsBackSlash = false;\r\n								if (((currentCharacter = source[currentPosition++]) == \'\\\\\')\r\n										&& (source[currentPosition] == \'u\')) {\r\n									getNextUnicodeChar();\r\n								} else {\r\n									if (withoutUnicodePtr != 0) {\r\n										withoutUnicodeBuffer[++withoutUnicodePtr] = currentCharacter;\r\n									}\r\n								}\r\n							} catch (InvalidInputException ex) {\r\n							}\r\n						}\r\n					} catch (IndexOutOfBoundsException e) {\r\n						return;\r\n					}\r\n					break;\r\n				case \'/\' :\r\n					{\r\n						int test;\r\n						boolean isUnicode;\r\n						if ((test = getNextChar(\'/\', \'*\')) == 0) { //line comment \r\n							try {\r\n								//get the next char \r\n								if (((currentCharacter = source[currentPosition++]) == \'\\\\\')\r\n										&& (source[currentPosition] == \'u\')) {\r\n									//-------------unicode traitement ------------\r\n									isUnicode = true;\r\n									int c1 = 0, c2 = 0, c3 = 0, c4 = 0;\r\n									currentPosition++;\r\n									while (source[currentPosition] == \'u\') {\r\n										currentPosition++;\r\n									}\r\n									if ((c1 = Character.getNumericValue(source[currentPosition++])) > 15\r\n											|| c1 < 0\r\n											|| (c2 = Character.getNumericValue(source[currentPosition++])) > 15\r\n											|| c2 < 0\r\n											|| (c3 = Character.getNumericValue(source[currentPosition++])) > 15\r\n											|| c3 < 0\r\n											|| (c4 = Character.getNumericValue(source[currentPosition++])) > 15\r\n											|| c4 < 0) { //error don\'t care of the value\r\n										currentCharacter = \'A\';\r\n									} //something different from \\n and \\r\r\n									else {\r\n										currentCharacter = (char) (((c1 * 16 + c2) * 16 + c3) * 16 + c4);\r\n									}\r\n								} else {\r\n									isUnicode = false;\r\n								}\r\n\r\n								while (currentCharacter != \'\\r\' && currentCharacter != \'\\n\') {\r\n									//get the next char \r\n									if (((currentCharacter = source[currentPosition++]) == \'\\\\\')\r\n											&& (source[currentPosition] == \'u\')) {\r\n										//-------------unicode traitement ------------\r\n										int c1 = 0, c2 = 0, c3 = 0, c4 = 0;\r\n										currentPosition++;\r\n										isUnicode = true;\r\n										while (source[currentPosition] == \'u\') {\r\n											currentPosition++;\r\n										}\r\n										if ((c1 = Character.getNumericValue(source[currentPosition++])) > 15\r\n												|| c1 < 0\r\n												|| (c2 = Character.getNumericValue(source[currentPosition++])) > 15\r\n												|| c2 < 0\r\n												|| (c3 = Character.getNumericValue(source[currentPosition++])) > 15\r\n												|| c3 < 0\r\n												|| (c4 = Character.getNumericValue(source[currentPosition++])) > 15\r\n												|| c4 < 0) { //error don\'t care of the value\r\n											currentCharacter = \'A\';\r\n										} //something different from \\n and \\r\r\n										else {\r\n											currentCharacter = (char) (((c1 * 16 + c2) * 16 + c3) * 16 + c4);\r\n										}\r\n									} else {\r\n										isUnicode = false;\r\n									}\r\n								}\r\n								if (recordLineSeparator\r\n										&& ((currentCharacter == \'\\r\') || (currentCharacter == \'\\n\'))) {\r\n									if (!isUnicode) {\r\n										pushLineSeparator();\r\n									}\r\n								}\r\n							} catch (IndexOutOfBoundsException e) {\r\n							} //an eof will them be generated\r\n							break;\r\n						}\r\n						if (test > 0) { //traditional and annotation comment\r\n							isUnicode = false;\r\n							boolean star = false;\r\n							try { // consume next character\r\n								unicodeAsBackSlash = false;\r\n								if (((currentCharacter = source[currentPosition++]) == \'\\\\\')\r\n										&& (source[currentPosition] == \'u\')) {\r\n									getNextUnicodeChar();\r\n									isUnicode = true;\r\n								} else {\r\n									isUnicode = false;\r\n									if (withoutUnicodePtr != 0) {\r\n										withoutUnicodeBuffer[++withoutUnicodePtr] = currentCharacter;\r\n									}\r\n								}\r\n							} catch (InvalidInputException ex) {\r\n							}\r\n							if (currentCharacter == \'*\') {\r\n								star = true;\r\n							}\r\n							if (recordLineSeparator\r\n									&& ((currentCharacter == \'\\r\') || (currentCharacter == \'\\n\'))) {\r\n								if (!isUnicode) {\r\n									pushLineSeparator();\r\n								}\r\n							}\r\n							try { //get the next char \r\n								if (((currentCharacter = source[currentPosition++]) == \'\\\\\')\r\n										&& (source[currentPosition] == \'u\')) {\r\n									//-------------unicode traitement ------------\r\n									isUnicode = true;\r\n									int c1 = 0, c2 = 0, c3 = 0, c4 = 0;\r\n									currentPosition++;\r\n									while (source[currentPosition] == \'u\') {\r\n										currentPosition++;\r\n									}\r\n									if ((c1 = Character.getNumericValue(source[currentPosition++])) > 15\r\n											|| c1 < 0\r\n											|| (c2 = Character.getNumericValue(source[currentPosition++])) > 15\r\n											|| c2 < 0\r\n											|| (c3 = Character.getNumericValue(source[currentPosition++])) > 15\r\n											|| c3 < 0\r\n											|| (c4 = Character.getNumericValue(source[currentPosition++])) > 15\r\n											|| c4 < 0) { //error don\'t care of the value\r\n										currentCharacter = \'A\';\r\n									} //something different from * and /\r\n									else {\r\n										currentCharacter = (char) (((c1 * 16 + c2) * 16 + c3) * 16 + c4);\r\n									}\r\n								} else {\r\n									isUnicode = false;\r\n								}\r\n								//loop until end of comment */ \r\n								while ((currentCharacter != \'/\') || (!star)) {\r\n									if (recordLineSeparator\r\n											&& ((currentCharacter == \'\\r\') || (currentCharacter == \'\\n\'))) {\r\n										if (!isUnicode) {\r\n											pushLineSeparator();\r\n										}\r\n									}\r\n									star = currentCharacter == \'*\';\r\n									//get next char\r\n									if (((currentCharacter = source[currentPosition++]) == \'\\\\\')\r\n											&& (source[currentPosition] == \'u\')) {\r\n										//-------------unicode traitement ------------\r\n										isUnicode = true;\r\n										int c1 = 0, c2 = 0, c3 = 0, c4 = 0;\r\n										currentPosition++;\r\n										while (source[currentPosition] == \'u\') {\r\n											currentPosition++;\r\n										}\r\n										if ((c1 = Character.getNumericValue(source[currentPosition++])) > 15\r\n												|| c1 < 0\r\n												|| (c2 = Character.getNumericValue(source[currentPosition++])) > 15\r\n												|| c2 < 0\r\n												|| (c3 = Character.getNumericValue(source[currentPosition++])) > 15\r\n												|| c3 < 0\r\n												|| (c4 = Character.getNumericValue(source[currentPosition++])) > 15\r\n												|| c4 < 0) { //error don\'t care of the value\r\n											currentCharacter = \'A\';\r\n										} //something different from * and /\r\n										else {\r\n											currentCharacter = (char) (((c1 * 16 + c2) * 16 + c3) * 16 + c4);\r\n										}\r\n									} else {\r\n										isUnicode = false;\r\n									}\r\n								}\r\n							} catch (IndexOutOfBoundsException e) {\r\n								return;\r\n							}\r\n							break;\r\n						}\r\n						break;\r\n					}\r\n\r\n					default :\r\n					if (Character.isJavaIdentifierStart(currentCharacter)) {\r\n						try {\r\n							scanIdentifierOrKeyword();\r\n						} catch (InvalidInputException ex) {\r\n						}\r\n						break;\r\n					}\r\n					if (Character.isDigit(currentCharacter)) {\r\n						try {\r\n							scanNumber(false);\r\n						} catch (InvalidInputException ex) {\r\n						}\r\n						break;\r\n					}\r\n				}\r\n			}\r\n			//-----------------end switch while try--------------------\r\n		} catch (IndexOutOfBoundsException e) {\r\n		} catch (InvalidInputException e) {\r\n		}\r\n		return;\r\n	}\r\n	public final boolean jumpOverUnicodeWhiteSpace() throws InvalidInputException {\r\n		//BOOLEAN\r\n		//handle the case of unicode. Jump over the next whiteSpace\r\n		//making startPosition pointing on the next available char\r\n		//On false, the currentCharacter is filled up with a potential\r\n		//correct char\r\n\r\n		try {\r\n			this.wasAcr = false;\r\n			int c1, c2, c3, c4;\r\n			int unicodeSize = 6;\r\n			currentPosition++;\r\n			while (source[currentPosition] == \'u\') {\r\n				currentPosition++;\r\n				unicodeSize++;\r\n			}\r\n\r\n			if (((c1 = Character.getNumericValue(source[currentPosition++])) > 15\r\n						|| c1 < 0)\r\n					|| ((c2 = Character.getNumericValue(source[currentPosition++])) > 15 || c2 < 0)\r\n					|| ((c3 = Character.getNumericValue(source[currentPosition++])) > 15 || c3 < 0)\r\n					|| ((c4 = Character.getNumericValue(source[currentPosition++])) > 15 || c4 < 0)) {\r\n				throw new InvalidInputException(INVALID_UNICODE_ESCAPE);\r\n			}\r\n\r\n			currentCharacter = (char) (((c1 * 16 + c2) * 16 + c3) * 16 + c4);\r\n			if (CharOperation.isWhitespace(currentCharacter))\r\n			return true;\r\n\r\n			//buffer the new char which is not a white space\r\n			withoutUnicodeBuffer[++withoutUnicodePtr] = currentCharacter;\r\n			//withoutUnicodePtr == 1 is true here\r\n			return false;\r\n		} catch (IndexOutOfBoundsException e){\r\n			throw new InvalidInputException(INVALID_UNICODE_ESCAPE);\r\n		}\r\n	}\r\n\r\n	final char[] optimizedCurrentTokenSource1() {\r\n		//return always the same char[] build only once\r\n\r\n		//optimization at no speed cost of 99.5 % of the singleCharIdentifier\r\n		char charOne = source[startPosition];\r\n		switch (charOne) {\r\n		case \'a\' :\r\n			return charArray_a;\r\n		case \'b\' :\r\n			return charArray_b;\r\n		case \'c\' :\r\n			return charArray_c;\r\n		case \'d\' :\r\n			return charArray_d;\r\n		case \'e\' :\r\n			return charArray_e;\r\n		case \'f\' :\r\n			return charArray_f;\r\n		case \'g\' :\r\n			return charArray_g;\r\n		case \'h\' :\r\n			return charArray_h;\r\n		case \'i\' :\r\n			return charArray_i;\r\n		case \'j\' :\r\n			return charArray_j;\r\n		case \'k\' :\r\n			return charArray_k;\r\n		case \'l\' :\r\n			return charArray_l;\r\n		case \'m\' :\r\n			return charArray_m;\r\n		case \'n\' :\r\n			return charArray_n;\r\n		case \'o\' :\r\n			return charArray_o;\r\n		case \'p\' :\r\n			return charArray_p;\r\n		case \'q\' :\r\n			return charArray_q;\r\n		case \'r\' :\r\n			return charArray_r;\r\n		case \'s\' :\r\n			return charArray_s;\r\n		case \'t\' :\r\n			return charArray_t;\r\n		case \'u\' :\r\n			return charArray_u;\r\n		case \'v\' :\r\n			return charArray_v;\r\n		case \'w\' :\r\n			return charArray_w;\r\n		case \'x\' :\r\n			return charArray_x;\r\n		case \'y\' :\r\n			return charArray_y;\r\n		case \'z\' :\r\n			return charArray_z;\r\n			default :\r\n			return new char[] {charOne};\r\n		}\r\n	}\r\n	final char[] optimizedCurrentTokenSource2() {\r\n		//try to return the same char[] build only once\r\n\r\n		char c0, c1;\r\n		int hash = \r\n		(((c0 = source[startPosition]) << 6) + (c1 = source[startPosition + 1]))\r\n		% TableSize; \r\n		char[][] table = charArray_length[0][hash];\r\n		int i = newEntry2;\r\n		while (++i < InternalTableSize) {\r\n			char[] charArray = table[i];\r\n			if ((c0 == charArray[0]) && (c1 == charArray[1]))\r\n			return charArray;\r\n		}\r\n		//---------other side---------\r\n		i = -1;\r\n		int max = newEntry2;\r\n		while (++i <= max) {\r\n			char[] charArray = table[i];\r\n			if ((c0 == charArray[0]) && (c1 == charArray[1]))\r\n			return charArray;\r\n		}\r\n		//--------add the entry-------\r\n		if (++max >= InternalTableSize) max = 0;\r\n		char[] r;\r\n		table[max] = (r = new char[] {c0, c1});\r\n		newEntry2 = max;\r\n		return r;\r\n	}\r\n	final char[] optimizedCurrentTokenSource3() {\r\n		//try to return the same char[] build only once\r\n\r\n		char c0, c1, c2;\r\n		int hash = \r\n		(((c0 = source[startPosition]) << 12)\r\n		+ ((c1 = source[startPosition + 1]) << 6)\r\n		+ (c2 = source[startPosition + 2]))\r\n		% TableSize; \r\n		char[][] table = charArray_length[1][hash];\r\n		int i = newEntry3;\r\n		while (++i < InternalTableSize) {\r\n			char[] charArray = table[i];\r\n			if ((c0 == charArray[0]) && (c1 == charArray[1]) && (c2 == charArray[2]))\r\n			return charArray;\r\n		}\r\n		//---------other side---------\r\n		i = -1;\r\n		int max = newEntry3;\r\n		while (++i <= max) {\r\n			char[] charArray = table[i];\r\n			if ((c0 == charArray[0]) && (c1 == charArray[1]) && (c2 == charArray[2]))\r\n			return charArray;\r\n		}\r\n		//--------add the entry-------\r\n		if (++max >= InternalTableSize) max = 0;\r\n		char[] r;\r\n		table[max] = (r = new char[] {c0, c1, c2});\r\n		newEntry3 = max;\r\n		return r;\r\n	}\r\n	final char[] optimizedCurrentTokenSource4() {\r\n		//try to return the same char[] build only once\r\n\r\n		char c0, c1, c2, c3;\r\n		long hash = \r\n		((((long) (c0 = source[startPosition])) << 18)\r\n		+ ((c1 = source[startPosition + 1]) << 12)\r\n		+ ((c2 = source[startPosition + 2]) << 6)\r\n		+ (c3 = source[startPosition + 3]))\r\n		% TableSize; \r\n		char[][] table = charArray_length[2][(int) hash];\r\n		int i = newEntry4;\r\n		while (++i < InternalTableSize) {\r\n			char[] charArray = table[i];\r\n			if ((c0 == charArray[0])\r\n					&& (c1 == charArray[1])\r\n					&& (c2 == charArray[2])\r\n					&& (c3 == charArray[3]))\r\n			return charArray;\r\n		}\r\n		//---------other side---------\r\n		i = -1;\r\n		int max = newEntry4;\r\n		while (++i <= max) {\r\n			char[] charArray = table[i];\r\n			if ((c0 == charArray[0])\r\n					&& (c1 == charArray[1])\r\n					&& (c2 == charArray[2])\r\n					&& (c3 == charArray[3]))\r\n			return charArray;\r\n		}\r\n		//--------add the entry-------\r\n		if (++max >= InternalTableSize) max = 0;\r\n		char[] r;\r\n		table[max] = (r = new char[] {c0, c1, c2, c3});\r\n		newEntry4 = max;\r\n		return r;\r\n		\r\n	}\r\n	final char[] optimizedCurrentTokenSource5() {\r\n		//try to return the same char[] build only once\r\n\r\n		char c0, c1, c2, c3, c4;\r\n		long hash = \r\n		((((long) (c0 = source[startPosition])) << 24)\r\n		+ (((long) (c1 = source[startPosition + 1])) << 18)\r\n		+ ((c2 = source[startPosition + 2]) << 12)\r\n		+ ((c3 = source[startPosition + 3]) << 6)\r\n		+ (c4 = source[startPosition + 4]))\r\n		% TableSize; \r\n		char[][] table = charArray_length[3][(int) hash];\r\n		int i = newEntry5;\r\n		while (++i < InternalTableSize) {\r\n			char[] charArray = table[i];\r\n			if ((c0 == charArray[0])\r\n					&& (c1 == charArray[1])\r\n					&& (c2 == charArray[2])\r\n					&& (c3 == charArray[3])\r\n					&& (c4 == charArray[4]))\r\n			return charArray;\r\n		}\r\n		//---------other side---------\r\n		i = -1;\r\n		int max = newEntry5;\r\n		while (++i <= max) {\r\n			char[] charArray = table[i];\r\n			if ((c0 == charArray[0])\r\n					&& (c1 == charArray[1])\r\n					&& (c2 == charArray[2])\r\n					&& (c3 == charArray[3])\r\n					&& (c4 == charArray[4]))\r\n			return charArray;\r\n		}\r\n		//--------add the entry-------\r\n		if (++max >= InternalTableSize) max = 0;\r\n		char[] r;\r\n		table[max] = (r = new char[] {c0, c1, c2, c3, c4});\r\n		newEntry5 = max;\r\n		return r;\r\n		\r\n	}\r\n	final char[] optimizedCurrentTokenSource6() {\r\n		//try to return the same char[] build only once\r\n\r\n		char c0, c1, c2, c3, c4, c5;\r\n		long hash = \r\n		((((long) (c0 = source[startPosition])) << 32)\r\n		+ (((long) (c1 = source[startPosition + 1])) << 24)\r\n		+ (((long) (c2 = source[startPosition + 2])) << 18)\r\n		+ ((c3 = source[startPosition + 3]) << 12)\r\n		+ ((c4 = source[startPosition + 4]) << 6)\r\n		+ (c5 = source[startPosition + 5]))\r\n		% TableSize; \r\n		char[][] table = charArray_length[4][(int) hash];\r\n		int i = newEntry6;\r\n		while (++i < InternalTableSize) {\r\n			char[] charArray = table[i];\r\n			if ((c0 == charArray[0])\r\n					&& (c1 == charArray[1])\r\n					&& (c2 == charArray[2])\r\n					&& (c3 == charArray[3])\r\n					&& (c4 == charArray[4])\r\n					&& (c5 == charArray[5]))\r\n			return charArray;\r\n		}\r\n		//---------other side---------\r\n		i = -1;\r\n		int max = newEntry6;\r\n		while (++i <= max) {\r\n			char[] charArray = table[i];\r\n			if ((c0 == charArray[0])\r\n					&& (c1 == charArray[1])\r\n					&& (c2 == charArray[2])\r\n					&& (c3 == charArray[3])\r\n					&& (c4 == charArray[4])\r\n					&& (c5 == charArray[5]))\r\n			return charArray;\r\n		}\r\n		//--------add the entry-------\r\n		if (++max >= InternalTableSize) max = 0;\r\n		char[] r;\r\n		table[max] = (r = new char[] {c0, c1, c2, c3, c4, c5});\r\n		newEntry6 = max;\r\n		return r;	\r\n	}\r\n	private void parseTags(NLSLine line) throws InvalidInputException {\r\n		String s = new String(getCurrentTokenSource());\r\n		int pos = s.indexOf(TAG_PREFIX);\r\n		int lineLength = line.size();\r\n		while (pos != -1) {\r\n			int start = pos + TAG_PREFIX_LENGTH;\r\n			int end = s.indexOf(TAG_POSTFIX, start);\r\n			if (end != -1) {\r\n				String index = s.substring(start, end);\r\n				int i = 0;\r\n				try {\r\n					i = Integer.parseInt(index) - 1; // Tags are one based not zero based.\r\n				} catch (NumberFormatException e) {\r\n					i = -1; // we don\'t want to consider this as a valid NLS tag\r\n				}\r\n				if (line.exists(i)) {\r\n					line.set(i, null);\r\n				}\r\n			}\r\n			pos = s.indexOf(TAG_PREFIX, start);\r\n		}\r\n\r\n		this.nonNLSStrings = new StringLiteral[lineLength];\r\n		int nonNLSCounter = 0;\r\n		for (Iterator iterator = line.iterator(); iterator.hasNext(); ) {\r\n			StringLiteral literal = (StringLiteral) iterator.next();\r\n			if (literal != null) {\r\n				this.nonNLSStrings[nonNLSCounter++] = literal;\r\n			}\r\n		}\r\n		if (nonNLSCounter == 0) {\r\n			this.nonNLSStrings = null;\r\n			currentLine = null;\r\n			return;\r\n		} \r\n		this.wasNonExternalizedStringLiteral = true;\r\n		if (nonNLSCounter != lineLength) {\r\n			System.arraycopy(this.nonNLSStrings, 0, (this.nonNLSStrings = new StringLiteral[nonNLSCounter]), 0, nonNLSCounter);\r\n		}\r\n		currentLine = null;\r\n	}\r\n\r\n	public final void pushLineSeparator() throws InvalidInputException {\r\n		//see comment on isLineDelimiter(char) for the use of \'\\n\' and \'\\r\'\r\n		final int INCREMENT = 250;\r\n		\r\n		if (this.checkNonExternalizedStringLiterals) {\r\n			// reinitialize the current line for non externalize strings purpose\r\n			currentLine = null;\r\n		}\r\n		//currentCharacter is at position currentPosition-1\r\n\r\n		// cr 000D\r\n		if (currentCharacter == \'\\r\') {\r\n			int separatorPos = currentPosition - 1;\r\n			//TODO : (olivier) david - why the following line was \"if ((linePtr > 0) && (lineEnds[linePtr] >= separatorPos)) return;\" ?\r\n			if ((linePtr >= 0) && (lineEnds[linePtr] >= separatorPos)) return;\r\n			//System.out.println(\"CR-\" + separatorPos);\r\n			try {\r\n				lineEnds[++linePtr] = separatorPos;\r\n			} catch (IndexOutOfBoundsException e) {\r\n				//linePtr value is correct\r\n				int oldLength = lineEnds.length;\r\n				int[] old = lineEnds;\r\n				lineEnds = new int[oldLength + INCREMENT];\r\n				System.arraycopy(old, 0, lineEnds, 0, oldLength);\r\n				lineEnds[linePtr] = separatorPos;\r\n			}\r\n			// look-ahead for merged cr+lf\r\n			try {\r\n				if (source[currentPosition] == \'\\n\') {\r\n					//System.out.println(\"look-ahead LF-\" + currentPosition);			\r\n					lineEnds[linePtr] = currentPosition;\r\n					currentPosition++;\r\n					wasAcr = false;\r\n				} else {\r\n					wasAcr = true;\r\n				}\r\n			} catch(IndexOutOfBoundsException e) {\r\n				wasAcr = true;\r\n			}\r\n		} else {\r\n			// lf 000A\r\n			if (currentCharacter == \'\\n\') { //must merge eventual cr followed by lf\r\n				if (wasAcr && (lineEnds[linePtr] == (currentPosition - 2))) {\r\n					//System.out.println(\"merge LF-\" + (currentPosition - 1));							\r\n					lineEnds[linePtr] = currentPosition - 1;\r\n				} else {\r\n					int separatorPos = currentPosition - 1;\r\n					//TODO : (olivier) david - why the following line was \"if ((linePtr > 0) && (lineEnds[linePtr] >= separatorPos)) return;\" ?\r\n					if ((linePtr >= 0) && (lineEnds[linePtr] >= separatorPos)) return;\r\n					// System.out.println(\"LF-\" + separatorPos);							\r\n					try {\r\n						lineEnds[++linePtr] = separatorPos;\r\n					} catch (IndexOutOfBoundsException e) {\r\n						//linePtr value is correct\r\n						int oldLength = lineEnds.length;\r\n						int[] old = lineEnds;\r\n						lineEnds = new int[oldLength + INCREMENT];\r\n						System.arraycopy(old, 0, lineEnds, 0, oldLength);\r\n						lineEnds[linePtr] = separatorPos;\r\n					}\r\n				}\r\n				wasAcr = false;\r\n			}\r\n		}\r\n	}\r\n	public final void pushUnicodeLineSeparator() {\r\n		if (this.checkNonExternalizedStringLiterals) {\r\n			// reinitialize the current line for non externalize strings purpose\r\n			currentLine = null;\r\n		}\r\n		\r\n		// cr 000D\r\n		if (currentCharacter == \'\\r\') {\r\n			if (source[currentPosition] == \'\\n\') {\r\n				wasAcr = false;\r\n			} else {\r\n				wasAcr = true;\r\n			}\r\n		} else {\r\n			// lf 000A\r\n			if (currentCharacter == \'\\n\') { //must merge eventual cr followed by lf\r\n				wasAcr = false;\r\n			}\r\n		}\r\n	}\r\n	public final void recordComment(boolean isJavadoc) {\r\n\r\n		// a new annotation comment is recorded\r\n		try {\r\n			this.commentStops[++this.commentPtr] = isJavadoc ? this.currentPosition : -this.currentPosition;\r\n		} catch (IndexOutOfBoundsException e) {\r\n			int oldStackLength = this.commentStops.length;\r\n			int[] oldStack = this.commentStops;\r\n			this.commentStops = new int[oldStackLength + 30];\r\n			System.arraycopy(oldStack, 0, this.commentStops, 0, oldStackLength);\r\n			this.commentStops[this.commentPtr] = isJavadoc ? this.currentPosition : -this.currentPosition;\r\n			//grows the positions buffers too\r\n			int[] old = this.commentStarts;\r\n			this.commentStarts = new int[oldStackLength + 30];\r\n			System.arraycopy(old, 0, this.commentStarts, 0, oldStackLength);\r\n		}\r\n\r\n		//the buffer is of a correct size here\r\n		this.commentStarts[this.commentPtr] = this.startPosition;\r\n	}\r\n\r\n	public void resetTo(int begin, int end) {\r\n		//reset the scanner to a given position where it may rescan again\r\n\r\n		diet = false;\r\n		initialPosition = startPosition = currentPosition = begin;\r\n		eofPosition = end < Integer.MAX_VALUE ? end + 1 : end;\r\n		commentPtr = -1; // reset comment stack\r\n		foundTaskCount = 0;\r\n\r\n	}\r\n\r\n	public final void scanEscapeCharacter() throws InvalidInputException {\r\n		// the string with \"\\\\u\" is a legal string of two chars \\ and u\r\n		//thus we use a direct access to the source (for regular cases).\r\n\r\n		if (unicodeAsBackSlash) {\r\n			// consume next character\r\n			unicodeAsBackSlash = false;\r\n			if (((currentCharacter = source[currentPosition++]) == \'\\\\\') && (source[currentPosition] == \'u\')) {\r\n				getNextUnicodeChar();\r\n			} else {\r\n				if (withoutUnicodePtr != 0) {\r\n					withoutUnicodeBuffer[++withoutUnicodePtr] = currentCharacter;\r\n				}\r\n			}\r\n		} else\r\n		currentCharacter = source[currentPosition++];\r\n		switch (currentCharacter) {\r\n		case \'b\' :\r\n			currentCharacter = \'\\b\';\r\n			break;\r\n		case \'t\' :\r\n			currentCharacter = \'\\t\';\r\n			break;\r\n		case \'n\' :\r\n			currentCharacter = \'\\n\';\r\n			break;\r\n		case \'f\' :\r\n			currentCharacter = \'\\f\';\r\n			break;\r\n		case \'r\' :\r\n			currentCharacter = \'\\r\';\r\n			break;\r\n		case \'\\\"\' :\r\n			currentCharacter = \'\\\"\';\r\n			break;\r\n		case \'\\\'\' :\r\n			currentCharacter = \'\\\'\';\r\n			break;\r\n		case \'\\\\\' :\r\n			currentCharacter = \'\\\\\';\r\n			break;\r\n			default :\r\n			// -----------octal escape--------------\r\n			// OctalDigit\r\n			// OctalDigit OctalDigit\r\n			// ZeroToThree OctalDigit OctalDigit\r\n\r\n			int number = Character.getNumericValue(currentCharacter);\r\n			if (number >= 0 && number <= 7) {\r\n				boolean zeroToThreeNot = number > 3;\r\n				if (Character.isDigit(currentCharacter = source[currentPosition++])) {\r\n					int digit = Character.getNumericValue(currentCharacter);\r\n					if (digit >= 0 && digit <= 7) {\r\n						number = (number * 8) + digit;\r\n						if (Character.isDigit(currentCharacter = source[currentPosition++])) {\r\n							if (zeroToThreeNot) {// has read \\NotZeroToThree OctalDigit Digit --> ignore last character\r\n								currentPosition--;\r\n							} else {\r\n								digit = Character.getNumericValue(currentCharacter);\r\n								if (digit >= 0 && digit <= 7){ // has read \\ZeroToThree OctalDigit OctalDigit\r\n									number = (number * 8) + digit;\r\n								} else {// has read \\ZeroToThree OctalDigit NonOctalDigit --> ignore last character\r\n									currentPosition--;\r\n								}\r\n							}\r\n						} else { // has read \\OctalDigit NonDigit--> ignore last character\r\n							currentPosition--;\r\n						}\r\n					} else { // has read \\OctalDigit NonOctalDigit--> ignore last character						\r\n						currentPosition--;\r\n					}\r\n				} else { // has read \\OctalDigit --> ignore last character\r\n					currentPosition--;\r\n				}\r\n				if (number > 255)\r\n				throw new InvalidInputException(INVALID_ESCAPE);\r\n				currentCharacter = (char) number;\r\n			} else\r\n			throw new InvalidInputException(INVALID_ESCAPE);\r\n		}\r\n	}\r\n	public int scanIdentifierOrKeyword() throws InvalidInputException {\r\n		//test keywords\r\n\r\n		//first dispatch on the first char.\r\n		//then the length. If there are several\r\n		//keywors with the same length AND the same first char, then do another\r\n		//dispatch on the second char \r\n		useAssertAsAnIndentifier = false;\r\n		while (getNextCharAsJavaIdentifierPart());\r\n\r\n		int index, length;\r\n		char[] data;\r\n		char firstLetter;\r\n		if (withoutUnicodePtr == 0)\r\n\r\n		//quick test on length == 1 but not on length > 12 while most identifier\r\n		//have a length which is <= 12...but there are lots of identifier with\r\n		//only one char....\r\n\r\n		{\r\n			if ((length = currentPosition - startPosition) == 1)\r\n			return TokenNameIdentifier;\r\n			data = source;\r\n			index = startPosition;\r\n		} else {\r\n			if ((length = withoutUnicodePtr) == 1)\r\n			return TokenNameIdentifier;\r\n			data = withoutUnicodeBuffer;\r\n			index = 1;\r\n		}\r\n\r\n		firstLetter = data[index];\r\n		switch (firstLetter) {\r\n\r\n		case \'a\' : \r\n			switch(length) {\r\n			case 8: //abstract\r\n				if ((data[++index] == \'b\')\r\n						&& (data[++index] == \'s\')\r\n						&& (data[++index] == \'t\')\r\n						&& (data[++index] == \'r\')\r\n						&& (data[++index] == \'a\')\r\n						&& (data[++index] == \'c\')\r\n						&& (data[++index] == \'t\')) {\r\n					return TokenNameabstract;\r\n				} else {\r\n					return TokenNameIdentifier;\r\n				}\r\n			case 6: // assert\r\n				if ((data[++index] == \'s\')\r\n						&& (data[++index] == \'s\')\r\n						&& (data[++index] == \'e\')\r\n						&& (data[++index] == \'r\')\r\n						&& (data[++index] == \'t\')) {\r\n					if (assertMode) {\r\n						containsAssertKeyword = true;\r\n						return TokenNameassert;\r\n					} else {\r\n						useAssertAsAnIndentifier = true;\r\n						return TokenNameIdentifier;								\r\n					}\r\n				} else {\r\n					return TokenNameIdentifier;\r\n				}\r\n			default: \r\n				return TokenNameIdentifier;\r\n			}\r\n		case \'b\' : //boolean break byte\r\n			switch (length) {\r\n			case 4 :\r\n				if ((data[++index] == \'y\') && (data[++index] == \'t\') && (data[++index] == \'e\'))\r\n				return TokenNamebyte;\r\n				else\r\n				return TokenNameIdentifier;\r\n			case 5 :\r\n				if ((data[++index] == \'r\')\r\n						&& (data[++index] == \'e\')\r\n						&& (data[++index] == \'a\')\r\n						&& (data[++index] == \'k\'))\r\n				return TokenNamebreak;\r\n				else\r\n				return TokenNameIdentifier;\r\n			case 7 :\r\n				if ((data[++index] == \'o\')\r\n						&& (data[++index] == \'o\')\r\n						&& (data[++index] == \'l\')\r\n						&& (data[++index] == \'e\')\r\n						&& (data[++index] == \'a\')\r\n						&& (data[++index] == \'n\'))\r\n				return TokenNameboolean;\r\n				else\r\n				return TokenNameIdentifier;\r\n				default :\r\n				return TokenNameIdentifier;\r\n			}\r\n\r\n		case \'c\' : //case char catch const class continue\r\n			switch (length) {\r\n			case 4 :\r\n				if (data[++index] == \'a\')\r\n				if ((data[++index] == \'s\') && (data[++index] == \'e\'))\r\n				return TokenNamecase;\r\n				else\r\n				return TokenNameIdentifier;\r\n				else\r\n				if ((data[index] == \'h\') && (data[++index] == \'a\') && (data[++index] == \'r\'))\r\n				return TokenNamechar;\r\n				else\r\n				return TokenNameIdentifier;\r\n			case 5 :\r\n				if (data[++index] == \'a\')\r\n				if ((data[++index] == \'t\') && (data[++index] == \'c\') && (data[++index] == \'h\'))\r\n				return TokenNamecatch;\r\n				else\r\n				return TokenNameIdentifier;\r\n				else\r\n				if ((data[index] == \'l\')\r\n						&& (data[++index] == \'a\')\r\n						&& (data[++index] == \'s\')\r\n						&& (data[++index] == \'s\'))\r\n				return TokenNameclass;\r\n				else\r\n				if ((data[index] == \'o\')\r\n						&& (data[++index] == \'n\')\r\n						&& (data[++index] == \'s\')\r\n						&& (data[++index] == \'t\'))\r\n				return TokenNameERROR; //const is not used in java ???????\r\n				else\r\n				return TokenNameIdentifier;\r\n			case 8 :\r\n				if ((data[++index] == \'o\')\r\n						&& (data[++index] == \'n\')\r\n						&& (data[++index] == \'t\')\r\n						&& (data[++index] == \'i\')\r\n						&& (data[++index] == \'n\')\r\n						&& (data[++index] == \'u\')\r\n						&& (data[++index] == \'e\'))\r\n				return TokenNamecontinue;\r\n				else\r\n				return TokenNameIdentifier;\r\n				default :\r\n				return TokenNameIdentifier;\r\n			}\r\n\r\n		case \'d\' : //default do double\r\n			switch (length) {\r\n			case 2 :\r\n				if ((data[++index] == \'o\'))\r\n				return TokenNamedo;\r\n				else\r\n				return TokenNameIdentifier;\r\n			case 6 :\r\n				if ((data[++index] == \'o\')\r\n						&& (data[++index] == \'u\')\r\n						&& (data[++index] == \'b\')\r\n						&& (data[++index] == \'l\')\r\n						&& (data[++index] == \'e\'))\r\n				return TokenNamedouble;\r\n				else\r\n				return TokenNameIdentifier;\r\n			case 7 :\r\n				if ((data[++index] == \'e\')\r\n						&& (data[++index] == \'f\')\r\n						&& (data[++index] == \'a\')\r\n						&& (data[++index] == \'u\')\r\n						&& (data[++index] == \'l\')\r\n						&& (data[++index] == \'t\'))\r\n				return TokenNamedefault;\r\n				else\r\n				return TokenNameIdentifier;\r\n				default :\r\n				return TokenNameIdentifier;\r\n			}\r\n		case \'e\' : //else extends\r\n			switch (length) {\r\n			case 4 :\r\n				if ((data[++index] == \'l\') && (data[++index] == \'s\') && (data[++index] == \'e\'))\r\n				return TokenNameelse;\r\n				else\r\n				return TokenNameIdentifier;\r\n			case 7 :\r\n				if ((data[++index] == \'x\')\r\n						&& (data[++index] == \'t\')\r\n						&& (data[++index] == \'e\')\r\n						&& (data[++index] == \'n\')\r\n						&& (data[++index] == \'d\')\r\n						&& (data[++index] == \'s\'))\r\n				return TokenNameextends;\r\n				else\r\n				return TokenNameIdentifier;\r\n				default :\r\n				return TokenNameIdentifier;\r\n			}\r\n\r\n		case \'f\' : //final finally float for false\r\n			switch (length) {\r\n			case 3 :\r\n				if ((data[++index] == \'o\') && (data[++index] == \'r\'))\r\n				return TokenNamefor;\r\n				else\r\n				return TokenNameIdentifier;\r\n			case 5 :\r\n				if (data[++index] == \'i\')\r\n				if ((data[++index] == \'n\')\r\n						&& (data[++index] == \'a\')\r\n						&& (data[++index] == \'l\')) {\r\n					return TokenNamefinal;\r\n				} else\r\n				return TokenNameIdentifier;\r\n				else\r\n				if ((data[index] == \'l\')\r\n						&& (data[++index] == \'o\')\r\n						&& (data[++index] == \'a\')\r\n						&& (data[++index] == \'t\'))\r\n				return TokenNamefloat;\r\n				else\r\n				if ((data[index] == \'a\')\r\n						&& (data[++index] == \'l\')\r\n						&& (data[++index] == \'s\')\r\n						&& (data[++index] == \'e\'))\r\n				return TokenNamefalse;\r\n				else\r\n				return TokenNameIdentifier;\r\n			case 7 :\r\n				if ((data[++index] == \'i\')\r\n						&& (data[++index] == \'n\')\r\n						&& (data[++index] == \'a\')\r\n						&& (data[++index] == \'l\')\r\n						&& (data[++index] == \'l\')\r\n						&& (data[++index] == \'y\'))\r\n				return TokenNamefinally;\r\n				else\r\n				return TokenNameIdentifier;\r\n\r\n				default :\r\n				return TokenNameIdentifier;\r\n			}\r\n		case \'g\' : //goto\r\n			if (length == 4) {\r\n				if ((data[++index] == \'o\')\r\n						&& (data[++index] == \'t\')\r\n						&& (data[++index] == \'o\')) {\r\n					return TokenNameERROR;\r\n				}\r\n			} //no goto in java are allowed, so why java removes this keyword ???\r\n			return TokenNameIdentifier;\r\n\r\n		case \'i\' : //if implements import instanceof int interface\r\n			switch (length) {\r\n			case 2 :\r\n				if (data[++index] == \'f\')\r\n				return TokenNameif;\r\n				else\r\n				return TokenNameIdentifier;\r\n			case 3 :\r\n				if ((data[++index] == \'n\') && (data[++index] == \'t\'))\r\n				return TokenNameint;\r\n				else\r\n				return TokenNameIdentifier;\r\n			case 6 :\r\n				if ((data[++index] == \'m\')\r\n						&& (data[++index] == \'p\')\r\n						&& (data[++index] == \'o\')\r\n						&& (data[++index] == \'r\')\r\n						&& (data[++index] == \'t\'))\r\n				return TokenNameimport;\r\n				else\r\n				return TokenNameIdentifier;\r\n			case 9 :\r\n				if ((data[++index] == \'n\')\r\n						&& (data[++index] == \'t\')\r\n						&& (data[++index] == \'e\')\r\n						&& (data[++index] == \'r\')\r\n						&& (data[++index] == \'f\')\r\n						&& (data[++index] == \'a\')\r\n						&& (data[++index] == \'c\')\r\n						&& (data[++index] == \'e\'))\r\n				return TokenNameinterface;\r\n				else\r\n				return TokenNameIdentifier;\r\n			case 10 :\r\n				if (data[++index] == \'m\')\r\n				if ((data[++index] == \'p\')\r\n						&& (data[++index] == \'l\')\r\n						&& (data[++index] == \'e\')\r\n						&& (data[++index] == \'m\')\r\n						&& (data[++index] == \'e\')\r\n						&& (data[++index] == \'n\')\r\n						&& (data[++index] == \'t\')\r\n						&& (data[++index] == \'s\'))\r\n				return TokenNameimplements;\r\n				else\r\n				return TokenNameIdentifier;\r\n				else\r\n				if ((data[index] == \'n\')\r\n						&& (data[++index] == \'s\')\r\n						&& (data[++index] == \'t\')\r\n						&& (data[++index] == \'a\')\r\n						&& (data[++index] == \'n\')\r\n						&& (data[++index] == \'c\')\r\n						&& (data[++index] == \'e\')\r\n						&& (data[++index] == \'o\')\r\n						&& (data[++index] == \'f\'))\r\n				return TokenNameinstanceof;\r\n				else\r\n				return TokenNameIdentifier;\r\n\r\n				default :\r\n				return TokenNameIdentifier;\r\n			}\r\n\r\n		case \'l\' : //long\r\n			if (length == 4) {\r\n				if ((data[++index] == \'o\')\r\n						&& (data[++index] == \'n\')\r\n						&& (data[++index] == \'g\')) {\r\n					return TokenNamelong;\r\n				}\r\n			}\r\n			return TokenNameIdentifier;\r\n\r\n		case \'n\' : //native new null\r\n			switch (length) {\r\n			case 3 :\r\n				if ((data[++index] == \'e\') && (data[++index] == \'w\'))\r\n				return TokenNamenew;\r\n				else\r\n				return TokenNameIdentifier;\r\n			case 4 :\r\n				if ((data[++index] == \'u\') && (data[++index] == \'l\') && (data[++index] == \'l\'))\r\n				return TokenNamenull;\r\n				else\r\n				return TokenNameIdentifier;\r\n			case 6 :\r\n				if ((data[++index] == \'a\')\r\n						&& (data[++index] == \'t\')\r\n						&& (data[++index] == \'i\')\r\n						&& (data[++index] == \'v\')\r\n						&& (data[++index] == \'e\')) {\r\n					return TokenNamenative;\r\n				} else\r\n				return TokenNameIdentifier;\r\n				default :\r\n				return TokenNameIdentifier;\r\n			}\r\n\r\n		case \'p\' : //package private protected public\r\n			switch (length) {\r\n			case 6 :\r\n				if ((data[++index] == \'u\')\r\n						&& (data[++index] == \'b\')\r\n						&& (data[++index] == \'l\')\r\n						&& (data[++index] == \'i\')\r\n						&& (data[++index] == \'c\')) {\r\n					return TokenNamepublic;\r\n				} else\r\n				return TokenNameIdentifier;\r\n			case 7 :\r\n				if (data[++index] == \'a\')\r\n				if ((data[++index] == \'c\')\r\n						&& (data[++index] == \'k\')\r\n						&& (data[++index] == \'a\')\r\n						&& (data[++index] == \'g\')\r\n						&& (data[++index] == \'e\'))\r\n				return TokenNamepackage;\r\n				else\r\n				return TokenNameIdentifier;\r\n				else\r\n				if ((data[index] == \'r\')\r\n						&& (data[++index] == \'i\')\r\n						&& (data[++index] == \'v\')\r\n						&& (data[++index] == \'a\')\r\n						&& (data[++index] == \'t\')\r\n						&& (data[++index] == \'e\')) {\r\n					return TokenNameprivate;\r\n				} else\r\n				return TokenNameIdentifier;\r\n			case 9 :\r\n				if ((data[++index] == \'r\')\r\n						&& (data[++index] == \'o\')\r\n						&& (data[++index] == \'t\')\r\n						&& (data[++index] == \'e\')\r\n						&& (data[++index] == \'c\')\r\n						&& (data[++index] == \'t\')\r\n						&& (data[++index] == \'e\')\r\n						&& (data[++index] == \'d\')) {\r\n					return TokenNameprotected;\r\n				} else\r\n				return TokenNameIdentifier;\r\n\r\n				default :\r\n				return TokenNameIdentifier;\r\n			}\r\n\r\n		case \'r\' : //return\r\n			if (length == 6) {\r\n				if ((data[++index] == \'e\')\r\n						&& (data[++index] == \'t\')\r\n						&& (data[++index] == \'u\')\r\n						&& (data[++index] == \'r\')\r\n						&& (data[++index] == \'n\')) {\r\n					return TokenNamereturn;\r\n				}\r\n			}\r\n			return TokenNameIdentifier;\r\n\r\n		case \'s\' : //short static super switch synchronized strictfp\r\n			switch (length) {\r\n			case 5 :\r\n				if (data[++index] == \'h\')\r\n				if ((data[++index] == \'o\') && (data[++index] == \'r\') && (data[++index] == \'t\'))\r\n				return TokenNameshort;\r\n				else\r\n				return TokenNameIdentifier;\r\n				else\r\n				if ((data[index] == \'u\')\r\n						&& (data[++index] == \'p\')\r\n						&& (data[++index] == \'e\')\r\n						&& (data[++index] == \'r\'))\r\n				return TokenNamesuper;\r\n				else\r\n				return TokenNameIdentifier;\r\n\r\n			case 6 :\r\n				if (data[++index] == \'t\')\r\n				if ((data[++index] == \'a\')\r\n						&& (data[++index] == \'t\')\r\n						&& (data[++index] == \'i\')\r\n						&& (data[++index] == \'c\')) {\r\n					return TokenNamestatic;\r\n				} else\r\n				return TokenNameIdentifier;\r\n				else\r\n				if ((data[index] == \'w\')\r\n						&& (data[++index] == \'i\')\r\n						&& (data[++index] == \'t\')\r\n						&& (data[++index] == \'c\')\r\n						&& (data[++index] == \'h\'))\r\n				return TokenNameswitch;\r\n				else\r\n				return TokenNameIdentifier;\r\n			case 8 :\r\n				if ((data[++index] == \'t\')\r\n						&& (data[++index] == \'r\')\r\n						&& (data[++index] == \'i\')\r\n						&& (data[++index] == \'c\')\r\n						&& (data[++index] == \'t\')\r\n						&& (data[++index] == \'f\')\r\n						&& (data[++index] == \'p\'))\r\n				return TokenNamestrictfp;\r\n				else\r\n				return TokenNameIdentifier;\r\n			case 12 :\r\n				if ((data[++index] == \'y\')\r\n						&& (data[++index] == \'n\')\r\n						&& (data[++index] == \'c\')\r\n						&& (data[++index] == \'h\')\r\n						&& (data[++index] == \'r\')\r\n						&& (data[++index] == \'o\')\r\n						&& (data[++index] == \'n\')\r\n						&& (data[++index] == \'i\')\r\n						&& (data[++index] == \'z\')\r\n						&& (data[++index] == \'e\')\r\n						&& (data[++index] == \'d\')) {\r\n					return TokenNamesynchronized;\r\n				} else\r\n				return TokenNameIdentifier;\r\n				default :\r\n				return TokenNameIdentifier;\r\n			}\r\n\r\n		case \'t\' : //try throw throws transient this true\r\n			switch (length) {\r\n			case 3 :\r\n				if ((data[++index] == \'r\') && (data[++index] == \'y\'))\r\n				return TokenNametry;\r\n				else\r\n				return TokenNameIdentifier;\r\n			case 4 :\r\n				if ((data[++index] == \'h\') && (data[++index] == \'i\') && (data[++index] == \'s\'))\r\n				return TokenNamethis;\r\n				else\r\n				if ((data[index] == \'r\') && (data[++index] == \'u\') && (data[++index] == \'e\'))\r\n				return TokenNametrue;\r\n				else\r\n				return TokenNameIdentifier;\r\n			case 5 :\r\n				if ((data[++index] == \'h\')\r\n						&& (data[++index] == \'r\')\r\n						&& (data[++index] == \'o\')\r\n						&& (data[++index] == \'w\'))\r\n				return TokenNamethrow;\r\n				else\r\n				return TokenNameIdentifier;\r\n			case 6 :\r\n				if ((data[++index] == \'h\')\r\n						&& (data[++index] == \'r\')\r\n						&& (data[++index] == \'o\')\r\n						&& (data[++index] == \'w\')\r\n						&& (data[++index] == \'s\'))\r\n				return TokenNamethrows;\r\n				else\r\n				return TokenNameIdentifier;\r\n			case 9 :\r\n				if ((data[++index] == \'r\')\r\n						&& (data[++index] == \'a\')\r\n						&& (data[++index] == \'n\')\r\n						&& (data[++index] == \'s\')\r\n						&& (data[++index] == \'i\')\r\n						&& (data[++index] == \'e\')\r\n						&& (data[++index] == \'n\')\r\n						&& (data[++index] == \'t\')) {\r\n					return TokenNametransient;\r\n				} else\r\n				return TokenNameIdentifier;\r\n\r\n				default :\r\n				return TokenNameIdentifier;\r\n			}\r\n\r\n		case \'v\' : //void volatile\r\n			switch (length) {\r\n			case 4 :\r\n				if ((data[++index] == \'o\') && (data[++index] == \'i\') && (data[++index] == \'d\'))\r\n				return TokenNamevoid;\r\n				else\r\n				return TokenNameIdentifier;\r\n			case 8 :\r\n				if ((data[++index] == \'o\')\r\n						&& (data[++index] == \'l\')\r\n						&& (data[++index] == \'a\')\r\n						&& (data[++index] == \'t\')\r\n						&& (data[++index] == \'i\')\r\n						&& (data[++index] == \'l\')\r\n						&& (data[++index] == \'e\')) {\r\n					return TokenNamevolatile;\r\n				} else\r\n				return TokenNameIdentifier;\r\n\r\n				default :\r\n				return TokenNameIdentifier;\r\n			}\r\n\r\n		case \'w\' : //while widefp\r\n			switch (length) {\r\n			case 5 :\r\n				if ((data[++index] == \'h\')\r\n						&& (data[++index] == \'i\')\r\n						&& (data[++index] == \'l\')\r\n						&& (data[++index] == \'e\'))\r\n				return TokenNamewhile;\r\n				else\r\n				return TokenNameIdentifier;\r\n				//case 6:if ( (data[++index] ==\'i\') && (data[++index]==\'d\') && (data[++index]==\'e\') && (data[++index]==\'f\')&& (data[++index]==\'p\'))\r\n				//return TokenNamewidefp ;\r\n				//else\r\n				//return TokenNameIdentifier;\r\n				default :\r\n				return TokenNameIdentifier;\r\n			}\r\n\r\n			default :\r\n			return TokenNameIdentifier;\r\n		}\r\n	}\r\n	public int scanNumber(boolean dotPrefix) throws InvalidInputException {\r\n\r\n		//when entering this method the currentCharacter is the first\r\n		//digit of the number. It may be preceeded by a \'.\' when\r\n		//dotPrefix is true\r\n\r\n		boolean floating = dotPrefix;\r\n		if ((!dotPrefix) && (currentCharacter == \'0\')) {\r\n			if (getNextChar(\'x\', \'X\') >= 0) { //----------hexa-----------------\r\n				//force the first char of the hexa number do exist...\r\n				// consume next character\r\n				unicodeAsBackSlash = false;\r\n				if (((currentCharacter = source[currentPosition++]) == \'\\\\\')\r\n						&& (source[currentPosition] == \'u\')) {\r\n					getNextUnicodeChar();\r\n				} else {\r\n					if (withoutUnicodePtr != 0) {\r\n						withoutUnicodeBuffer[++withoutUnicodePtr] = currentCharacter;\r\n					}\r\n				}\r\n				if (Character.digit(currentCharacter, 16) == -1)\r\n				throw new InvalidInputException(INVALID_HEXA);\r\n				//---end forcing--\r\n				while (getNextCharAsDigit(16));\r\n				if (getNextChar(\'l\', \'L\') >= 0)\r\n				return TokenNameLongLiteral;\r\n				else\r\n				return TokenNameIntegerLiteral;\r\n			}\r\n\r\n			//there is x or X in the number\r\n			//potential octal ! ... some one may write 000099.0 ! thus 00100 < 00078.0 is true !!!!! crazy language\r\n			if (getNextCharAsDigit()) { //-------------potential octal-----------------\r\n				while (getNextCharAsDigit());\r\n\r\n				if (getNextChar(\'l\', \'L\') >= 0) {\r\n					return TokenNameLongLiteral;\r\n				}\r\n\r\n				if (getNextChar(\'f\', \'F\') >= 0) {\r\n					return TokenNameFloatingPointLiteral;\r\n				}\r\n\r\n				if (getNextChar(\'d\', \'D\') >= 0) {\r\n					return TokenNameDoubleLiteral;\r\n				} else { //make the distinction between octal and float ....\r\n					boolean isInteger = true;\r\n					if (getNextChar(\'.\')) { \r\n						isInteger = false;\r\n						while (getNextCharAsDigit());\r\n					}\r\n					if (getNextChar(\'e\', \'E\') >= 0) { // consume next character\r\n						isInteger = false;\r\n						unicodeAsBackSlash = false;\r\n						if (((currentCharacter = source[currentPosition++]) == \'\\\\\')\r\n								&& (source[currentPosition] == \'u\')) {\r\n							getNextUnicodeChar();\r\n						} else {\r\n							if (withoutUnicodePtr != 0) {\r\n								withoutUnicodeBuffer[++withoutUnicodePtr] = currentCharacter;\r\n							}\r\n						}\r\n\r\n						if ((currentCharacter == \'-\')\r\n								|| (currentCharacter == \'+\')) { // consume next character\r\n							unicodeAsBackSlash = false;\r\n							if (((currentCharacter = source[currentPosition++]) == \'\\\\\')\r\n									&& (source[currentPosition] == \'u\')) {\r\n								getNextUnicodeChar();\r\n							} else {\r\n								if (withoutUnicodePtr != 0) {\r\n									withoutUnicodeBuffer[++withoutUnicodePtr] = currentCharacter;\r\n								}\r\n							}\r\n						}\r\n						if (!Character.isDigit(currentCharacter))\r\n						throw new InvalidInputException(INVALID_FLOAT);\r\n						while (getNextCharAsDigit());\r\n					}\r\n					if (getNextChar(\'f\', \'F\') >= 0)\r\n					return TokenNameFloatingPointLiteral;\r\n					if (getNextChar(\'d\', \'D\') >= 0 || !isInteger)\r\n					return TokenNameDoubleLiteral;\r\n					return TokenNameIntegerLiteral;\r\n				}\r\n			} else {\r\n				/* carry on */\r\n			}\r\n		}\r\n\r\n		while (getNextCharAsDigit());\r\n\r\n		if ((!dotPrefix) && (getNextChar(\'l\', \'L\') >= 0))\r\n		return TokenNameLongLiteral;\r\n\r\n		if ((!dotPrefix) && (getNextChar(\'.\'))) { //decimal part that can be empty\r\n			while (getNextCharAsDigit());\r\n			floating = true;\r\n		}\r\n\r\n		//if floating is true both exponant and suffix may be optional\r\n\r\n		if (getNextChar(\'e\', \'E\') >= 0) {\r\n			floating = true;\r\n			// consume next character\r\n			unicodeAsBackSlash = false;\r\n			if (((currentCharacter = source[currentPosition++]) == \'\\\\\')\r\n					&& (source[currentPosition] == \'u\')) {\r\n				getNextUnicodeChar();\r\n			} else {\r\n				if (withoutUnicodePtr != 0) {\r\n					withoutUnicodeBuffer[++withoutUnicodePtr] = currentCharacter;\r\n				}\r\n			}\r\n\r\n			if ((currentCharacter == \'-\')\r\n					|| (currentCharacter == \'+\')) { // consume next character\r\n				unicodeAsBackSlash = false;\r\n				if (((currentCharacter = source[currentPosition++]) == \'\\\\\')\r\n						&& (source[currentPosition] == \'u\')) {\r\n					getNextUnicodeChar();\r\n				} else {\r\n					if (withoutUnicodePtr != 0) {\r\n						withoutUnicodeBuffer[++withoutUnicodePtr] = currentCharacter;\r\n					}\r\n				}\r\n			}\r\n			if (!Character.isDigit(currentCharacter))\r\n			throw new InvalidInputException(INVALID_FLOAT);\r\n			while (getNextCharAsDigit());\r\n		}\r\n\r\n		if (getNextChar(\'d\', \'D\') >= 0)\r\n		return TokenNameDoubleLiteral;\r\n		if (getNextChar(\'f\', \'F\') >= 0)\r\n		return TokenNameFloatingPointLiteral;\r\n\r\n		//the long flag has been tested before\r\n\r\n		return floating ? TokenNameDoubleLiteral : TokenNameIntegerLiteral;\r\n	}\r\n	/**\r\n* Search the line number corresponding to a specific position\r\n*\r\n*/\r\n	public final int getLineNumber(int position) {\r\n\r\n		if (lineEnds == null)\r\n		return 1;\r\n		int length = linePtr+1;\r\n		if (length == 0)\r\n		return 1;\r\n		int g = 0, d = length - 1;\r\n		int m = 0;\r\n		while (g <= d) {\r\n			m = (g + d) /2;\r\n			if (position < lineEnds[m]) {\r\n				d = m-1;\r\n			} else if (position > lineEnds[m]) {\r\n				g = m+1;\r\n			} else {\r\n				return m + 1;\r\n			}\r\n		}\r\n		if (position < lineEnds[m]) {\r\n			return m+1;\r\n		}\r\n		return m+2;\r\n	}\r\n	public final void setSource(char[] source){\r\n		//the source-buffer is set to sourceString\r\n\r\n		if (source == null) {\r\n			this.source = CharOperation.NO_CHAR;\r\n		} else {\r\n			this.source = source;\r\n		}\r\n		startPosition = -1;\r\n		eofPosition = source.length;\r\n		initialPosition = currentPosition = 0;\r\n		containsAssertKeyword = false;\r\n		withoutUnicodeBuffer = new char[this.source.length];\r\n\r\n	}\r\n\r\n	public String toString() {\r\n		if (startPosition == source.length)\r\n		return \"EOF\\n\\n\" + new String(source); //$NON-NLS-1$\r\n		if (currentPosition > source.length)\r\n		return \"behind the EOF :-( ....\\n\\n\" + new String(source); //$NON-NLS-1$\r\n\r\n		char front[] = new char[startPosition];\r\n		System.arraycopy(source, 0, front, 0, startPosition);\r\n\r\n		int middleLength = (currentPosition - 1) - startPosition + 1;\r\n		char middle[];\r\n		if (middleLength > -1) {\r\n			middle = new char[middleLength];\r\n			System.arraycopy(\r\n			source, \r\n			startPosition, \r\n			middle, \r\n			0, \r\n			middleLength);\r\n		} else {\r\n			middle = CharOperation.NO_CHAR;\r\n		}\r\n		\r\n		char end[] = new char[source.length - (currentPosition - 1)];\r\n		System.arraycopy(\r\n		source, \r\n		(currentPosition - 1) + 1, \r\n		end, \r\n		0, \r\n		source.length - (currentPosition - 1) - 1);\r\n		\r\n		return new String(front)\r\n		+ \"\\n===============================\\nStarts here -->\" //$NON-NLS-1$\r\n		+ new String(middle)\r\n		+ \"<-- Ends here\\n===============================\\n\" //$NON-NLS-1$\r\n		+ new String(end); \r\n	}\r\n	public final String toStringAction(int act) {\r\n		switch (act) {\r\n		case TokenNameIdentifier :\r\n			return \"Identifier(\" + new String(getCurrentTokenSource()) + \")\"; //$NON-NLS-1$ //$NON-NLS-2$\r\n		case TokenNameabstract :\r\n			return \"abstract\"; //$NON-NLS-1$\r\n		case TokenNameboolean :\r\n			return \"boolean\"; //$NON-NLS-1$\r\n		case TokenNamebreak :\r\n			return \"break\"; //$NON-NLS-1$\r\n		case TokenNamebyte :\r\n			return \"byte\"; //$NON-NLS-1$\r\n		case TokenNamecase :\r\n			return \"case\"; //$NON-NLS-1$\r\n		case TokenNamecatch :\r\n			return \"catch\"; //$NON-NLS-1$\r\n		case TokenNamechar :\r\n			return \"char\"; //$NON-NLS-1$\r\n		case TokenNameclass :\r\n			return \"class\"; //$NON-NLS-1$\r\n		case TokenNamecontinue :\r\n			return \"continue\"; //$NON-NLS-1$\r\n		case TokenNamedefault :\r\n			return \"default\"; //$NON-NLS-1$\r\n		case TokenNamedo :\r\n			return \"do\"; //$NON-NLS-1$\r\n		case TokenNamedouble :\r\n			return \"double\"; //$NON-NLS-1$\r\n		case TokenNameelse :\r\n			return \"else\"; //$NON-NLS-1$\r\n		case TokenNameextends :\r\n			return \"extends\"; //$NON-NLS-1$\r\n		case TokenNamefalse :\r\n			return \"false\"; //$NON-NLS-1$\r\n		case TokenNamefinal :\r\n			return \"final\"; //$NON-NLS-1$\r\n		case TokenNamefinally :\r\n			return \"finally\"; //$NON-NLS-1$\r\n		case TokenNamefloat :\r\n			return \"float\"; //$NON-NLS-1$\r\n		case TokenNamefor :\r\n			return \"for\"; //$NON-NLS-1$\r\n		case TokenNameif :\r\n			return \"if\"; //$NON-NLS-1$\r\n		case TokenNameimplements :\r\n			return \"implements\"; //$NON-NLS-1$\r\n		case TokenNameimport :\r\n			return \"import\"; //$NON-NLS-1$\r\n		case TokenNameinstanceof :\r\n			return \"instanceof\"; //$NON-NLS-1$\r\n		case TokenNameint :\r\n			return \"int\"; //$NON-NLS-1$\r\n		case TokenNameinterface :\r\n			return \"interface\"; //$NON-NLS-1$\r\n		case TokenNamelong :\r\n			return \"long\"; //$NON-NLS-1$\r\n		case TokenNamenative :\r\n			return \"native\"; //$NON-NLS-1$\r\n		case TokenNamenew :\r\n			return \"new\"; //$NON-NLS-1$\r\n		case TokenNamenull :\r\n			return \"null\"; //$NON-NLS-1$\r\n		case TokenNamepackage :\r\n			return \"package\"; //$NON-NLS-1$\r\n		case TokenNameprivate :\r\n			return \"private\"; //$NON-NLS-1$\r\n		case TokenNameprotected :\r\n			return \"protected\"; //$NON-NLS-1$\r\n		case TokenNamepublic :\r\n			return \"public\"; //$NON-NLS-1$\r\n		case TokenNamereturn :\r\n			return \"return\"; //$NON-NLS-1$\r\n		case TokenNameshort :\r\n			return \"short\"; //$NON-NLS-1$\r\n		case TokenNamestatic :\r\n			return \"static\"; //$NON-NLS-1$\r\n		case TokenNamesuper :\r\n			return \"super\"; //$NON-NLS-1$\r\n		case TokenNameswitch :\r\n			return \"switch\"; //$NON-NLS-1$\r\n		case TokenNamesynchronized :\r\n			return \"synchronized\"; //$NON-NLS-1$\r\n		case TokenNamethis :\r\n			return \"this\"; //$NON-NLS-1$\r\n		case TokenNamethrow :\r\n			return \"throw\"; //$NON-NLS-1$\r\n		case TokenNamethrows :\r\n			return \"throws\"; //$NON-NLS-1$\r\n		case TokenNametransient :\r\n			return \"transient\"; //$NON-NLS-1$\r\n		case TokenNametrue :\r\n			return \"true\"; //$NON-NLS-1$\r\n		case TokenNametry :\r\n			return \"try\"; //$NON-NLS-1$\r\n		case TokenNamevoid :\r\n			return \"void\"; //$NON-NLS-1$\r\n		case TokenNamevolatile :\r\n			return \"volatile\"; //$NON-NLS-1$\r\n		case TokenNamewhile :\r\n			return \"while\"; //$NON-NLS-1$\r\n\r\n		case TokenNameIntegerLiteral :\r\n			return \"Integer(\" + new String(getCurrentTokenSource()) + \")\"; //$NON-NLS-1$ //$NON-NLS-2$\r\n		case TokenNameLongLiteral :\r\n			return \"Long(\" + new String(getCurrentTokenSource()) + \")\"; //$NON-NLS-1$ //$NON-NLS-2$\r\n		case TokenNameFloatingPointLiteral :\r\n			return \"Float(\" + new String(getCurrentTokenSource()) + \")\"; //$NON-NLS-1$ //$NON-NLS-2$\r\n		case TokenNameDoubleLiteral :\r\n			return \"Double(\" + new String(getCurrentTokenSource()) + \")\"; //$NON-NLS-1$ //$NON-NLS-2$\r\n		case TokenNameCharacterLiteral :\r\n			return \"Char(\" + new String(getCurrentTokenSource()) + \")\"; //$NON-NLS-1$ //$NON-NLS-2$\r\n		case TokenNameStringLiteral :\r\n			return \"String(\" + new String(getCurrentTokenSource()) + \")\"; //$NON-NLS-1$ //$NON-NLS-2$\r\n\r\n		case TokenNamePLUS_PLUS :\r\n			return \"++\"; //$NON-NLS-1$\r\n		case TokenNameMINUS_MINUS :\r\n			return \"--\"; //$NON-NLS-1$\r\n		case TokenNameEQUAL_EQUAL :\r\n			return \"==\"; //$NON-NLS-1$\r\n		case TokenNameLESS_EQUAL :\r\n			return \"<=\"; //$NON-NLS-1$\r\n		case TokenNameGREATER_EQUAL :\r\n			return \">=\"; //$NON-NLS-1$\r\n		case TokenNameNOT_EQUAL :\r\n			return \"!=\"; //$NON-NLS-1$\r\n		case TokenNameLEFT_SHIFT :\r\n			return \"<<\"; //$NON-NLS-1$\r\n		case TokenNameRIGHT_SHIFT :\r\n			return \">>\"; //$NON-NLS-1$\r\n		case TokenNameUNSIGNED_RIGHT_SHIFT :\r\n			return \">>>\"; //$NON-NLS-1$\r\n		case TokenNamePLUS_EQUAL :\r\n			return \"+=\"; //$NON-NLS-1$\r\n		case TokenNameMINUS_EQUAL :\r\n			return \"-=\"; //$NON-NLS-1$\r\n		case TokenNameMULTIPLY_EQUAL :\r\n			return \"*=\"; //$NON-NLS-1$\r\n		case TokenNameDIVIDE_EQUAL :\r\n			return \"/=\"; //$NON-NLS-1$\r\n		case TokenNameAND_EQUAL :\r\n			return \"&=\"; //$NON-NLS-1$\r\n		case TokenNameOR_EQUAL :\r\n			return \"|=\"; //$NON-NLS-1$\r\n		case TokenNameXOR_EQUAL :\r\n			return \"^=\"; //$NON-NLS-1$\r\n		case TokenNameREMAINDER_EQUAL :\r\n			return \"%=\"; //$NON-NLS-1$\r\n		case TokenNameLEFT_SHIFT_EQUAL :\r\n			return \"<<=\"; //$NON-NLS-1$\r\n		case TokenNameRIGHT_SHIFT_EQUAL :\r\n			return \">>=\"; //$NON-NLS-1$\r\n		case TokenNameUNSIGNED_RIGHT_SHIFT_EQUAL :\r\n			return \">>>=\"; //$NON-NLS-1$\r\n		case TokenNameOR_OR :\r\n			return \"||\"; //$NON-NLS-1$\r\n		case TokenNameAND_AND :\r\n			return \"&&\"; //$NON-NLS-1$\r\n		case TokenNamePLUS :\r\n			return \"+\"; //$NON-NLS-1$\r\n		case TokenNameMINUS :\r\n			return \"-\"; //$NON-NLS-1$\r\n		case TokenNameNOT :\r\n			return \"!\"; //$NON-NLS-1$\r\n		case TokenNameREMAINDER :\r\n			return \"%\"; //$NON-NLS-1$\r\n		case TokenNameXOR :\r\n			return \"^\"; //$NON-NLS-1$\r\n		case TokenNameAND :\r\n			return \"&\"; //$NON-NLS-1$\r\n		case TokenNameMULTIPLY :\r\n			return \"*\"; //$NON-NLS-1$\r\n		case TokenNameOR :\r\n			return \"|\"; //$NON-NLS-1$\r\n		case TokenNameTWIDDLE :\r\n			return \"~\"; //$NON-NLS-1$\r\n		case TokenNameDIVIDE :\r\n			return \"/\"; //$NON-NLS-1$\r\n		case TokenNameGREATER :\r\n			return \">\"; //$NON-NLS-1$\r\n		case TokenNameLESS :\r\n			return \"<\"; //$NON-NLS-1$\r\n		case TokenNameLPAREN :\r\n			return \"(\"; //$NON-NLS-1$\r\n		case TokenNameRPAREN :\r\n			return \")\"; //$NON-NLS-1$\r\n		case TokenNameLBRACE :\r\n			return \"{\"; //$NON-NLS-1$\r\n		case TokenNameRBRACE :\r\n			return \"}\"; //$NON-NLS-1$\r\n		case TokenNameLBRACKET :\r\n			return \"[\"; //$NON-NLS-1$\r\n		case TokenNameRBRACKET :\r\n			return \"]\"; //$NON-NLS-1$\r\n		case TokenNameSEMICOLON :\r\n			return \";\"; //$NON-NLS-1$\r\n		case TokenNameQUESTION :\r\n			return \"?\"; //$NON-NLS-1$\r\n		case TokenNameCOLON :\r\n			return \":\"; //$NON-NLS-1$\r\n		case TokenNameCOMMA :\r\n			return \",\"; //$NON-NLS-1$\r\n		case TokenNameDOT :\r\n			return \".\"; //$NON-NLS-1$\r\n		case TokenNameEQUAL :\r\n			return \"=\"; //$NON-NLS-1$\r\n		case TokenNameEOF :\r\n			return \"EOF\"; //$NON-NLS-1$\r\n			default :\r\n			return \"not-a-token\"; //$NON-NLS-1$\r\n		}\r\n	}\r\n}','Public Class','eclipse.jdt.core','org.eclipse.jdt.internal.core.util.PublicScanner',2,7,0),(9,'C','cdsbp','/**\r\n* Licensed to the Apache Software Foundation (ASF) under one or more\r\n* contributor license agreements.  See the NOTICE file distributed with\r\n* this work for additional information regarding copyright ownership.\r\n* The ASF licenses this file to You under the Apache License, Version 2.0\r\n* (the \"License\"); you may not use this file except in compliance with\r\n* the License.  You may obtain a copy of the License at\r\n*\r\n*     http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing, software\r\n* distributed under the License is distributed on an \"AS IS\" BASIS,\r\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n* See the License for the specific language governing permissions and\r\n* limitations under the License.\r\n*/\r\n\r\npackage org.apache.nutch.crawl;\r\n\r\nimport java.io.*;\r\nimport java.text.SimpleDateFormat;\r\nimport java.util.*;\r\n\r\n// Commons Logging imports\r\nimport org.slf4j.Logger;\r\nimport org.slf4j.LoggerFactory;\r\n\r\nimport org.apache.hadoop.io.*;\r\nimport org.apache.hadoop.fs.*;\r\nimport org.apache.hadoop.conf.*;\r\nimport org.apache.hadoop.mapred.*;\r\nimport org.apache.hadoop.util.*;\r\n\r\nimport org.apache.nutch.util.HadoopFSUtil;\r\nimport org.apache.nutch.util.LockUtil;\r\nimport org.apache.nutch.util.NutchConfiguration;\r\nimport org.apache.nutch.util.NutchJob;\r\nimport org.apache.nutch.util.TimingUtil;\r\n\r\n/**\r\n* This class takes the output of the fetcher and updates the\r\n* crawldb accordingly.\r\n*/\r\npublic class CrawlDb extends Configured implements Tool {\r\n	public static final Logger LOG = LoggerFactory.getLogger(CrawlDb.class);\r\n\r\n	public static final String CRAWLDB_ADDITIONS_ALLOWED = \"db.update.additions.allowed\";\r\n\r\n	public static final String CRAWLDB_PURGE_404 = \"db.update.purge.404\";\r\n\r\n	public static final String CURRENT_NAME = \"current\";\r\n\r\n	public static final String LOCK_NAME = \".locked\";\r\n\r\n	public CrawlDb() {}\r\n\r\n	public CrawlDb(Configuration conf) {\r\n		setConf(conf);\r\n	}\r\n\r\n	public void update(Path crawlDb, Path[] segments, boolean normalize, boolean filter) throws IOException {\r\n		boolean additionsAllowed = getConf().getBoolean(CRAWLDB_ADDITIONS_ALLOWED, true);\r\n		update(crawlDb, segments, normalize, filter, additionsAllowed, false);\r\n	}\r\n\r\n	public void update(Path crawlDb, Path[] segments, boolean normalize, boolean filter, boolean additionsAllowed, boolean force) throws IOException {\r\n		FileSystem fs = FileSystem.get(getConf());\r\n		Path lock = new Path(crawlDb, LOCK_NAME);\r\n		LockUtil.createLockFile(fs, lock, force);\r\n		SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\r\n		long start = System.currentTimeMillis();\r\n\r\n		JobConf job = CrawlDb.createJob(getConf(), crawlDb);\r\n		job.setBoolean(CRAWLDB_ADDITIONS_ALLOWED, additionsAllowed);\r\n		job.setBoolean(CrawlDbFilter.URL_FILTERING, filter);\r\n		job.setBoolean(CrawlDbFilter.URL_NORMALIZING, normalize);\r\n\r\n		boolean url404Purging = job.getBoolean(CRAWLDB_PURGE_404, false);\r\n\r\n		if (LOG.isInfoEnabled()) {\r\n			LOG.info(\"CrawlDb update: starting at \" + sdf.format(start));\r\n			LOG.info(\"CrawlDb update: db: \" + crawlDb);\r\n			LOG.info(\"CrawlDb update: segments: \" + Arrays.asList(segments));\r\n			LOG.info(\"CrawlDb update: additions allowed: \" + additionsAllowed);\r\n			LOG.info(\"CrawlDb update: URL normalizing: \" + normalize);\r\n			LOG.info(\"CrawlDb update: URL filtering: \" + filter);\r\n			LOG.info(\"CrawlDb update: 404 purging: \" + url404Purging);\r\n		}\r\n\r\n		for (int i = 0; i < segments.length; i++) {\r\n			Path fetch = new Path(segments[i], CrawlDatum.FETCH_DIR_NAME);\r\n			Path parse = new Path(segments[i], CrawlDatum.PARSE_DIR_NAME);\r\n			if (fs.exists(fetch) && fs.exists(parse)) {\r\n				FileInputFormat.addInputPath(job, fetch);\r\n				FileInputFormat.addInputPath(job, parse);\r\n			} else {\r\n				LOG.info(\" - skipping invalid segment \" + segments[i]);\r\n			}\r\n		}\r\n\r\n		if (LOG.isInfoEnabled()) {\r\n			LOG.info(\"CrawlDb update: Merging segment data into db.\");\r\n		}\r\n		try {\r\n			JobClient.runJob(job);\r\n		} catch (IOException e) {\r\n			LockUtil.removeLockFile(fs, lock);\r\n			Path outPath = FileOutputFormat.getOutputPath(job);\r\n			if (fs.exists(outPath) ) fs.delete(outPath, true);\r\n			throw e;\r\n		}\r\n\r\n		CrawlDb.install(job, crawlDb);\r\n		long end = System.currentTimeMillis();\r\n		LOG.info(\"CrawlDb update: finished at \" + sdf.format(end) + \", elapsed: \" + TimingUtil.elapsedTime(start, end));\r\n	}\r\n\r\n	public static JobConf createJob(Configuration config, Path crawlDb)\r\n	throws IOException {\r\n		Path newCrawlDb =\r\n		new Path(crawlDb,\r\n		Integer.toString(new Random().nextInt(Integer.MAX_VALUE)));\r\n\r\n		JobConf job = new NutchJob(config);\r\n		job.setJobName(\"crawldb \" + crawlDb);\r\n\r\n\r\n		Path current = new Path(crawlDb, CURRENT_NAME);\r\n		if (FileSystem.get(job).exists(current)) {\r\n			FileInputFormat.addInputPath(job, current);\r\n		}\r\n		job.setInputFormat(SequenceFileInputFormat.class);\r\n\r\n		job.setMapperClass(CrawlDbFilter.class);\r\n		job.setReducerClass(CrawlDbReducer.class);\r\n\r\n		FileOutputFormat.setOutputPath(job, newCrawlDb);\r\n		job.setOutputFormat(MapFileOutputFormat.class);\r\n		job.setOutputKeyClass(Text.class);\r\n		job.setOutputValueClass(CrawlDatum.class);\r\n\r\n		// https://issues.apache.org/jira/browse/NUTCH-1110\r\n		job.setBoolean(\"mapreduce.fileoutputcommitter.marksuccessfuljobs\", false);\r\n\r\n		return job;\r\n	}\r\n\r\n	public static void install(JobConf job, Path crawlDb) throws IOException {\r\n		Path newCrawlDb = FileOutputFormat.getOutputPath(job);\r\n		FileSystem fs = new JobClient(job).getFs();\r\n		Path old = new Path(crawlDb, \"old\");\r\n		Path current = new Path(crawlDb, CURRENT_NAME);\r\n		if (fs.exists(current)) {\r\n			if (fs.exists(old)) fs.delete(old, true);\r\n			fs.rename(current, old);\r\n		}\r\n		fs.mkdirs(crawlDb);\r\n		fs.rename(newCrawlDb, current);\r\n		if (fs.exists(old)) fs.delete(old, true);\r\n		Path lock = new Path(crawlDb, LOCK_NAME);\r\n		LockUtil.removeLockFile(fs, lock);\r\n	}\r\n\r\n	public static void main(String[] args) throws Exception {\r\n		int res = ToolRunner.run(NutchConfiguration.create(), new CrawlDb(), args);\r\n		System.exit(res);\r\n	}\r\n\r\n	public int run(String[] args) throws Exception {\r\n		if (args.length < 2) {\r\n			System.err.println(\"Usage: CrawlDb <crawldb> (-dir <segments> | <seg1> <seg2> ...) [-force] [-normalize] [-filter] [-noAdditions]\");\r\n			System.err.println(\"\\tcrawldb\\tCrawlDb to update\");\r\n			System.err.println(\"\\t-dir segments\\tparent directory containing all segments to update from\");\r\n			System.err.println(\"\\tseg1 seg2 ...\\tlist of segment names to update from\");\r\n			System.err.println(\"\\t-force\\tforce update even if CrawlDb appears to be locked (CAUTION advised)\");\r\n			System.err.println(\"\\t-normalize\\tuse URLNormalizer on urls in CrawlDb and segment (usually not needed)\");\r\n			System.err.println(\"\\t-filter\\tuse URLFilters on urls in CrawlDb and segment\");\r\n			System.err.println(\"\\t-noAdditions\\tonly update already existing URLs, don\'t add any newly discovered URLs\");\r\n\r\n			return -1;\r\n		}\r\n		boolean normalize = false;\r\n		boolean filter = false;\r\n		boolean force = false;\r\n		boolean url404Purging = false;\r\n		final FileSystem fs = FileSystem.get(getConf());\r\n		boolean additionsAllowed = getConf().getBoolean(CRAWLDB_ADDITIONS_ALLOWED, true);\r\n		HashSet<Path> dirs = new HashSet<Path>();\r\n		for (int i = 1; i < args.length; i++) {\r\n			if (args[i].equals(\"-normalize\")) {\r\n				normalize = true;\r\n			} else if (args[i].equals(\"-filter\")) {\r\n				filter = true;\r\n			} else if (args[i].equals(\"-force\")) {\r\n				force = true;\r\n			} else if (args[i].equals(\"-noAdditions\")) {\r\n				additionsAllowed = false;\r\n			} else if (args[i].equals(\"-dir\")) {\r\n				FileStatus[] paths = fs.listStatus(new Path(args[++i]), HadoopFSUtil.getPassDirectoriesFilter(fs));\r\n				dirs.addAll(Arrays.asList(HadoopFSUtil.getPaths(paths)));\r\n			} else {\r\n				dirs.add(new Path(args[i]));\r\n			}\r\n		}\r\n		try {\r\n			update(new Path(args[0]), dirs.toArray(new Path[dirs.size()]), normalize, filter, additionsAllowed, force);\r\n			return 0;\r\n		} catch (Exception e) {\r\n			LOG.error(\"CrawlDb update: \" + StringUtils.stringifyException(e));\r\n			return -1;\r\n		}\r\n	}\r\n}','Public Class','nutch','org.apache.nutch.crawl.CrawlDb',1,3,0),(10,'C','cdsbp','/**\r\n* Licensed to the Apache Software Foundation (ASF) under one or more\r\n* contributor license agreements.  See the NOTICE file distributed with\r\n* this work for additional information regarding copyright ownership.\r\n* The ASF licenses this file to You under the Apache License, Version 2.0\r\n* (the \"License\"); you may not use this file except in compliance with\r\n* the License.  You may obtain a copy of the License at\r\n*\r\n*     http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing, software\r\n* distributed under the License is distributed on an \"AS IS\" BASIS,\r\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n* See the License for the specific language governing permissions and\r\n* limitations under the License.\r\n*/\r\n\r\npackage org.apache.solr.search;\r\n\r\nimport org.apache.lucene.index.Term;\r\nimport org.apache.lucene.queryParser.ParseException;\r\nimport org.apache.lucene.queryParser.QueryParser;\r\nimport org.apache.lucene.search.BooleanClause;\r\nimport org.apache.lucene.search.BooleanQuery;\r\nimport org.apache.lucene.search.ConstantScoreQuery;\r\nimport org.apache.lucene.search.FuzzyQuery;\r\nimport org.apache.lucene.search.NumericRangeQuery;\r\nimport org.apache.lucene.search.PrefixQuery;\r\nimport org.apache.lucene.search.Query;\r\nimport org.apache.lucene.search.Sort;\r\nimport org.apache.lucene.search.SortField;\r\nimport org.apache.lucene.search.TermQuery;\r\nimport org.apache.lucene.search.TermRangeQuery;\r\nimport org.apache.lucene.search.WildcardQuery;\r\nimport org.apache.solr.common.SolrException;\r\nimport org.apache.solr.common.params.MapSolrParams;\r\nimport org.apache.solr.common.params.SolrParams;\r\nimport org.apache.solr.core.SolrCore;\r\nimport org.apache.solr.request.LocalSolrQueryRequest;\r\nimport org.apache.solr.request.SolrQueryRequest;\r\nimport org.apache.solr.schema.FieldType;\r\nimport org.apache.solr.schema.IndexSchema;\r\nimport org.apache.solr.schema.SchemaField;\r\nimport org.apache.solr.search.function.FunctionQuery;\r\nimport org.apache.solr.search.function.QueryValueSource;\r\nimport java.io.IOException;\r\nimport java.util.ArrayList;\r\nimport java.util.HashMap;\r\nimport java.util.List;\r\nimport java.util.Map;\r\n\r\n/**\r\n* Collection of static utilities useful for query parsing.\r\n*\r\n* @version $Id$\r\n*/\r\npublic class QueryParsing {\r\n	public static final String OP = \"q.op\";  // the SolrParam used to override the QueryParser \"default operator\"\r\n	public static final String V = \"v\";      // value of this parameter\r\n	public static final String F = \"f\";      // field that a query or command pertains to\r\n	public static final String TYPE = \"type\";// type of this query or command\r\n	public static final String DEFTYPE = \"defType\"; // default type for any direct subqueries\r\n	public static final String LOCALPARAM_START = \"{!\";\r\n	public static final char LOCALPARAM_END = \'}\';\r\n	public static final String DOCID = \"_docid_\";\r\n	public static final String SCORE = \"score\";\r\n\r\n	// true if the value was specified by the \"v\" param (i.e. v=myval, or v=$param)\r\n	public static final String VAL_EXPLICIT = \"__VAL_EXPLICIT__\";\r\n\r\n\r\n	/**\r\n* Helper utility for parsing a query using the Lucene QueryParser syntax.\r\n*\r\n* @param qs     query expression in standard Lucene syntax\r\n* @param schema used for default operator (overridden by params) and passed to the query parser for field format analysis information\r\n*/\r\n	public static Query parseQuery(String qs, IndexSchema schema) {\r\n		return parseQuery(qs, null, schema);\r\n	}\r\n\r\n	/**\r\n* Helper utility for parsing a query using the Lucene QueryParser syntax.\r\n*\r\n* @param qs           query expression in standard Lucene syntax\r\n* @param defaultField default field used for unqualified search terms in the query expression\r\n* @param schema       used for default operator (overridden by params) and passed to the query parser for field format analysis information\r\n*/\r\n	public static Query parseQuery(String qs, String defaultField, IndexSchema schema) {\r\n		try {\r\n			Query query = schema.getSolrQueryParser(defaultField).parse(qs);\r\n\r\n			if (SolrCore.log.isTraceEnabled()) {\r\n				SolrCore.log.trace(\"After QueryParser:\" + query);\r\n			}\r\n\r\n			return query;\r\n\r\n		} catch (ParseException e) {\r\n			SolrCore.log(e);\r\n			throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Error parsing Lucene query\", e);\r\n		}\r\n	}\r\n\r\n	/**\r\n* Helper utility for parsing a query using the Lucene QueryParser syntax.\r\n*\r\n* @param qs           query expression in standard Lucene syntax\r\n* @param defaultField default field used for unqualified search terms in the query expression\r\n* @param params       used to determine the default operator, overriding the schema specified operator\r\n* @param schema       used for default operator (overridden by params) and passed to the query parser for field format analysis information\r\n*/\r\n	public static Query parseQuery(String qs, String defaultField, SolrParams params, IndexSchema schema) {\r\n		try {\r\n			SolrQueryParser parser = schema.getSolrQueryParser(defaultField);\r\n			String opParam = params.get(OP);\r\n			if (opParam != null) {\r\n				parser.setDefaultOperator(\"AND\".equals(opParam) ? QueryParser.Operator.AND : QueryParser.Operator.OR);\r\n			}\r\n			Query query = parser.parse(qs);\r\n\r\n			if (SolrCore.log.isTraceEnabled()) {\r\n				SolrCore.log.trace(\"After QueryParser:\" + query);\r\n			}\r\n\r\n			return query;\r\n\r\n		} catch (ParseException e) {\r\n			SolrCore.log(e);\r\n			throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Query parsing error: \" + e.getMessage(), e);\r\n		}\r\n	}\r\n\r\n\r\n	// note to self: something needs to detect infinite recursion when parsing queries\r\n	static int parseLocalParams(String txt, int start, Map<String, String> target, SolrParams params) throws ParseException {\r\n		int off = start;\r\n		if (!txt.startsWith(LOCALPARAM_START, off)) return start;\r\n		StrParser p = new StrParser(txt, start, txt.length());\r\n		p.pos += 2; // skip over \"{!\"\r\n\r\n		for (; ;) {\r\n			/*\r\n	if (p.pos>=txt.length()) {\r\n		throw new ParseException(\"Missing \'}\' parsing local params \'\" + txt + \'\"\');\r\n	}\r\n	*/\r\n			char ch = p.peek();\r\n			if (ch == LOCALPARAM_END) {\r\n				return p.pos + 1;\r\n			}\r\n\r\n			String id = p.getId();\r\n			if (id.length() == 0) {\r\n				throw new ParseException(\"Expected identifier \'}\' parsing local params \'\" + txt + \'\"\');\r\n\r\n			}\r\n			String val = null;\r\n\r\n			ch = p.peek();\r\n			if (ch != \'=\') {\r\n				// single word... treat {!func} as type=func for easy lookup\r\n				val = id;\r\n				id = TYPE;\r\n			} else {\r\n				// saw equals, so read value\r\n				p.pos++;\r\n				ch = p.peek();\r\n				boolean deref = false;\r\n				if (ch == \'$\') {\r\n					p.pos++;\r\n					ch = p.peek();\r\n					deref = true;  // dereference whatever value is read by treating it as a variable name\r\n				}\r\n\r\n				if (ch == \'\\\"\' || ch == \'\\\'\') {\r\n					val = p.getQuotedString();\r\n				} else {\r\n					// read unquoted literal ended by whitespace or \'}\'\r\n					// there is no escaping.\r\n					int valStart = p.pos;\r\n					for (; ;) {\r\n						if (p.pos >= p.end) {\r\n							throw new ParseException(\"Missing end to unquoted value starting at \" + valStart + \" str=\'\" + txt + \"\'\");\r\n						}\r\n						char c = p.val.charAt(p.pos);\r\n						if (c == LOCALPARAM_END || Character.isWhitespace(c)) {\r\n							val = p.val.substring(valStart, p.pos);\r\n							break;\r\n						}\r\n						p.pos++;\r\n					}\r\n				}\r\n\r\n				if (deref) {  // dereference parameter\r\n					if (params != null) {\r\n						val = params.get(val);\r\n					}\r\n				}\r\n			}\r\n			if (target != null) target.put(id, val);\r\n		}\r\n	}\r\n\r\n	public static String encodeLocalParamVal(String val) {\r\n		int len = val.length();\r\n		int i = 0;\r\n		if (len > 0 && val.charAt(0) != \'$\') {\r\n			for (;i<len; i++) {\r\n				char ch = val.charAt(i);\r\n				if (Character.isWhitespace(ch) || ch==\'}\') break;\r\n			}\r\n		}\r\n\r\n		if (i>=len) return val;\r\n\r\n		// We need to enclose in quotes... but now we need to escape\r\n		StringBuilder sb = new StringBuilder(val.length() + 4);\r\n		sb.append(\'\\\'\');\r\n		for (i=0; i<len; i++) {\r\n			char ch = val.charAt(i);\r\n			if (ch==\'\\\'\') {\r\n				sb.append(\'\\\\\');\r\n			}\r\n			sb.append(ch);\r\n		}\r\n		sb.append(\'\\\'\');\r\n		return sb.toString();\r\n	}\r\n\r\n\r\n	/**\r\n* \"foo\" returns null\r\n* \"{!prefix f=myfield}yes\" returns type=\"prefix\",f=\"myfield\",v=\"yes\"\r\n* \"{!prefix f=myfield v=$p}\" returns type=\"prefix\",f=\"myfield\",v=params.get(\"p\")\r\n*/\r\n	public static SolrParams getLocalParams(String txt, SolrParams params) throws ParseException {\r\n		if (txt == null || !txt.startsWith(LOCALPARAM_START)) {\r\n			return null;\r\n		}\r\n		Map<String, String> localParams = new HashMap<String, String>();\r\n		int start = QueryParsing.parseLocalParams(txt, 0, localParams, params);\r\n\r\n		String val = localParams.get(V);\r\n		if (val == null) {\r\n			val = txt.substring(start);\r\n			localParams.put(V, val);\r\n		} else {\r\n			// localParams.put(VAL_EXPLICIT, \"true\");\r\n		}\r\n		return new MapSolrParams(localParams);\r\n	}\r\n\r\n\r\n	/**\r\n* Returns null if the sortSpec is the standard sort desc.\r\n* <p/>\r\n* <p>\r\n* The form of the sort specification string currently parsed is:\r\n* </p>\r\n* <pre>>\r\n* SortSpec ::= SingleSort [, SingleSort]*\r\n* SingleSort ::= <fieldname> SortDirection\r\n* SortDirection ::= top | desc | bottom | asc\r\n* </pre>\r\n* Examples:\r\n* <pre>\r\n*   score desc               #normal sort by score (will return null)\r\n*   weight bottom            #sort by weight ascending\r\n*   weight desc              #sort by weight descending\r\n*   height desc,weight desc  #sort by height descending, and use weight descending to break any ties\r\n*   height desc,weight asc   #sort by height descending, using weight ascending as a tiebreaker\r\n* </pre>\r\n*/\r\n	public static Sort parseSort(String sortSpec, SolrQueryRequest req) {\r\n		if (sortSpec == null || sortSpec.length() == 0) return null;\r\n		List<SortField> lst = new ArrayList<SortField>(4);\r\n\r\n		try {\r\n\r\n			StrParser sp = new StrParser(sortSpec);\r\n			while (sp.pos < sp.end) {\r\n				sp.eatws();\r\n\r\n				final int start = sp.pos;\r\n\r\n				// short circuit test for a really simple field name\r\n				String field = sp.getId(null);\r\n				Exception qParserException = null;\r\n\r\n				if (field == null || !Character.isWhitespace(sp.peekChar())) {\r\n					// let\'s try it as a function instead\r\n					field = null;\r\n					String funcStr = sp.val.substring(start);\r\n\r\n					QParser parser = QParser.getParser(funcStr, FunctionQParserPlugin.NAME, req);\r\n					Query q = null;\r\n					try {\r\n						if (parser instanceof FunctionQParser) {\r\n							FunctionQParser fparser = (FunctionQParser)parser;\r\n							fparser.setParseMultipleSources(false);\r\n							fparser.setParseToEnd(false);\r\n							\r\n							q = fparser.getQuery();\r\n							\r\n							if (fparser.localParams != null) {\r\n								if (fparser.valFollowedParams) {\r\n									// need to find the end of the function query via the string parser\r\n									int leftOver = fparser.sp.end - fparser.sp.pos;\r\n									sp.pos = sp.end - leftOver;   // reset our parser to the same amount of leftover\r\n								} else {\r\n									// the value was via the \"v\" param in localParams, so we need to find\r\n									// the end of the local params themselves to pick up where we left off\r\n									sp.pos = start + fparser.localParamsEnd;\r\n								}\r\n							} else {\r\n								// need to find the end of the function query via the string parser\r\n								int leftOver = fparser.sp.end - fparser.sp.pos;\r\n								sp.pos = sp.end - leftOver;   // reset our parser to the same amount of leftover\r\n							}\r\n						} else {\r\n							// A QParser that\'s not for function queries.\r\n							// It must have been specified via local params.\r\n							q = parser.getQuery();\r\n\r\n							assert parser.getLocalParams() != null;\r\n							sp.pos = start + parser.localParamsEnd;\r\n						}\r\n\r\n						Boolean top = sp.getSortDirection();\r\n						if (null != top) {\r\n							// we have a Query and a valid direction\r\n							if (q instanceof FunctionQuery) {\r\n								lst.add(((FunctionQuery)q).getValueSource().getSortField(top));\r\n							} else {\r\n								lst.add((new QueryValueSource(q, 0.0f)).getSortField(top));\r\n							}\r\n							continue;\r\n						}\r\n					} catch (IOException ioe) {\r\n						throw ioe;\r\n					} catch (Exception e) {\r\n						// hang onto this in case the string isn\'t a full field name either\r\n						qParserException = e;\r\n					}\r\n				}\r\n\r\n				// if we made it here, we either have a \"simple\" field name,\r\n				// or there was a problem parsing the string as a complex func/quer\r\n\r\n				if (field == null) {\r\n					// try again, simple rules for a field name with no whitespace\r\n					sp.pos = start;\r\n					field = sp.getSimpleString();\r\n				}\r\n				Boolean top = sp.getSortDirection();\r\n				if (null == top) {\r\n					throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \r\n					\"Can\'t determine Sort Order: \" + sp);\r\n				}\r\n				\r\n				if (SCORE.equals(field)) {\r\n					if (top) {\r\n						lst.add(SortField.FIELD_SCORE);\r\n					} else {\r\n						lst.add(new SortField(null, SortField.SCORE, true));\r\n					}\r\n				} else if (DOCID.equals(field)) {\r\n					lst.add(new SortField(null, SortField.DOC, top));\r\n				} else {\r\n					// try to find the field\r\n					SchemaField sf = req.getSchema().getFieldOrNull(field);\r\n					if (null == sf) {\r\n						if (null != qParserException) {\r\n							throw new SolrException\r\n							(SolrException.ErrorCode.BAD_REQUEST,\r\n							\"sort param could not be parsed as a query, and is not a \"+\r\n							\"field that exists in the index: \" + field,\r\n							qParserException);\r\n						}\r\n						throw new SolrException\r\n						(SolrException.ErrorCode.BAD_REQUEST,\r\n						\"sort param field can\'t be found: \" + field);\r\n					}\r\n					lst.add(sf.getSortField(top));\r\n				}\r\n			}\r\n\r\n		} catch (ParseException e) {\r\n			throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"error in sort: \" + sortSpec, e);\r\n		} catch (IOException e) {\r\n			throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"error in sort: \" + sortSpec, e);\r\n		}\r\n\r\n\r\n		// normalize a sort on score desc to null\r\n		if (lst.size()==1 && lst.get(0) == SortField.FIELD_SCORE) {\r\n			return null;\r\n		}\r\n\r\n		return new Sort(lst.toArray(new SortField[lst.size()]));\r\n	}\r\n\r\n\r\n\r\n	///////////////////////////\r\n	///////////////////////////\r\n	///////////////////////////\r\n\r\n	static FieldType writeFieldName(String name, IndexSchema schema, Appendable out, int flags) throws IOException {\r\n		FieldType ft = null;\r\n		ft = schema.getFieldTypeNoEx(name);\r\n		out.append(name);\r\n		if (ft == null) {\r\n			out.append(\"(UNKNOWN FIELD \" + name + \')\');\r\n		}\r\n		out.append(\':\');\r\n		return ft;\r\n	}\r\n\r\n	static void writeFieldVal(String val, FieldType ft, Appendable out, int flags) throws IOException {\r\n		if (ft != null) {\r\n			try {\r\n				out.append(ft.indexedToReadable(val));\r\n			} catch (Exception e) {\r\n				out.append(\"EXCEPTION(val=\");\r\n				out.append(val);\r\n				out.append(\")\");\r\n			}\r\n		} else {\r\n			out.append(val);\r\n		}\r\n	}\r\n\r\n	/**\r\n* @see #toString(Query,IndexSchema)\r\n*/\r\n	public static void toString(Query query, IndexSchema schema, Appendable out, int flags) throws IOException {\r\n		boolean writeBoost = true;\r\n\r\n		if (query instanceof TermQuery) {\r\n			TermQuery q = (TermQuery) query;\r\n			Term t = q.getTerm();\r\n			FieldType ft = writeFieldName(t.field(), schema, out, flags);\r\n			writeFieldVal(t.text(), ft, out, flags);\r\n		} else if (query instanceof TermRangeQuery) {\r\n			TermRangeQuery q = (TermRangeQuery) query;\r\n			String fname = q.getField();\r\n			FieldType ft = writeFieldName(fname, schema, out, flags);\r\n			out.append(q.includesLower() ? \'[\' : \'{\');\r\n			String lt = q.getLowerTerm();\r\n			String ut = q.getUpperTerm();\r\n			if (lt == null) {\r\n				out.append(\'*\');\r\n			} else {\r\n				writeFieldVal(lt, ft, out, flags);\r\n			}\r\n\r\n			out.append(\" TO \");\r\n\r\n			if (ut == null) {\r\n				out.append(\'*\');\r\n			} else {\r\n				writeFieldVal(ut, ft, out, flags);\r\n			}\r\n\r\n			out.append(q.includesUpper() ? \']\' : \'}\');\r\n		} else if (query instanceof NumericRangeQuery) {\r\n			NumericRangeQuery q = (NumericRangeQuery) query;\r\n			String fname = q.getField();\r\n			FieldType ft = writeFieldName(fname, schema, out, flags);\r\n			out.append(q.includesMin() ? \'[\' : \'{\');\r\n			Number lt = q.getMin();\r\n			Number ut = q.getMax();\r\n			if (lt == null) {\r\n				out.append(\'*\');\r\n			} else {\r\n				out.append(lt.toString());\r\n			}\r\n\r\n			out.append(\" TO \");\r\n\r\n			if (ut == null) {\r\n				out.append(\'*\');\r\n			} else {\r\n				out.append(ut.toString());\r\n			}\r\n\r\n			out.append(q.includesMax() ? \']\' : \'}\');\r\n		} else if (query instanceof BooleanQuery) {\r\n			BooleanQuery q = (BooleanQuery) query;\r\n			boolean needParens = false;\r\n\r\n			if (q.getBoost() != 1.0 || q.getMinimumNumberShouldMatch() != 0) {\r\n				needParens = true;\r\n			}\r\n			if (needParens) {\r\n				out.append(\'(\');\r\n			}\r\n			boolean first = true;\r\n			for (BooleanClause c : q.clauses()) {\r\n				if (!first) {\r\n					out.append(\' \');\r\n				} else {\r\n					first = false;\r\n				}\r\n\r\n				if (c.isProhibited()) {\r\n					out.append(\'-\');\r\n				} else if (c.isRequired()) {\r\n					out.append(\'+\');\r\n				}\r\n				Query subQuery = c.getQuery();\r\n				boolean wrapQuery = false;\r\n\r\n				// TODO: may need to put parens around other types\r\n				// of queries too, depending on future syntax.\r\n				if (subQuery instanceof BooleanQuery) {\r\n					wrapQuery = true;\r\n				}\r\n\r\n				if (wrapQuery) {\r\n					out.append(\'(\');\r\n				}\r\n\r\n				toString(subQuery, schema, out, flags);\r\n\r\n				if (wrapQuery) {\r\n					out.append(\')\');\r\n				}\r\n			}\r\n\r\n			if (needParens) {\r\n				out.append(\')\');\r\n			}\r\n			if (q.getMinimumNumberShouldMatch() > 0) {\r\n				out.append(\'~\');\r\n				out.append(Integer.toString(q.getMinimumNumberShouldMatch()));\r\n			}\r\n\r\n		} else if (query instanceof PrefixQuery) {\r\n			PrefixQuery q = (PrefixQuery) query;\r\n			Term prefix = q.getPrefix();\r\n			FieldType ft = writeFieldName(prefix.field(), schema, out, flags);\r\n			out.append(prefix.text());\r\n			out.append(\'*\');\r\n		} else if (query instanceof ConstantScorePrefixQuery) {\r\n			ConstantScorePrefixQuery q = (ConstantScorePrefixQuery) query;\r\n			Term prefix = q.getPrefix();\r\n			FieldType ft = writeFieldName(prefix.field(), schema, out, flags);\r\n			out.append(prefix.text());\r\n			out.append(\'*\');\r\n		} else if (query instanceof WildcardQuery) {\r\n			out.append(query.toString());\r\n			writeBoost = false;\r\n		} else if (query instanceof FuzzyQuery) {\r\n			out.append(query.toString());\r\n			writeBoost = false;\r\n		} else if (query instanceof ConstantScoreQuery) {\r\n			out.append(query.toString());\r\n			writeBoost = false;\r\n		} else {\r\n			out.append(query.getClass().getSimpleName()\r\n			+ \'(\' + query.toString() + \')\');\r\n			writeBoost = false;\r\n		}\r\n\r\n		if (writeBoost && query.getBoost() != 1.0f) {\r\n			out.append(\"^\");\r\n			out.append(Float.toString(query.getBoost()));\r\n		}\r\n\r\n	}\r\n\r\n	/**\r\n* Formats a Query for debugging, using the IndexSchema to make\r\n* complex field types readable.\r\n* <p/>\r\n* <p>\r\n* The benefit of using this method instead of calling\r\n* <code>Query.toString</code> directly is that it knows about the data\r\n* types of each field, so any field which is encoded in a particularly\r\n* complex way is still readable. The downside is that it only knows\r\n* about built in Query types, and will not be able to format custom\r\n* Query classes.\r\n* </p>\r\n*/\r\n	public static String toString(Query query, IndexSchema schema) {\r\n		try {\r\n			StringBuilder sb = new StringBuilder();\r\n			toString(query, schema, sb, 0);\r\n			return sb.toString();\r\n		} catch (Exception e) {\r\n			throw new RuntimeException(e);\r\n		}\r\n	}\r\n\r\n	/**\r\n* Simple class to help with parsing a string\r\n* <b>Note: This API is experimental and may change in non backward-compatible ways in the future</b>\r\n*/\r\n	public static class StrParser {\r\n		String val;\r\n		int pos;\r\n		int end;\r\n\r\n		public StrParser(String val) {\r\n			this(val, 0, val.length());\r\n		}\r\n\r\n		public StrParser(String val, int start, int end) {\r\n			this.val = val;\r\n			this.pos = start;\r\n			this.end = end;\r\n		}\r\n\r\n		void eatws() {\r\n			while (pos < end && Character.isWhitespace(val.charAt(pos))) pos++;\r\n		}\r\n\r\n		char ch() {\r\n			return pos < end ? val.charAt(pos) : 0;\r\n		}\r\n\r\n		void skip(int nChars) {\r\n			pos = Math.max(pos + nChars, end);\r\n		}\r\n\r\n		boolean opt(String s) {\r\n			eatws();\r\n			int slen = s.length();\r\n			if (val.regionMatches(pos, s, 0, slen)) {\r\n				pos += slen;\r\n				return true;\r\n			}\r\n			return false;\r\n		}\r\n\r\n		boolean opt(char ch) {\r\n			eatws();\r\n			if (val.charAt(pos) == ch) {\r\n				pos++;\r\n				return true;\r\n			}\r\n			return false;\r\n		}\r\n\r\n\r\n		void expect(String s) throws ParseException {\r\n			eatws();\r\n			int slen = s.length();\r\n			if (val.regionMatches(pos, s, 0, slen)) {\r\n				pos += slen;\r\n			} else {\r\n				throw new ParseException(\"Expected \'\" + s + \"\' at position \" + pos + \" in \'\" + val + \"\'\");\r\n			}\r\n		}\r\n\r\n		float getFloat() throws ParseException {\r\n			eatws();\r\n			char[] arr = new char[end - pos];\r\n			int i;\r\n			for (i = 0; i < arr.length; i++) {\r\n				char ch = val.charAt(pos);\r\n				if ((ch >= \'0\' && ch <= \'9\')\r\n						|| ch == \'+\' || ch == \'-\'\r\n						|| ch == \'.\' || ch == \'e\' || ch == \'E\'\r\n						) {\r\n					pos++;\r\n					arr[i] = ch;\r\n				} else {\r\n					break;\r\n				}\r\n			}\r\n\r\n			return Float.parseFloat(new String(arr, 0, i));\r\n		}\r\n\r\n		Number getNumber() throws ParseException {\r\n			eatws();\r\n			int start = pos;\r\n			boolean flt = false;\r\n\r\n			while (pos < end) {\r\n				char ch = val.charAt(pos);\r\n				if ((ch >= \'0\' && ch <= \'9\') || ch == \'+\' || ch == \'-\') {\r\n					pos++;\r\n				} else if (ch == \'.\' || ch ==\'e\' || ch==\'E\') {\r\n					flt = true;\r\n					pos++;\r\n				} else {\r\n					break;\r\n				}\r\n			}\r\n\r\n			String v = val.substring(start,pos);\r\n			return flt ? Double.parseDouble(v) : Long.parseLong(v);\r\n		}\r\n\r\n		double getDouble() throws ParseException {\r\n			eatws();\r\n			char[] arr = new char[end - pos];\r\n			int i;\r\n			for (i = 0; i < arr.length; i++) {\r\n				char ch = val.charAt(pos);\r\n				if ((ch >= \'0\' && ch <= \'9\')\r\n						|| ch == \'+\' || ch == \'-\'\r\n						|| ch == \'.\' || ch == \'e\' || ch == \'E\'\r\n						) {\r\n					pos++;\r\n					arr[i] = ch;\r\n				} else {\r\n					break;\r\n				}\r\n			}\r\n\r\n			return Double.parseDouble(new String(arr, 0, i));\r\n		}\r\n\r\n		int getInt() throws ParseException {\r\n			eatws();\r\n			char[] arr = new char[end - pos];\r\n			int i;\r\n			for (i = 0; i < arr.length; i++) {\r\n				char ch = val.charAt(pos);\r\n				if ((ch >= \'0\' && ch <= \'9\')\r\n						|| ch == \'+\' || ch == \'-\'\r\n						) {\r\n					pos++;\r\n					arr[i] = ch;\r\n				} else {\r\n					break;\r\n				}\r\n			}\r\n\r\n			return Integer.parseInt(new String(arr, 0, i));\r\n		}\r\n\r\n\r\n		String getId() throws ParseException {\r\n			return getId(\"Expected identifier\");\r\n		}\r\n\r\n		String getId(String errMessage) throws ParseException {\r\n			eatws();\r\n			int id_start = pos;\r\n			char ch;\r\n			if (pos < end && (ch = val.charAt(pos)) != \'$\' && Character.isJavaIdentifierStart(ch)) {\r\n				pos++;\r\n				while (pos < end) {\r\n					ch = val.charAt(pos);\r\n					if (!Character.isJavaIdentifierPart(ch) && ch != \'.\') {\r\n						break;\r\n					}\r\n					pos++;\r\n				}\r\n				return val.substring(id_start, pos);\r\n			}\r\n\r\n			if (errMessage != null) {\r\n				throw new ParseException(errMessage + \" at pos \" + pos + \" str=\'\" + val + \"\'\");\r\n			}\r\n			return null;\r\n		}\r\n\r\n		/**\r\n	* Skips leading whitespace and returns whatever sequence of non \r\n	* whitespace it can find (or hte empty string)\r\n	*/\r\n		String getSimpleString() {\r\n			eatws();\r\n			int startPos = pos;\r\n			char ch;\r\n			while (pos < end) {\r\n				ch = val.charAt(pos);\r\n				if (Character.isWhitespace(ch)) break;\r\n				pos++;\r\n			}\r\n			return val.substring(startPos, pos);\r\n		}\r\n\r\n		/**\r\n	* Sort direction or null if current position does not inidcate a \r\n	* sort direction. (True is desc, False is asc).  \r\n	* Position is advanced to after the comma (or end) when result is non null \r\n	*/\r\n		Boolean getSortDirection() throws ParseException {\r\n			final int startPos = pos;\r\n			final String order = getId(null);\r\n\r\n			Boolean top = null;\r\n\r\n			if (null != order) {\r\n				if (\"desc\".equals(order) || \"top\".equals(order)) {\r\n					top = true;\r\n				} else if (\"asc\".equals(order) || \"bottom\".equals(order)) {\r\n					top = false;\r\n				}\r\n\r\n				// it\'s not a legal direction if more stuff comes after it\r\n				eatws();\r\n				final char c = ch();\r\n				if (0 == c) {\r\n					// :NOOP\r\n				} else if (\',\' == c) {\r\n					pos++;\r\n				} else {\r\n					top = null;\r\n				}\r\n			}\r\n\r\n			if (null == top) pos = startPos; // no direction, reset\r\n			return top;\r\n		}\r\n\r\n		// return null if not a string\r\n		String getQuotedString() throws ParseException {\r\n			eatws();\r\n			char delim = peekChar();\r\n			if (!(delim == \'\\\"\' || delim == \'\\\'\')) {\r\n				return null;\r\n			}\r\n			int val_start = ++pos;\r\n			StringBuilder sb = new StringBuilder(); // needed for escaping\r\n			for (; ;) {\r\n				if (pos >= end) {\r\n					throw new ParseException(\"Missing end quote for string at pos \" + (val_start - 1) + \" str=\'\" + val + \"\'\");\r\n				}\r\n				char ch = val.charAt(pos);\r\n				if (ch == \'\\\\\') {\r\n					pos++;\r\n					if (pos >= end) break;\r\n					ch = val.charAt(pos);\r\n					switch (ch) {\r\n					case \'n\':\r\n						ch = \'\\n\';\r\n						break;\r\n					case \'t\':\r\n						ch = \'\\t\';\r\n						break;\r\n					case \'r\':\r\n						ch = \'\\r\';\r\n						break;\r\n					case \'b\':\r\n						ch = \'\\b\';\r\n						break;\r\n					case \'f\':\r\n						ch = \'\\f\';\r\n						break;\r\n					case \'u\':\r\n						if (pos + 4 >= end) {\r\n							throw new ParseException(\"bad unicode escape \\\\uxxxx at pos\" + (val_start - 1) + \" str=\'\" + val + \"\'\");\r\n						}\r\n						ch = (char) Integer.parseInt(val.substring(pos + 1, pos + 5), 16);\r\n						pos += 4;\r\n						break;\r\n					}\r\n				} else if (ch == delim) {\r\n					pos++;  // skip over the quote\r\n					break;\r\n				}\r\n				sb.append(ch);\r\n				pos++;\r\n			}\r\n\r\n			return sb.toString();\r\n		}\r\n\r\n		// next non-whitespace char\r\n		char peek() {\r\n			eatws();\r\n			return pos < end ? val.charAt(pos) : 0;\r\n		}\r\n\r\n		// next char\r\n		char peekChar() {\r\n			return pos < end ? val.charAt(pos) : 0;\r\n		}\r\n\r\n		@Override\r\n		public String toString() {\r\n			return \"\'\" + val + \"\'\" + \", pos=\" + pos;\r\n		}\r\n\r\n	}\r\n\r\n	/**\r\n* Builds a list of String which are stringified versions of a list of Queries\r\n*/\r\n	public static List<String> toString(List<Query> queries, IndexSchema schema) {\r\n		List<String> out = new ArrayList<String>(queries.size());\r\n		for (Query q : queries) {\r\n			out.add(QueryParsing.toString(q, schema));\r\n		}\r\n		return out;\r\n	}\r\n\r\n	/**\r\n* Parse a function, returning a FunctionQuery\r\n* <p/>\r\n* <p>\r\n* Syntax Examples....\r\n* </p>\r\n* <p/>\r\n* <pre>\r\n* // Numeric fields default to correct type\r\n* // (ie: IntFieldSource or FloatFieldSource)\r\n* // Others use explicit ord(...) to generate numeric field value\r\n* myfield\r\n* <p/>\r\n* // OrdFieldSource\r\n* ord(myfield)\r\n* <p/>\r\n* // ReverseOrdFieldSource\r\n* rord(myfield)\r\n* <p/>\r\n* // LinearFloatFunction on numeric field value\r\n* linear(myfield,1,2)\r\n* <p/>\r\n* // MaxFloatFunction of LinearFloatFunction on numeric field value or constant\r\n* max(linear(myfield,1,2),100)\r\n* <p/>\r\n* // ReciprocalFloatFunction on numeric field value\r\n* recip(myfield,1,2,3)\r\n* <p/>\r\n* // ReciprocalFloatFunction on ReverseOrdFieldSource\r\n* recip(rord(myfield),1,2,3)\r\n* <p/>\r\n* // ReciprocalFloatFunction on LinearFloatFunction on ReverseOrdFieldSource\r\n* recip(linear(rord(myfield),1,2),3,4,5)\r\n* </pre>\r\n*/\r\n	public static FunctionQuery parseFunction(String func, IndexSchema schema) throws ParseException {\r\n		SolrCore core = SolrCore.getSolrCore();\r\n		return (FunctionQuery) (QParser.getParser(func, \"func\", new LocalSolrQueryRequest(core, new HashMap())).parse());\r\n		// return new FunctionQuery(parseValSource(new StrParser(func), schema));\r\n	}\r\n\r\n}','Public Class','lucene','org.apache.solr.search.QueryParsing',2,6,0),(11,'M','lpl','public BenchmarkResults benchmark(int seeds, int depth, int threads, int maxPerHost, long topN, boolean delete, String plugins) throws Exception {\r\n	Configuration conf = getConf();\r\n	conf.set(\"http.proxy.host\", \"localhost\");\r\n	conf.setInt(\"http.proxy.port\", 8181);\r\n	conf.set(\"http.agent.name\", \"test\");\r\n	conf.set(\"http.robots.agents\", \"test,*\");\r\n	if (!plugins.equals(\"default\")) {\r\n		conf.set(\"plugin.includes\", plugins);\r\n	}\r\n	conf.setInt(Generator.GENERATOR_MAX_COUNT, maxPerHost);\r\n	conf.set(Generator.GENERATOR_COUNT_MODE, Generator.GENERATOR_COUNT_VALUE_HOST);\r\n	JobConf job = new NutchJob(getConf());    \r\n	FileSystem fs = FileSystem.get(job);\r\n	Path dir = new Path(getConf().get(\"hadoop.tmp.dir\"),\r\n	\"bench-\" + System.currentTimeMillis());\r\n	fs.mkdirs(dir);\r\n	Path rootUrlDir = new Path(dir, \"seed\");\r\n	fs.mkdirs(rootUrlDir);\r\n	createSeeds(fs, rootUrlDir, seeds);\r\n\r\n	if (LOG.isInfoEnabled()) {\r\n		LOG.info(\"crawl started in: \" + dir);\r\n		LOG.info(\"rootUrlDir = \" + rootUrlDir);\r\n		LOG.info(\"threads = \" + threads);\r\n		LOG.info(\"depth = \" + depth);      \r\n	}\r\n	BenchmarkResults res = new BenchmarkResults();\r\n	res.delete = delete;\r\n	res.depth = depth;\r\n	res.plugins = plugins;\r\n	res.seeds = seeds;\r\n	res.threads = threads;\r\n	res.topN = topN;\r\n	Path crawlDb = new Path(dir + \"/crawldb\");\r\n	Path linkDb = new Path(dir + \"/linkdb\");\r\n	Path segments = new Path(dir + \"/segments\");\r\n	res.elapsed = System.currentTimeMillis();\r\n	Injector injector = new Injector(getConf());\r\n	Generator generator = new Generator(getConf());\r\n	Fetcher fetcher = new Fetcher(getConf());\r\n	ParseSegment parseSegment = new ParseSegment(getConf());\r\n	CrawlDb crawlDbTool = new CrawlDb(getConf());\r\n	LinkDb linkDbTool = new LinkDb(getConf());\r\n	\r\n	// initialize crawlDb\r\n	long start = System.currentTimeMillis();\r\n	injector.inject(crawlDb, rootUrlDir);\r\n	long delta = System.currentTimeMillis() - start;\r\n	res.addTiming(\"inject\", \"0\", delta);\r\n	int i;\r\n	for (i = 0; i < depth; i++) {             // generate new segment\r\n		start = System.currentTimeMillis();\r\n		Path[] segs = generator.generate(crawlDb, segments, -1, topN, System\r\n		.currentTimeMillis());\r\n		delta = System.currentTimeMillis() - start;\r\n		res.addTiming(\"generate\", i + \"\", delta);\r\n		if (segs == null) {\r\n			LOG.info(\"Stopping at depth=\" + i + \" - no more URLs to fetch.\");\r\n			break;\r\n		}\r\n		start = System.currentTimeMillis();\r\n		fetcher.fetch(segs[0], threads);  // fetch it\r\n		delta = System.currentTimeMillis() - start;\r\n		res.addTiming(\"fetch\", i + \"\", delta);\r\n		if (!Fetcher.isParsing(job)) {\r\n			start = System.currentTimeMillis();\r\n			parseSegment.parse(segs[0]);    // parse it, if needed\r\n			delta = System.currentTimeMillis() - start;\r\n			res.addTiming(\"parse\", i + \"\", delta);\r\n		}\r\n		start = System.currentTimeMillis();\r\n		crawlDbTool.update(crawlDb, segs, true, true); // update crawldb\r\n		delta = System.currentTimeMillis() - start;\r\n		res.addTiming(\"update\", i + \"\", delta);\r\n		start = System.currentTimeMillis();\r\n		linkDbTool.invert(linkDb, segs, true, true, false); // invert links\r\n		delta = System.currentTimeMillis() - start;\r\n		res.addTiming(\"invert\", i + \"\", delta);\r\n		// delete data\r\n		if (delete) {\r\n			for (Path p : segs) {\r\n				fs.delete(p, true);\r\n			}\r\n		}\r\n	}\r\n	if (i == 0) {\r\n		LOG.warn(\"No URLs to fetch - check your seed list and URL filters.\");\r\n	}\r\n	if (LOG.isInfoEnabled()) { LOG.info(\"crawl finished: \" + dir); }\r\n	res.elapsed = System.currentTimeMillis() - res.elapsed;\r\n	CrawlDbReader dbreader = new CrawlDbReader();\r\n	dbreader.processStatJob(crawlDb.toString(), conf, false);\r\n	return res;\r\n}','Public Method','nutch','org.apache.nutch.tools.Benchmark.benchmark',1,5,0),(12,'M','lpl','@Override\r\n  public FSDataOutputStream create(Path f, FsPermission permission,\r\n      boolean overwrite, int bufferSize, short replication, long blockSize,\r\n      Progressable progress) throws IOException {\r\n    return super.create(swizzleParamPath(f), permission,\r\n        overwrite, bufferSize, replication, blockSize, progress);\r\n  }','Public Method','hive','org.apache.hadoop.fs.ProxyFileSystem.create',2,9,0),(13,'C','gc','/*\r\n *  Licensed to the Apache Software Foundation (ASF) under one or more\r\n *  contributor license agreements.  See the NOTICE file distributed with\r\n *  this work for additional information regarding copyright ownership.\r\n *  The ASF licenses this file to You under the Apache License, Version 2.0\r\n *  (the \"License\"); you may not use this file except in compliance with\r\n *  the License.  You may obtain a copy of the License at\r\n *\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n *  Unless required by applicable law or agreed to in writing, software\r\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\r\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n *  See the License for the specific language governing permissions and\r\n *  limitations under the License.\r\n *\r\n */\r\npackage org.apache.tools.ant.types.optional;\r\n\r\nimport org.apache.tools.ant.BuildException;\r\nimport org.apache.tools.ant.taskdefs.condition.Condition;\r\n\r\n/**\r\n * A condition that lets you include script.\r\n * The condition component sets a bean \"self\", whose attribute \"value\"\r\n * must be set to true for the condition to succeed, false to fail.\r\n * The default is \'false\'\r\n */\r\npublic class ScriptCondition extends AbstractScriptComponent implements Condition {\r\n\r\n    /**\r\n     * result field\r\n     */\r\n    private boolean value = false;\r\n\r\n    /**\r\n     * Is this condition true?\r\n     *\r\n     * @return true if the condition is true\r\n     *\r\n     * @throws org.apache.tools.ant.BuildException\r\n     *          if an error occurs\r\n     */\r\n    public boolean eval() throws BuildException {\r\n        initScriptRunner();\r\n        executeScript(\"ant_condition\");\r\n        return getValue();\r\n    }\r\n\r\n    /**\r\n     * get the current value of the conditon\r\n     * @return true if the condition\r\n     */\r\n    public boolean getValue() {\r\n        return value;\r\n    }\r\n\r\n    /**\r\n     * set the value of the condition.\r\n     * This is used by the script to pass the return value.\r\n     * It can be used by an attribute, in which case it sets the default\r\n     * value\r\n     * @param value the value to set the condition to\r\n     */\r\n    public void setValue(boolean value) {\r\n        this.value = value;\r\n    }\r\n}','Public Class','ant','org.apache.tools.ant.types.optional.ScriptCondition',1,7,1),(14,'M','lm','/**\r\n     * Is this condition true?\r\n     *\r\n     * @return true if the condition is true\r\n     *\r\n     * @throws org.apache.tools.ant.BuildException\r\n     *          if an error occurs\r\n     */\r\n    public boolean eval() throws BuildException {\r\n        initScriptRunner();\r\n        executeScript(\"ant_condition\");\r\n        return getValue();\r\n    }','Public Method','ant','org.apache.tools.ant.types.optional.ScriptCondition',1,4,1),(15,'M','lpl','/**\r\n     * Executes the proxied task.\r\n     *\r\n     * @exception BuildException if the project could not be set\r\n     * or the method could not be executed.\r\n     */\r\n    public void execute() throws BuildException {\r\n        try {\r\n            Method setLocationM = proxy.getClass().getMethod(\r\n                \"setLocation\", new Class[] {Location.class});\r\n            if (setLocationM != null) {\r\n                setLocationM.invoke(proxy, new Object[] {getLocation()});\r\n            }\r\n        } catch (NoSuchMethodException e) {\r\n            // ignore this if the class being used as a task does not have\r\n            // a set location method.\r\n        } catch (Exception ex) {\r\n            log(\"Error setting location in \" + proxy.getClass(),\r\n                Project.MSG_ERR);\r\n            throw new BuildException(ex);\r\n        }\r\n\r\n        try {\r\n            Method setProjectM = proxy.getClass().getMethod(\r\n                \"setProject\", new Class[] {Project.class});\r\n            if (setProjectM != null) {\r\n                setProjectM.invoke(proxy, new Object[] {getProject()});\r\n            }\r\n        } catch (NoSuchMethodException e) {\r\n            // ignore this if the class being used as a task does not have\r\n            // a set project method.\r\n        } catch (Exception ex) {\r\n            log(\"Error setting project in \" + proxy.getClass(),\r\n                Project.MSG_ERR);\r\n            throw new BuildException(ex);\r\n        }\r\n\r\n        try {\r\n            DispatchUtils.execute(proxy);\r\n        } catch (BuildException be) {\r\n            throw be;\r\n        } catch (Exception ex) {\r\n            log(\"Error in \" + proxy.getClass(), Project.MSG_VERBOSE);\r\n            throw new BuildException(ex);\r\n        }\r\n    }','Public Method','ant','org.apache.tools.ant.TaskAdapter',2,5,1),(16,'C','gc','/*******************************************************************************\r\n * Copyright (c) 2000, 2003 IBM Corporation and others.\r\n * All rights reserved. This program and the accompanying materials \r\n * are made available under the terms of the Common Public License v1.0\r\n * which accompanies this distribution, and is available at\r\n * http://www.eclipse.org/legal/cpl-v10.html\r\n * \r\n * Contributors:\r\n *     IBM Corporation - initial API and implementation\r\n *******************************************************************************/\r\npackage org.eclipse.jdt.internal.eval;\r\n\r\nimport java.util.Map;\r\n\r\nimport org.eclipse.jdt.internal.compiler.Compiler;\r\nimport org.eclipse.jdt.internal.compiler.ICompilerRequestor;\r\nimport org.eclipse.jdt.internal.compiler.IErrorHandlingPolicy;\r\nimport org.eclipse.jdt.internal.compiler.IProblemFactory;\r\nimport org.eclipse.jdt.internal.compiler.env.INameEnvironment;\r\n\r\n/**\r\n * A compiler that compiles code snippets. \r\n */\r\npublic class CodeSnippetCompiler extends Compiler {\r\n	\r\n	EvaluationContext evaluationContext;\r\n	int codeSnippetStart;\r\n	int codeSnippetEnd;\r\n	\r\n	/**\r\n	 * Creates a new code snippet compiler initialized with a code snippet parser.\r\n	 */\r\n	public CodeSnippetCompiler(\r\n		INameEnvironment environment,\r\n		IErrorHandlingPolicy policy,\r\n		Map settings,\r\n		ICompilerRequestor requestor,\r\n		IProblemFactory problemFactory,\r\n		EvaluationContext evaluationContext,\r\n		int codeSnippetStart,\r\n		int codeSnippetEnd) {\r\n		super(environment, policy, settings, requestor, problemFactory);\r\n		this.parser =\r\n			new CodeSnippetParser(\r\n				problemReporter,\r\n				evaluationContext,\r\n				this.options.parseLiteralExpressionsAsConstants,\r\n				codeSnippetStart,\r\n				codeSnippetEnd);\r\n		this.parseThreshold = 1;\r\n		// fully parse only the code snippet compilation unit\r\n	}\r\n	\r\n	/* (non-Javadoc)\r\n	 * @see org.eclipse.jdt.internal.compiler.Compiler#initializeParser()\r\n	 */\r\n	public void initializeParser() {\r\n		this.parser =\r\n			new CodeSnippetParser(\r\n				this.problemReporter,\r\n				this.evaluationContext,\r\n				this.options.parseLiteralExpressionsAsConstants,\r\n				this.codeSnippetStart,\r\n				this.codeSnippetEnd);\r\n		}\r\n}','Public Class','eclipse.jdt.core','org.eclipse.jdt.internal.eval.CodeSnippetCompiler',2,7,1);
/*!40000 ALTER TABLE `ms_task` ENABLE KEYS */;
UNLOCK TABLES;
/*!40103 SET TIME_ZONE=@OLD_TIME_ZONE */;

/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;

-- Dump completed on 2020-01-02  5:12:22
