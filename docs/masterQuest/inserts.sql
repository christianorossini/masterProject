-- MySQL dump 10.13  Distrib 5.7.27, for Linux (x86_64)
--
-- Host: localhost    Database: masterquestdb
-- ------------------------------------------------------
-- Server version	5.7.27-0ubuntu0.18.04.1

/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!40101 SET NAMES utf8 */;
/*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */;
/*!40103 SET TIME_ZONE='+00:00' */;
/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;

--
-- Dumping data for table `ms_dtModel`
--

LOCK TABLES `ms_dtModel` WRITE;
/*!40000 ALTER TABLE `ms_dtModel` DISABLE KEYS */;
INSERT INTO `ms_dtModel` VALUES (4,'dtm2.png','/*******************************************************************************\r\n * Copyright (c) 2002, 2003 International Business Machines Corp. and others.\r\n * All rights reserved. This program and the accompanying materials \r\n * are made available under the terms of the Common Public License v1.0 \r\n * which accompanies this distribution, and is available at\r\n * http://www.eclipse.org/legal/cpl-v10.html\r\n * \r\n * Contributors:\r\n *     IBM Corporation - initial API and implementation\r\n ******************************************************************************/\r\npackage org.eclipse.jdt.internal.formatter;\r\n\r\nimport java.util.Map;\r\n\r\nimport org.eclipse.jdt.core.JavaCore;\r\nimport org.eclipse.jdt.core.ToolFactory;\r\nimport org.eclipse.jdt.core.compiler.IProblem;\r\nimport org.eclipse.jdt.core.compiler.IScanner;\r\nimport org.eclipse.jdt.core.compiler.ITerminalSymbols;\r\nimport org.eclipse.jdt.core.compiler.InvalidInputException;\r\nimport org.eclipse.jdt.internal.compiler.AbstractSyntaxTreeVisitorAdapter;\r\nimport org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor;\r\nimport org.eclipse.jdt.internal.compiler.ast.AND_AND_Expression;\r\nimport org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration;\r\nimport org.eclipse.jdt.internal.compiler.ast.AllocationExpression;\r\nimport org.eclipse.jdt.internal.compiler.ast.AnonymousLocalTypeDeclaration;\r\nimport org.eclipse.jdt.internal.compiler.ast.Argument;\r\nimport org.eclipse.jdt.internal.compiler.ast.ArrayAllocationExpression;\r\nimport org.eclipse.jdt.internal.compiler.ast.ArrayInitializer;\r\nimport org.eclipse.jdt.internal.compiler.ast.ArrayQualifiedTypeReference;\r\nimport org.eclipse.jdt.internal.compiler.ast.ArrayReference;\r\nimport org.eclipse.jdt.internal.compiler.ast.ArrayTypeReference;\r\nimport org.eclipse.jdt.internal.compiler.ast.AssertStatement;\r\nimport org.eclipse.jdt.internal.compiler.ast.Assignment;\r\nimport org.eclipse.jdt.internal.compiler.ast.AstNode;\r\nimport org.eclipse.jdt.internal.compiler.ast.BinaryExpression;\r\nimport org.eclipse.jdt.internal.compiler.ast.Block;\r\nimport org.eclipse.jdt.internal.compiler.ast.BreakStatement;\r\nimport org.eclipse.jdt.internal.compiler.ast.CaseStatement;\r\nimport org.eclipse.jdt.internal.compiler.ast.CastExpression;\r\nimport org.eclipse.jdt.internal.compiler.ast.CharLiteral;\r\nimport org.eclipse.jdt.internal.compiler.ast.ClassLiteralAccess;\r\nimport org.eclipse.jdt.internal.compiler.ast.Clinit;\r\nimport org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration;\r\nimport org.eclipse.jdt.internal.compiler.ast.CompoundAssignment;\r\nimport org.eclipse.jdt.internal.compiler.ast.ConditionalExpression;\r\nimport org.eclipse.jdt.internal.compiler.ast.ConstructorDeclaration;\r\nimport org.eclipse.jdt.internal.compiler.ast.ContinueStatement;\r\nimport org.eclipse.jdt.internal.compiler.ast.DoStatement;\r\nimport org.eclipse.jdt.internal.compiler.ast.DoubleLiteral;\r\nimport org.eclipse.jdt.internal.compiler.ast.EmptyStatement;\r\nimport org.eclipse.jdt.internal.compiler.ast.EqualExpression;\r\nimport org.eclipse.jdt.internal.compiler.ast.ExplicitConstructorCall;\r\nimport org.eclipse.jdt.internal.compiler.ast.Expression;\r\nimport org.eclipse.jdt.internal.compiler.ast.FalseLiteral;\r\nimport org.eclipse.jdt.internal.compiler.ast.FieldDeclaration;\r\nimport org.eclipse.jdt.internal.compiler.ast.FieldReference;\r\nimport org.eclipse.jdt.internal.compiler.ast.FloatLiteral;\r\nimport org.eclipse.jdt.internal.compiler.ast.ForStatement;\r\nimport org.eclipse.jdt.internal.compiler.ast.IfStatement;\r\nimport org.eclipse.jdt.internal.compiler.ast.ImportReference;\r\nimport org.eclipse.jdt.internal.compiler.ast.Initializer;\r\nimport org.eclipse.jdt.internal.compiler.ast.InstanceOfExpression;\r\nimport org.eclipse.jdt.internal.compiler.ast.IntLiteral;\r\nimport org.eclipse.jdt.internal.compiler.ast.LabeledStatement;\r\nimport org.eclipse.jdt.internal.compiler.ast.LocalDeclaration;\r\nimport org.eclipse.jdt.internal.compiler.ast.LocalTypeDeclaration;\r\nimport org.eclipse.jdt.internal.compiler.ast.LongLiteral;\r\nimport org.eclipse.jdt.internal.compiler.ast.MemberTypeDeclaration;\r\nimport org.eclipse.jdt.internal.compiler.ast.MessageSend;\r\nimport org.eclipse.jdt.internal.compiler.ast.MethodDeclaration;\r\nimport org.eclipse.jdt.internal.compiler.ast.NullLiteral;\r\nimport org.eclipse.jdt.internal.compiler.ast.OR_OR_Expression;\r\nimport org.eclipse.jdt.internal.compiler.ast.OperatorIds;\r\nimport org.eclipse.jdt.internal.compiler.ast.PostfixExpression;\r\nimport org.eclipse.jdt.internal.compiler.ast.PrefixExpression;\r\nimport org.eclipse.jdt.internal.compiler.ast.QualifiedAllocationExpression;\r\nimport org.eclipse.jdt.internal.compiler.ast.QualifiedNameReference;\r\nimport org.eclipse.jdt.internal.compiler.ast.QualifiedSuperReference;\r\nimport org.eclipse.jdt.internal.compiler.ast.QualifiedThisReference;\r\nimport org.eclipse.jdt.internal.compiler.ast.QualifiedTypeReference;\r\nimport org.eclipse.jdt.internal.compiler.ast.ReturnStatement;\r\nimport org.eclipse.jdt.internal.compiler.ast.SingleNameReference;\r\nimport org.eclipse.jdt.internal.compiler.ast.SingleTypeReference;\r\nimport org.eclipse.jdt.internal.compiler.ast.Statement;\r\nimport org.eclipse.jdt.internal.compiler.ast.StringLiteral;\r\nimport org.eclipse.jdt.internal.compiler.ast.SuperReference;\r\nimport org.eclipse.jdt.internal.compiler.ast.SwitchStatement;\r\nimport org.eclipse.jdt.internal.compiler.ast.SynchronizedStatement;\r\nimport org.eclipse.jdt.internal.compiler.ast.ThisReference;\r\nimport org.eclipse.jdt.internal.compiler.ast.ThrowStatement;\r\nimport org.eclipse.jdt.internal.compiler.ast.TrueLiteral;\r\nimport org.eclipse.jdt.internal.compiler.ast.TryStatement;\r\nimport org.eclipse.jdt.internal.compiler.ast.TypeDeclaration;\r\nimport org.eclipse.jdt.internal.compiler.ast.TypeReference;\r\nimport org.eclipse.jdt.internal.compiler.ast.UnaryExpression;\r\nimport org.eclipse.jdt.internal.compiler.ast.WhileStatement;\r\nimport org.eclipse.jdt.internal.compiler.impl.Constant;\r\nimport org.eclipse.jdt.internal.compiler.lookup.BlockScope;\r\nimport org.eclipse.jdt.internal.compiler.lookup.ClassScope;\r\nimport org.eclipse.jdt.internal.compiler.lookup.CompilationUnitScope;\r\nimport org.eclipse.jdt.internal.compiler.lookup.CompilerModifiers;\r\nimport org.eclipse.jdt.internal.compiler.lookup.MethodScope;\r\nimport org.eclipse.jdt.internal.formatter.align.Alignment;\r\nimport org.eclipse.jdt.internal.formatter.align.AlignmentException;\r\n\r\n/**\r\n * This class is responsible for formatting a valid java source code.\r\n * @since 2.1\r\n */\r\n// TODO add line splitting for all remaining expression and statements\r\n// TODO find a way to handle complex boolean expression\r\n// TODO Add the ICodeFormatter extension point once the UI has fixed their code\r\n/*\r\n   <extension\r\n         id=\"org.eclipse.jdt.core.newformatter.codeformatter\"\r\n         name=\"org.eclipse.jdt.core.newformatter.codeformatter\"\r\n         point=\"org.eclipse.jdt.core.codeFormatter\">\r\n      <codeFormatter\r\n            class=\"org.eclipse.jdt.internal.formatter.CodeFormatterVisitor\">\r\n      </codeFormatter>\r\n   </extension>\r\n*/\r\npublic class CodeFormatterVisitor extends AbstractSyntaxTreeVisitorAdapter {\r\n\r\n	public static class MultiFieldDeclaration extends FieldDeclaration {\r\n		\r\n		FieldDeclaration[] declarations;\r\n		\r\n		MultiFieldDeclaration(FieldDeclaration[] declarations){\r\n			this.declarations = declarations;\r\n			this.modifiers = declarations[0].modifiers; \r\n		}\r\n	}\r\n	\r\n	public static boolean DEBUG = false;\r\n	private static final int NO_MODIFIERS = 0;\r\n	/*\r\n	 * Set of expected tokens type for a single type reference.\r\n	 * This array needs to be SORTED.\r\n	 */\r\n	private static final int[] SINGLETYPEREFERENCE_EXPECTEDTOKENS = new int[] {\r\n		ITerminalSymbols.TokenNameIdentifier,\r\n		ITerminalSymbols.TokenNameboolean,\r\n		ITerminalSymbols.TokenNamebyte,\r\n		ITerminalSymbols.TokenNamechar,\r\n		ITerminalSymbols.TokenNamedouble,\r\n		ITerminalSymbols.TokenNamefloat,\r\n		ITerminalSymbols.TokenNameint,\r\n		ITerminalSymbols.TokenNamelong,\r\n		ITerminalSymbols.TokenNameshort,\r\n		ITerminalSymbols.TokenNamevoid\r\n	};\r\n	private int chunkKind;\r\n	public int lastLocalDeclarationSourceStart;\r\n	private IScanner localScanner;\r\n	public FormattingPreferences preferences;\r\n	public Scribe scribe;\r\n	\r\n	/*\r\n	 * TODO: See how to choose the formatter\'s options. The extension point is calling\r\n	 * this constructor, but then there is no way to initialize the option used by the formatter.\r\n	 */ \r\n	public CodeFormatterVisitor() {\r\n		this(FormattingPreferences.getSunSetttings(), JavaCore.getOptions());\r\n	}\r\n\r\n	public CodeFormatterVisitor(FormattingPreferences preferences, Map settings) {\r\n		if (settings != null) {\r\n			String compiler_source = (String) settings.get(JavaCore.COMPILER_SOURCE);\r\n			if (compiler_source == null) {\r\n				this.localScanner = ToolFactory.createScanner(false, false, false, false);\r\n			} else {\r\n				this.localScanner = ToolFactory.createScanner(false, false, false, compiler_source);\r\n			}\r\n		} else {\r\n			this.localScanner = ToolFactory.createScanner(false, false, false, false);\r\n		}\r\n		// TODO set the java core options when common preferences are changed\r\n//		convertOldOptionsToPreferences(settings, preferences);\r\n		this.preferences = preferences;\r\n		this.scribe = new Scribe(this, settings);\r\n	}\r\n	\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#acceptProblem(org.eclipse.jdt.core.compiler.IProblem)\r\n	 */\r\n	public void acceptProblem(IProblem problem) {\r\n		super.acceptProblem(problem);\r\n	}\r\n\r\n	private BinaryExpressionFragmentBuilder buildFragments(BinaryExpression binaryExpression, BlockScope scope) {\r\n		BinaryExpressionFragmentBuilder builder = new BinaryExpressionFragmentBuilder();\r\n		\r\n		switch((binaryExpression.bits & AstNode.OperatorMASK) >> AstNode.OperatorSHIFT) {\r\n			case OperatorIds.AND_AND :\r\n				binaryExpression.left.traverse(builder, scope);\r\n				builder.operatorsList.add(new Integer(ITerminalSymbols.TokenNameAND_AND));\r\n				binaryExpression.right.traverse(builder, scope);\r\n				break;\r\n			case OperatorIds.OR_OR :\r\n				binaryExpression.left.traverse(builder, scope);\r\n				builder.operatorsList.add(new Integer(ITerminalSymbols.TokenNameOR_OR));\r\n				binaryExpression.right.traverse(builder, scope);\r\n				break;\r\n		}\r\n\r\n		return builder;\r\n	}\r\n\r\n	public boolean checkChunkStart(int kind) {\r\n		if (this.chunkKind != kind) {\r\n			this.chunkKind = kind;\r\n			return true;\r\n		}\r\n		return false;\r\n	}\r\n	\r\n	private AstNode[] computeMergedMemberDeclarations(TypeDeclaration typeDeclaration){\r\n		\r\n		int fieldIndex = 0, fieldCount = (typeDeclaration.fields == null) ? 0 : typeDeclaration.fields.length;\r\n		FieldDeclaration field = fieldCount == 0 ? null : typeDeclaration.fields[fieldIndex];\r\n		int fieldStart = field == null ? Integer.MAX_VALUE : field.declarationSourceStart;\r\n\r\n		int methodIndex = 0, methodCount = (typeDeclaration.methods == null) ? 0 : typeDeclaration.methods.length;\r\n		AbstractMethodDeclaration method = methodCount == 0 ? null : typeDeclaration.methods[methodIndex];\r\n		int methodStart = method == null ? Integer.MAX_VALUE : method.declarationSourceStart;\r\n\r\n		int typeIndex = 0, typeCount = (typeDeclaration.memberTypes == null) ? 0 : typeDeclaration.memberTypes.length;\r\n		MemberTypeDeclaration type = typeCount == 0 ? null : typeDeclaration.memberTypes[typeIndex];\r\n		int typeStart = type == null ? Integer.MAX_VALUE : type.declarationSourceStart;\r\n	\r\n		final int memberLength = fieldCount+methodCount+typeCount;\r\n		AstNode[] members = new AstNode[memberLength];\r\n		if (memberLength != 0) {\r\n			int index = 0;\r\n			int previousFieldStart = -1;\r\n			do {\r\n				if (fieldStart < methodStart && fieldStart < typeStart) {\r\n					// next member is a field\r\n					if (fieldStart == previousFieldStart){ \r\n						AstNode previousMember = members[index - 1];\r\n						if (previousMember instanceof MultiFieldDeclaration) {\r\n							MultiFieldDeclaration multiField = (MultiFieldDeclaration) previousMember;\r\n							int length = multiField.declarations.length;\r\n							System.arraycopy(multiField.declarations, 0, multiField.declarations=new FieldDeclaration[length+1], 0, length);\r\n							multiField.declarations[length] = (FieldDeclaration) field;\r\n						} else {\r\n							members[index - 1] = new MultiFieldDeclaration(new FieldDeclaration[]{ (FieldDeclaration)previousMember, field});\r\n						}\r\n					} else {\r\n						members[index++] = field;					\r\n					}\r\n					previousFieldStart = fieldStart;\r\n					if (++fieldIndex < fieldCount) { // find next field if any\r\n						fieldStart = (field = typeDeclaration.fields[fieldIndex]).declarationSourceStart;\r\n					} else {\r\n						fieldStart = Integer.MAX_VALUE;\r\n					}\r\n				} else if (methodStart < fieldStart && methodStart < typeStart) {\r\n					// next member is a method\r\n					if (!method.isDefaultConstructor() && !method.isClinit()) {\r\n						members[index++] = method;					\r\n					}\r\n					if (++methodIndex < methodCount) { // find next method if any\r\n						methodStart = (method = typeDeclaration.methods[methodIndex]).declarationSourceStart;\r\n					} else {\r\n						methodStart = Integer.MAX_VALUE;\r\n					}\r\n				} else {\r\n					// next member is a type\r\n					members[index++] = type;\r\n					if (++typeIndex < typeCount) { // find next type if any\r\n						typeStart = (type = typeDeclaration.memberTypes[typeIndex]).declarationSourceStart;\r\n					} else {\r\n						typeStart = Integer.MAX_VALUE;\r\n					}\r\n				}\r\n			} while ((fieldIndex < fieldCount) || (typeIndex < typeCount) || (methodIndex < methodCount));\r\n			\r\n			if (members.length != index) {\r\n				System.arraycopy(members, 0, members=new AstNode[index], 0, index);\r\n			}\r\n		}\r\n		return members;\r\n	}\r\n\r\n	void convertOldOptionsToPreferences(Map oldOptions, FormattingPreferences formattingPreferences) {\r\n		if (oldOptions == null) {\r\n			return;\r\n		}\r\n		Object[] entries = oldOptions.entrySet().toArray();\r\n		\r\n		for (int i = 0, max = entries.length; i < max; i++){\r\n			Map.Entry entry = (Map.Entry)entries[i];\r\n			if (!(entry.getKey() instanceof String)) continue;\r\n			if (!(entry.getValue() instanceof String)) continue;\r\n			String optionID = (String) entry.getKey();\r\n			String optionValue = (String) entry.getValue();\r\n			\r\n			if(optionID.equals(JavaCore.FORMATTER_NEWLINE_OPENING_BRACE)){\r\n				if (optionValue.equals(JavaCore.INSERT)){\r\n					formattingPreferences.anonymous_type_declaration_brace_position = FormattingPreferences.NEXT_LINE;\r\n					formattingPreferences.type_declaration_brace_position = FormattingPreferences.NEXT_LINE;\r\n					formattingPreferences.method_declaration_brace_position = FormattingPreferences.NEXT_LINE;\r\n					formattingPreferences.block_brace_position = FormattingPreferences.NEXT_LINE;\r\n					formattingPreferences.switch_brace_position = FormattingPreferences.NEXT_LINE;\r\n				} else if (optionValue.equals(JavaCore.DO_NOT_INSERT)){\r\n					formattingPreferences.anonymous_type_declaration_brace_position = FormattingPreferences.END_OF_LINE;\r\n					formattingPreferences.type_declaration_brace_position = FormattingPreferences.END_OF_LINE;\r\n					formattingPreferences.method_declaration_brace_position = FormattingPreferences.END_OF_LINE;\r\n					formattingPreferences.block_brace_position = FormattingPreferences.END_OF_LINE;\r\n					formattingPreferences.switch_brace_position = FormattingPreferences.END_OF_LINE;\r\n				}\r\n				continue;\r\n			}\r\n			if(optionID.equals(JavaCore.FORMATTER_NEWLINE_CONTROL)) {\r\n				if (optionValue.equals(JavaCore.INSERT)){\r\n					formattingPreferences.insert_new_line_in_control_statements = true;\r\n				} else if (optionValue.equals(JavaCore.DO_NOT_INSERT)){\r\n					formattingPreferences.insert_new_line_in_control_statements = false;\r\n				}\r\n				continue;\r\n			}\r\n			if(optionID.equals(JavaCore.FORMATTER_CLEAR_BLANK_LINES)) {\r\n				if (optionValue.equals(JavaCore.CLEAR_ALL)){\r\n					formattingPreferences.number_of_empty_lines_to_preserve = 0;\r\n				} else if (optionValue.equals(JavaCore.PRESERVE_ONE)){\r\n					formattingPreferences.number_of_empty_lines_to_preserve = 1;\r\n				}\r\n				continue;\r\n			}\r\n			if(optionID.equals(JavaCore.FORMATTER_NEWLINE_ELSE_IF)){\r\n				if (optionValue.equals(JavaCore.INSERT)){\r\n					formattingPreferences.compact_else_if = false;\r\n				} else if (optionValue.equals(JavaCore.DO_NOT_INSERT)){\r\n					formattingPreferences.compact_else_if = true;\r\n				}\r\n				continue;\r\n			}\r\n			if(optionID.equals(JavaCore.FORMATTER_NEWLINE_EMPTY_BLOCK)){\r\n				if (optionValue.equals(JavaCore.INSERT)){\r\n					formattingPreferences.insert_new_line_in_empty_anonymous_type_declaration = true;\r\n					formattingPreferences.insert_new_line_in_empty_type_declaration = true;\r\n					formattingPreferences.insert_new_line_in_empty_method_body = true;\r\n					formattingPreferences.insert_new_line_in_empty_block = true;\r\n				} else if (optionValue.equals(JavaCore.DO_NOT_INSERT)){\r\n					formattingPreferences.insert_new_line_in_empty_anonymous_type_declaration = false;\r\n					formattingPreferences.insert_new_line_in_empty_type_declaration = false;\r\n					formattingPreferences.insert_new_line_in_empty_method_body = false;\r\n					formattingPreferences.insert_new_line_in_empty_block = false;\r\n				}\r\n				continue;\r\n			}\r\n			if(optionID.equals(JavaCore.FORMATTER_LINE_SPLIT)){\r\n				try {\r\n					int val = Integer.parseInt(optionValue);\r\n					if (val >= 0) {\r\n						formattingPreferences.page_width = val;\r\n					}\r\n				} catch(NumberFormatException e){\r\n				}\r\n			}\r\n			if(optionID.equals(JavaCore.FORMATTER_COMPACT_ASSIGNMENT)){\r\n				if (optionValue.equals(JavaCore.COMPACT)){\r\n					formattingPreferences.insert_space_before_assignment_operators = false;\r\n				} else if (optionValue.equals(JavaCore.NORMAL)){\r\n					formattingPreferences.insert_space_before_assignment_operators = true;\r\n				}\r\n				continue;\r\n			}\r\n			if(optionID.equals(JavaCore.FORMATTER_TAB_CHAR)){\r\n				if (optionValue.equals(JavaCore.TAB)){\r\n					formattingPreferences.use_tab = true;\r\n				} else if (optionValue.equals(JavaCore.SPACE)){\r\n					formattingPreferences.use_tab = false;\r\n				}\r\n				continue;\r\n			}\r\n			if(optionID.equals(JavaCore.FORMATTER_TAB_SIZE)){\r\n				try {\r\n					int val = Integer.parseInt(optionValue);\r\n					if (val > 0) {\r\n						formattingPreferences.tab_size = val;\r\n					}\r\n				} catch(NumberFormatException e){\r\n				}\r\n			}\r\n			if(optionID.equals(JavaCore.FORMATTER_SPACE_CASTEXPRESSION)){\r\n				if (optionValue.equals(JavaCore.INSERT)){\r\n					formattingPreferences.insert_space_after_closing_paren_in_cast = true;\r\n				} else if (optionValue.equals(JavaCore.DO_NOT_INSERT)){\r\n					formattingPreferences.insert_space_after_closing_paren_in_cast = false;\r\n				}\r\n				continue;\r\n			}		\r\n		}		\r\n	}\r\n\r\n	private boolean dumpBinaryExpression(\r\n		BinaryExpression binaryExpression,\r\n		int operator,\r\n		BlockScope scope) {\r\n\r\n		final int numberOfParens = (binaryExpression.bits & AstNode.ParenthesizedMASK) >> AstNode.ParenthesizedSHIFT;\r\n\r\n		if (numberOfParens > 0) {\r\n			manageOpeningParenthesizedExpression(binaryExpression, numberOfParens);\r\n		}	\r\n		BinaryExpressionFragmentBuilder builder = buildFragments(binaryExpression, scope);\r\n		final int fragmentsSize = builder.size();\r\n		\r\n		if (fragmentsSize > 1) {\r\n			Alignment binaryExpressionAlignment = this.scribe.createAlignment(\"binaryExpressionAlignment\", this.preferences.binary_expression_alignment, fragmentsSize, this.scribe.scanner.currentPosition); //$NON-NLS-1$\r\n			this.scribe.enterAlignment(binaryExpressionAlignment);\r\n			boolean ok = false;\r\n			AstNode[] fragments = builder.fragments();\r\n			int[] operators = builder.operators();\r\n			do {\r\n				try {\r\n					for (int i = 0; i < fragmentsSize - 1; i++) {\r\n						AstNode fragment = fragments[i];\r\n						fragment.traverse(this, scope);\r\n						this.scribe.alignFragment(binaryExpressionAlignment, i);\r\n						this.scribe.printNextToken(operators[i], this.preferences.insert_space_before_binary_operator);\r\n						if (this.preferences.insert_space_after_binary_operator) {\r\n							this.scribe.space();\r\n						}						\r\n					}\r\n					fragments[fragmentsSize - 1].traverse(this, scope);\r\n					ok = true;\r\n				} catch(AlignmentException e){\r\n					this.scribe.redoAlignment(e);\r\n				}\r\n			} while (!ok);		\r\n			this.scribe.exitAlignment(binaryExpressionAlignment, true);\r\n		} else {\r\n			binaryExpression.left.traverse(this, scope);\r\n			this.scribe.printNextToken(operator, this.preferences.insert_space_before_binary_operator);\r\n			if (this.preferences.insert_space_after_binary_operator) {\r\n				this.scribe.space();\r\n			}\r\n			binaryExpression.right.traverse(this, scope);\r\n		}	\r\n		if (numberOfParens > 0) {\r\n			manageClosingParenthesizedExpression(binaryExpression, numberOfParens);\r\n		}\r\n		return false;\r\n	}\r\n\r\n	private String failedToFormat(final char[] compilationUnitSource) {\r\n		StringBuffer buffer = new StringBuffer(this.scribe.formattedSource());\r\n		buffer.append(compilationUnitSource, this.scribe.scanner.getCurrentTokenEndPosition(), this.scribe.scannerEndPosition - this.scribe.scanner.getCurrentTokenEndPosition());\r\n		System.out.println(\"COULD NOT FORMAT \\n\" + this.scribe.scanner); //$NON-NLS-1$\r\n		if (DEBUG) {\r\n			System.out.println(this.scribe);\r\n		}\r\n		return buffer.toString();\r\n	}\r\n\r\n	private void format(\r\n		AbstractMethodDeclaration methodDeclaration,\r\n		ClassScope scope,\r\n		boolean isChunkStart) {\r\n\r\n		final int newLineBeforeChunk = isChunkStart ? this.preferences.blank_lines_before_new_chunk : 0;\r\n		if (newLineBeforeChunk > 0) {\r\n			this.scribe.printNewLines(newLineBeforeChunk);\r\n		}\r\n		final int newLinesBeforeMethod = this.preferences.blank_lines_before_method;\r\n		if (newLinesBeforeMethod > 0) {\r\n			this.scribe.printNewLines(newLinesBeforeMethod);\r\n		}\r\n		methodDeclaration.traverse(this, scope);\r\n	}\r\n	\r\n	private void format(FieldDeclaration fieldDeclaration, IAbstractSyntaxTreeVisitor visitor, MethodScope scope, boolean isChunkStart) {\r\n		\r\n		int newLineBeforeChunk = isChunkStart ? this.preferences.blank_lines_before_new_chunk : 0;\r\n		if (newLineBeforeChunk > 0) {\r\n			this.scribe.printNewLines(newLineBeforeChunk);\r\n		}\r\n		final int newLinesBeforeField = this.preferences.blank_lines_before_field;\r\n		if (newLinesBeforeField > 0) {\r\n			this.scribe.printNewLines(newLinesBeforeField);\r\n		}\r\n		Alignment fieldAlignment = this.scribe.getAlignment(\"typeMembers\");	//$NON-NLS-1$\r\n\r\n		if (fieldDeclaration.modifiers != NO_MODIFIERS) {\r\n			this.scribe.printModifiers();\r\n		}\r\n		/*\r\n		 * Field type\r\n		 */\r\n		this.scribe.alignFragment(fieldAlignment, 0);\r\n\r\n		fieldDeclaration.type.traverse(this, scope);\r\n		\r\n		/*\r\n		 * Field name\r\n		 */\r\n		this.scribe.alignFragment(fieldAlignment, 1);\r\n\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameIdentifier, true);\r\n\r\n		/*\r\n		 * Check for extra dimensions\r\n		 */\r\n		int extraDimensions = getExtraDimension();\r\n		if (extraDimensions != 0) {\r\n			 for (int i = 0; i < extraDimensions; i++) {\r\n			 	this.scribe.printNextToken(ITerminalSymbols.TokenNameLBRACKET);\r\n			 	this.scribe.printNextToken(ITerminalSymbols.TokenNameRBRACKET);\r\n			 }\r\n		}\r\n	\r\n		/*\r\n		 * Field initialization\r\n		 */\r\n		if (fieldDeclaration.initialization != null) {\r\n			this.scribe.alignFragment(fieldAlignment, 2);\r\n			this.scribe.printNextToken(ITerminalSymbols.TokenNameEQUAL, this.preferences.insert_space_before_assignment_operators);\r\n			if (this.preferences.insert_space_after_assignment_operators) {\r\n				this.scribe.space();\r\n			}\r\n			fieldDeclaration.initialization.traverse(this, scope);\r\n		}\r\n		\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameSEMICOLON, this.preferences.insert_space_before_semicolon);\r\n\r\n		if (fieldDeclaration.initialization == null) {\r\n			this.scribe.alignFragment(fieldAlignment, 2);\r\n		}\r\n\r\n		if (fieldAlignment != null) {\r\n			this.scribe.alignFragment(fieldAlignment, 3);\r\n			this.scribe.printTrailingComment();\r\n			this.scribe.printNewLine();\r\n			this.scribe.exitAlignment(fieldAlignment, false);\r\n		} else {\r\n			this.scribe.space();\r\n			this.scribe.printTrailingComment();\r\n			this.scribe.printNewLine();\r\n		}\r\n	}\r\n\r\n	private void format(\r\n		MemberTypeDeclaration memberTypeDeclaration,\r\n		ClassScope scope,\r\n		boolean isChunkStart) {\r\n\r\n		int newLineBeforeChunk = isChunkStart ? this.preferences.blank_lines_before_new_chunk : 0;\r\n		if (newLineBeforeChunk > 0) {\r\n			this.scribe.printNewLines(newLineBeforeChunk);\r\n		}\r\n		final int newLinesBeforeMember = this.preferences.blank_lines_before_member_type;\r\n		if (newLinesBeforeMember > 0) {\r\n			this.scribe.printNewLines(newLinesBeforeMember);\r\n		}\r\n		memberTypeDeclaration.traverse(this, scope);\r\n	}\r\n	\r\n	private void format(MultiFieldDeclaration multiFieldDeclaration, IAbstractSyntaxTreeVisitor visitor, MethodScope scope, boolean isChunkStart) {\r\n\r\n		int newLineBeforeChunk = isChunkStart ? this.preferences.blank_lines_before_new_chunk : 0;\r\n		if (newLineBeforeChunk > 0) {\r\n			this.scribe.printNewLines(newLineBeforeChunk);\r\n		}\r\n		final int newLinesBeforeField = this.preferences.blank_lines_before_field;\r\n		if (newLinesBeforeField > 0) {\r\n			this.scribe.printNewLines(newLinesBeforeField);\r\n		}\r\n		Alignment fieldAlignment = this.scribe.getAlignment(\"typeMembers\");	//$NON-NLS-1$\r\n\r\n		if (multiFieldDeclaration.declarations[0].modifiers != NO_MODIFIERS) {\r\n			this.scribe.printModifiers();\r\n		}\r\n		this.scribe.alignFragment(fieldAlignment, 0);\r\n\r\n		multiFieldDeclaration.declarations[0].type.traverse(this, scope);\r\n\r\n		for (int i = 0, length = multiFieldDeclaration.declarations.length; i < length; i++) {\r\n			FieldDeclaration fieldDeclaration = multiFieldDeclaration.declarations[i];\r\n			/*\r\n			 * Field name\r\n			 */\r\n			if (i == 0) {\r\n				this.scribe.alignFragment(fieldAlignment, 1);\r\n			}\r\n			this.scribe.printNextToken(ITerminalSymbols.TokenNameIdentifier, true);\r\n	\r\n			/*\r\n			 * Check for extra dimensions\r\n			 */\r\n			int extraDimensions = getExtraDimension();\r\n			if (extraDimensions != 0) {\r\n				 for (int index = 0; index < extraDimensions; index++) {\r\n				 	this.scribe.printNextToken(ITerminalSymbols.TokenNameLBRACKET);\r\n				 	this.scribe.printNextToken(ITerminalSymbols.TokenNameRBRACKET);\r\n				 }\r\n			}\r\n		\r\n			/*\r\n			 * Field initialization\r\n			 */\r\n			if (fieldDeclaration.initialization != null) {\r\n				if (i == 0) {\r\n					this.scribe.alignFragment(fieldAlignment, 2);\r\n				}\r\n				this.scribe.printNextToken(ITerminalSymbols.TokenNameEQUAL, this.preferences.insert_space_before_assignment_operators);\r\n				if (this.preferences.insert_space_after_assignment_operators) {\r\n					this.scribe.space();\r\n				}\r\n				fieldDeclaration.initialization.traverse(this, scope);\r\n			}\r\n			\r\n			if (i != length - 1) {\r\n				if (i == 0 && fieldDeclaration.initialization == null) {\r\n					this.scribe.alignFragment(fieldAlignment, 2);\r\n				}				\r\n				this.scribe.printNextToken(ITerminalSymbols.TokenNameCOMMA, this.preferences.insert_space_before_comma_in_multiple_field_declarations);\r\n				if (this.preferences.insert_space_after_comma_in_multiple_field_declarations) {\r\n					this.scribe.space();\r\n				}\r\n			} else {\r\n				this.scribe.printNextToken(ITerminalSymbols.TokenNameSEMICOLON, this.preferences.insert_space_before_semicolon);\r\n				\r\n				this.scribe.alignFragment(fieldAlignment, 3);\r\n				this.scribe.printTrailingComment();\r\n				this.scribe.printNewLine();\r\n			}\r\n		}\r\n		if (fieldAlignment != null) {\r\n			this.scribe.exitAlignment(fieldAlignment, false);\r\n		}\r\n	}\r\n	\r\n	/**\r\n	 * @see org.eclipse.jdt.core.ICodeFormatter#format(java.lang.String, int, int, java.lang.String)\r\n	 */\r\n	public String format(String string, int[] positions, AstNode[] nodes) {\r\n		// reset the scribe\r\n		this.scribe.reset(positions);\r\n		\r\n		long startTime = System.currentTimeMillis();\r\n\r\n		final char[] compilationUnitSource = string.toCharArray();\r\n		\r\n		this.scribe.scanner.setSource(compilationUnitSource);\r\n		this.localScanner.setSource(compilationUnitSource);\r\n		this.scribe.scannerEndPosition = compilationUnitSource.length;\r\n		this.scribe.scanner.resetTo(0, this.scribe.scannerEndPosition);\r\n		if (nodes == null) {\r\n			return string;\r\n		}\r\n\r\n		this.lastLocalDeclarationSourceStart = 0;\r\n		try {\r\n			if (nodes != null) {\r\n				formatClassBodyDeclarations(nodes);\r\n			}\r\n		} catch(AbortFormatting e){\r\n			return failedToFormat(compilationUnitSource);\r\n		}\r\n		if (DEBUG){\r\n			System.out.println(\"Formatting time: \" + (System.currentTimeMillis() - startTime));  //$NON-NLS-1$\r\n		}\r\n		return this.scribe.toString();\r\n	}\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.core.ICodeFormatter#format(java.lang.String, int, int, java.lang.String)\r\n	 */\r\n	public String format(String string, int[] positions, CompilationUnitDeclaration compilationUnitDeclaration) {\r\n		// reset the scribe\r\n		this.scribe.reset(positions);\r\n		\r\n		long startTime = System.currentTimeMillis();\r\n\r\n		final char[] compilationUnitSource = string.toCharArray();\r\n		\r\n		this.scribe.scanner.setSource(compilationUnitSource);\r\n		this.localScanner.setSource(compilationUnitSource);\r\n		this.scribe.scannerEndPosition = compilationUnitSource.length;\r\n		this.scribe.scanner.resetTo(0, this.scribe.scannerEndPosition);\r\n		if (compilationUnitDeclaration == null || compilationUnitDeclaration.ignoreFurtherInvestigation) {\r\n			return string;\r\n		}\r\n\r\n		this.lastLocalDeclarationSourceStart = 0;\r\n		try {\r\n			compilationUnitDeclaration.traverse(this, compilationUnitDeclaration.scope);\r\n		} catch(AbortFormatting e){\r\n			return failedToFormat(compilationUnitSource);\r\n		}\r\n		if (DEBUG){\r\n			System.out.println(\"Formatting time: \" + (System.currentTimeMillis() - startTime));  //$NON-NLS-1$\r\n		}\r\n		return this.scribe.toString();\r\n	}\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.core.ICodeFormatter#format(java.lang.String, int, int, java.lang.String)\r\n	 */\r\n	public String format(String string, int[] positions, ConstructorDeclaration constructorDeclaration) {\r\n		// reset the scribe\r\n		this.scribe.reset(positions);\r\n		\r\n		long startTime = System.currentTimeMillis();\r\n\r\n		final char[] compilationUnitSource = string.toCharArray();\r\n		\r\n		this.scribe.scanner.setSource(compilationUnitSource);\r\n		this.localScanner.setSource(compilationUnitSource);\r\n		this.scribe.scannerEndPosition = compilationUnitSource.length;\r\n		this.scribe.scanner.resetTo(0, this.scribe.scannerEndPosition);\r\n		if (constructorDeclaration == null) {\r\n			return string;\r\n		}\r\n\r\n		this.lastLocalDeclarationSourceStart = 0;\r\n		try {\r\n			ExplicitConstructorCall explicitConstructorCall = constructorDeclaration.constructorCall;\r\n			if (explicitConstructorCall != SuperReference.implicitSuperConstructorCall()) {\r\n				explicitConstructorCall.traverse(this, null);\r\n			}\r\n			Statement[] statements = constructorDeclaration.statements;\r\n			if (statements != null) {\r\n				formatStatements(null, statements);\r\n			}\r\n			this.scribe.printComment();\r\n		} catch(AbortFormatting e){\r\n			return failedToFormat(compilationUnitSource);\r\n		}\r\n		if (DEBUG){\r\n			System.out.println(\"Formatting time: \" + (System.currentTimeMillis() - startTime));  //$NON-NLS-1$\r\n		}\r\n		return this.scribe.toString();\r\n	}\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.core.ICodeFormatter#format(java.lang.String, int, int, java.lang.String)\r\n	 */\r\n	public String format(String string, int[] positions, Expression expression) {\r\n		// reset the scribe\r\n		this.scribe.reset(positions);\r\n		\r\n		long startTime = System.currentTimeMillis();\r\n\r\n		final char[] compilationUnitSource = string.toCharArray();\r\n		\r\n		this.scribe.scanner.setSource(compilationUnitSource);\r\n		this.localScanner.setSource(compilationUnitSource);\r\n		this.scribe.scannerEndPosition = compilationUnitSource.length;\r\n		this.scribe.scanner.resetTo(0, this.scribe.scannerEndPosition);\r\n		if (expression == null) {\r\n			return string;\r\n		}\r\n\r\n		this.lastLocalDeclarationSourceStart = 0;\r\n		try {\r\n			expression.traverse(this, null);\r\n			this.scribe.printComment();\r\n		} catch(AbortFormatting e){\r\n			return failedToFormat(compilationUnitSource);\r\n		}\r\n		if (DEBUG){\r\n			System.out.println(\"Formatting time: \" + (System.currentTimeMillis() - startTime));  //$NON-NLS-1$\r\n		}\r\n		return this.scribe.toString();\r\n	}\r\n	\r\n	private void format(TypeDeclaration typeDeclaration){\r\n\r\n		if (typeDeclaration.modifiers != NO_MODIFIERS) {\r\n			this.scribe.printModifiers();\r\n		} else {\r\n			this.scribe.printComment();\r\n		}\r\n		/*\r\n		 * Type name\r\n		 */\r\n		if (typeDeclaration.isInterface()) {\r\n			this.scribe.printNextToken(ITerminalSymbols.TokenNameinterface, true); \r\n		} else {\r\n			this.scribe.printNextToken(ITerminalSymbols.TokenNameclass, true); \r\n		}\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameIdentifier, true); \r\n\r\n		/* \r\n		 * Superclass \r\n		 */\r\n		final TypeReference superclass = typeDeclaration.superclass;\r\n		if (superclass != null) {\r\n			Alignment superclassAlignment =this.scribe.createAlignment(\r\n					\"superclass\", //$NON-NLS-1$\r\n					this.preferences.type_declaration_superclass_alignment,\r\n					2,\r\n					this.scribe.scanner.currentPosition);\r\n			this.scribe.enterAlignment(superclassAlignment);\r\n			boolean ok = false;\r\n			do {\r\n				try {\r\n					this.scribe.alignFragment(superclassAlignment, 0);\r\n					this.scribe.printNextToken(ITerminalSymbols.TokenNameextends, true);\r\n					this.scribe.alignFragment(superclassAlignment, 1);\r\n					this.scribe.space();\r\n					superclass.traverse(this, typeDeclaration.scope);\r\n					ok = true;\r\n				} catch (AlignmentException e) {\r\n					this.scribe.redoAlignment(e);\r\n				}\r\n			} while (!ok);\r\n			this.scribe.exitAlignment(superclassAlignment, true); \r\n		}\r\n\r\n		/* \r\n		 * Super Interfaces \r\n		 */\r\n		final TypeReference[] superInterfaces = typeDeclaration.superInterfaces;\r\n		if (superInterfaces != null) {\r\n			\r\n			int superInterfaceLength = superInterfaces.length;\r\n			Alignment interfaceAlignment =this.scribe.createAlignment(\r\n					\"superInterfaces\",//$NON-NLS-1$\r\n					this.preferences.type_declaration_superinterfaces_alignment,\r\n					superInterfaceLength+1,  // implements token is first fragment\r\n					this.scribe.scanner.currentPosition);\r\n			this.scribe.enterAlignment(interfaceAlignment);\r\n			boolean ok = false;\r\n			do {\r\n				try {\r\n					this.scribe.alignFragment(interfaceAlignment, 0);\r\n					if (typeDeclaration.isInterface()) {\r\n						this.scribe.printNextToken(ITerminalSymbols.TokenNameextends, true);\r\n					} else  {\r\n						this.scribe.printNextToken(ITerminalSymbols.TokenNameimplements, true);\r\n					}\r\n					for (int i = 0; i < superInterfaceLength; i++) {\r\n						if (i > 0) {\r\n							this.scribe.printNextToken(ITerminalSymbols.TokenNameCOMMA, this.preferences.insert_space_before_comma_in_superinterfaces);\r\n							this.scribe.alignFragment(interfaceAlignment, i+1);\r\n							if (this.preferences.insert_space_after_comma_in_superinterfaces) {\r\n								this.scribe.space();\r\n							}\r\n							superInterfaces[i].traverse(this, typeDeclaration.scope);\r\n						} else {\r\n							this.scribe.alignFragment(interfaceAlignment, i+1);\r\n							this.scribe.space();\r\n							superInterfaces[i].traverse(this, typeDeclaration.scope);\r\n						}\r\n					}\r\n					ok = true;\r\n				} catch (AlignmentException e) {\r\n					this.scribe.redoAlignment(e);\r\n				}\r\n			} while (!ok);\r\n			this.scribe.exitAlignment(interfaceAlignment, true);\r\n		}\r\n\r\n		/*\r\n		 * Type body\r\n		 */\r\n		String class_declaration_brace = this.preferences.type_declaration_brace_position;\r\n\r\n		formatTypeOpeningBrace(class_declaration_brace, this.preferences.insert_space_before_type_open_brace, typeDeclaration);\r\n		\r\n		if (this.preferences.indent_body_declarations_compare_to_type_header) {\r\n			this.scribe.indent();\r\n		}\r\n\r\n		formatTypeMembers(typeDeclaration);\r\n\r\n		this.scribe.printComment();\r\n		\r\n		if (this.preferences.indent_body_declarations_compare_to_type_header) {\r\n			this.scribe.unIndent();\r\n		}\r\n		\r\n		if (this.preferences.insert_new_line_in_empty_type_declaration) {\r\n			this.scribe.printNewLine();\r\n		}\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameRBRACE);\r\n		this.scribe.printTrailingComment();\r\n		if (class_declaration_brace.equals(FormattingPreferences.NEXT_LINE_SHIFTED)) {\r\n			this.scribe.unIndent();\r\n		}\r\n	}\r\n\r\n	/*\r\n	 * Merged traversal of member (types, fields, methods)\r\n	 */\r\n	private void formatClassBodyDeclarations(AstNode[] nodes) {\r\n		final int FIELD = 1, METHOD = 2, TYPE = 3;\r\n		\r\n		Alignment memberAlignment = this.scribe.createAlignment(\"typeMembers\", this.preferences.type_member_alignment, 4, this.scribe.scanner.currentPosition); //$NON-NLS-1$\r\n		this.scribe.enterAlignment(memberAlignment);\r\n		boolean isChunkStart = false;\r\n		boolean ok = false;\r\n		int startIndex = 0;\r\n		do {\r\n			try {\r\n				for (int i = startIndex, max = nodes.length; i < max; i++) {\r\n					AstNode member = nodes[i];\r\n					if (member instanceof FieldDeclaration) {\r\n						isChunkStart = memberAlignment.checkChunkStart(FIELD, i, this.scribe.scanner.currentPosition);\r\n						if (member instanceof MultiFieldDeclaration){\r\n							MultiFieldDeclaration multiField = (MultiFieldDeclaration) member;\r\n							\r\n							if (multiField.isStatic()) {\r\n								format(multiField, this, null, isChunkStart);\r\n							} else {\r\n								format(multiField, this, null, isChunkStart);\r\n							}					\r\n						} else if (member instanceof Initializer) {\r\n							Initializer initializer = (Initializer) member;\r\n							if (initializer.isStatic()) {\r\n								initializer.traverse(this, null);\r\n							} else {\r\n								initializer.traverse(this, null);\r\n							}					\r\n						} else {\r\n							FieldDeclaration field = (FieldDeclaration) member;\r\n							if (field.isStatic()) {\r\n								format(field, this, null, isChunkStart);\r\n							} else {\r\n								format(field, this, null, isChunkStart);\r\n							}					\r\n						}\r\n					} else if (member instanceof AbstractMethodDeclaration) {\r\n						isChunkStart = memberAlignment.checkChunkStart(METHOD, i, this.scribe.scanner.currentPosition);\r\n						format((AbstractMethodDeclaration) member, null, isChunkStart);\r\n					} else {\r\n						isChunkStart = memberAlignment.checkChunkStart(TYPE, i, this.scribe.scanner.currentPosition);\r\n						format((MemberTypeDeclaration)member, null, isChunkStart);\r\n					}\r\n					if (isSemiColon()) {\r\n						this.scribe.printNextToken(ITerminalSymbols.TokenNameSEMICOLON, this.preferences.insert_space_before_semicolon);\r\n						this.scribe.printTrailingComment();\r\n					}\r\n				}\r\n				ok = true;\r\n			} catch(AlignmentException e){\r\n				startIndex = memberAlignment.chunkStartIndex;\r\n				this.scribe.redoAlignment(e);\r\n			}\r\n		} while (!ok);		\r\n		this.scribe.exitAlignment(memberAlignment, true);\r\n		this.scribe.printComment();\r\n	}\r\n	\r\n	private void formatEmptyStatement() {\r\n\r\n		if (this.preferences.put_empty_statement_on_new_line) {\r\n			this.scribe.printNewLine();\r\n		}\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameSEMICOLON, this.preferences.insert_space_before_semicolon);\r\n		this.scribe.printTrailingComment();\r\n		this.scribe.printNewLine();\r\n	}\r\n\r\n	private void formatGuardClauseBlock(Block block, BlockScope scope) {\r\n\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameLBRACE, this.preferences.insert_space_before_block_open_brace);\r\n		this.scribe.space();\r\n\r\n		final Statement[] statements = block.statements;\r\n		statements[0].traverse(this, scope);\r\n		this.scribe.space();\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameRBRACE, false, true);\r\n		this.scribe.printTrailingComment();\r\n	}	\r\n\r\n	public void formatMessageSend(\r\n		MessageSend messageSend,\r\n		BlockScope scope,\r\n		Alignment messageAlignment) {\r\n\r\n		if (messageAlignment != null) {\r\n			this.scribe.alignFragment(messageAlignment, 0);\r\n			this.scribe.printNextToken(ITerminalSymbols.TokenNameDOT);\r\n		}\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameIdentifier); // selector\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameLPAREN, this.preferences.insert_space_before_message_send);\r\n\r\n		final Expression[] arguments = messageSend.arguments;\r\n		if (arguments != null) {\r\n			int argumentLength = arguments.length;\r\n			Alignment argumentsAlignment = this.scribe.createAlignment(\r\n					\"messageArguments\", //$NON-NLS-1$\r\n					this.preferences.message_send_arguments_alignment,\r\n					argumentLength,\r\n					this.scribe.scanner.currentPosition);\r\n			this.scribe.enterAlignment(argumentsAlignment);\r\n			boolean ok = false;\r\n			do {\r\n				try {\r\n					if (this.preferences.insert_space_within_message_send) {\r\n						this.scribe.space();\r\n					}\r\n					for (int i = 0; i < argumentLength; i++) {\r\n						if (i > 0) {\r\n							this.scribe.printNextToken(ITerminalSymbols.TokenNameCOMMA, this.preferences.insert_space_before_comma_in_messagesend_arguments);\r\n						}\r\n						this.scribe.alignFragment(argumentsAlignment, i);\r\n						if (i > 0 && this.preferences.insert_space_after_comma_in_messagesend_arguments) {\r\n							this.scribe.space();\r\n						}\r\n						arguments[i].traverse(this, scope);\r\n					}\r\n					this.scribe.printNextToken(ITerminalSymbols.TokenNameRPAREN, this.preferences.insert_space_within_message_send);\r\n					ok = true;\r\n				} catch (AlignmentException e) {\r\n					this.scribe.redoAlignment(e);\r\n				}\r\n			} while (!ok);\r\n			this.scribe.exitAlignment(argumentsAlignment, true);\r\n		} else {\r\n			this.scribe.printNextToken(ITerminalSymbols.TokenNameRPAREN, this.preferences.insert_space_between_empty_arguments);\r\n		}\r\n	}\r\n\r\n	public void formatMethodArguments(\r\n			AbstractMethodDeclaration methodDeclaration, \r\n			boolean spaceBeforeOpenParen, \r\n			boolean spaceBetweenEmptyArgument,\r\n			boolean spaceBeforeClosingParen, \r\n			boolean spaceBeforeFirstArgument, \r\n			boolean spaceBeforeComma, \r\n			boolean spaceAfterComma) {\r\n				\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameLPAREN, spaceBeforeOpenParen); \r\n		\r\n		final Argument[] arguments = methodDeclaration.arguments;\r\n		if (arguments != null) {\r\n			int argumentLength = arguments.length;\r\n			Alignment argumentsAlignment = this.scribe.createAlignment(\r\n					\"methodArguments\",//$NON-NLS-1$\r\n					this.preferences.method_declaration_arguments_alignment,\r\n					argumentLength,\r\n					this.scribe.scanner.currentPosition);\r\n			this.scribe.enterAlignment(argumentsAlignment);\r\n			boolean ok = false;\r\n			do {\r\n				try {\r\n					if (spaceBeforeFirstArgument) {\r\n						this.scribe.space();\r\n					}\r\n					for (int i = 0; i < argumentLength; i++) {\r\n						if (i > 0) {\r\n							this.scribe.printNextToken(ITerminalSymbols.TokenNameCOMMA, spaceBeforeComma);\r\n						}\r\n						this.scribe.alignFragment(argumentsAlignment, i);\r\n						if (i > 0 && spaceAfterComma) {\r\n							this.scribe.space();\r\n						}\r\n						arguments[i].traverse(this, methodDeclaration.scope);\r\n					}\r\n					ok = true;\r\n				} catch (AlignmentException e) {\r\n					this.scribe.redoAlignment(e);\r\n				}\r\n			} while (!ok);\r\n			this.scribe.exitAlignment(argumentsAlignment, true);\r\n		\r\n			this.scribe.printNextToken(ITerminalSymbols.TokenNameRPAREN, spaceBeforeClosingParen); \r\n		} else {\r\n			this.scribe.printNextToken(ITerminalSymbols.TokenNameRPAREN, spaceBetweenEmptyArgument); \r\n		}\r\n	}\r\n\r\n	private void formatOpeningBrace(String bracePosition, boolean insertSpaceBeforeBrace) {\r\n	\r\n		if (bracePosition.equals(FormattingPreferences.NEXT_LINE)) {\r\n			this.scribe.printNewLine();\r\n		} else if (bracePosition.equals(FormattingPreferences.NEXT_LINE_SHIFTED)) {\r\n			this.scribe.printNewLine();\r\n			this.scribe.indent();\r\n		}\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameLBRACE, insertSpaceBeforeBrace);\r\n\r\n		this.scribe.printTrailingComment();\r\n		this.scribe.printNewLine();\r\n	}\r\n\r\n	public void formatStatements(BlockScope scope, final Statement[] statements) {\r\n		int statementsLength = statements.length;\r\n		for (int i = 0; i < statementsLength; i++) {\r\n			final Statement statement = statements[i];\r\n			statement.traverse(this, scope);\r\n			if (statement instanceof Expression) {\r\n				this.scribe.printNextToken(ITerminalSymbols.TokenNameSEMICOLON, this.preferences.insert_space_before_semicolon);\r\n				this.scribe.printTrailingComment();\r\n			} else if (statement instanceof LocalDeclaration) {\r\n				LocalDeclaration currentLocal = (LocalDeclaration) statement;\r\n				if (i < (statementsLength - 1)) {\r\n					/* \r\n					 * We need to check that the next statement is a local declaration\r\n					 */\r\n					if (statements[i + 1] instanceof LocalDeclaration) {\r\n						LocalDeclaration nextLocal = (LocalDeclaration) statements[i + 1];\r\n						if (currentLocal.declarationSourceStart != nextLocal.declarationSourceStart) {\r\n							this.scribe.printNextToken(ITerminalSymbols.TokenNameSEMICOLON, this.preferences.insert_space_before_semicolon);\r\n							this.scribe.printTrailingComment();\r\n						}\r\n					} else {\r\n						this.scribe.printNextToken(ITerminalSymbols.TokenNameSEMICOLON, this.preferences.insert_space_before_semicolon);\r\n						this.scribe.printTrailingComment();\r\n					}\r\n				} else {\r\n					this.scribe.printNextToken(ITerminalSymbols.TokenNameSEMICOLON, this.preferences.insert_space_before_semicolon);\r\n					this.scribe.printTrailingComment();\r\n				}\r\n			} else {\r\n				this.scribe.printTrailingComment();\r\n			}\r\n			this.scribe.printNewLine();\r\n		}\r\n	}\r\n	\r\n	private void formatThrowsClause(\r\n		AbstractMethodDeclaration methodDeclaration,\r\n		boolean spaceBeforeComma,\r\n		boolean spaceAfterComma) {\r\n			\r\n		final TypeReference[] thrownExceptions = methodDeclaration.thrownExceptions;\r\n		if (thrownExceptions != null) {\r\n			int thrownExceptionsLength = thrownExceptions.length;\r\n			Alignment throwsAlignment = this.scribe.createAlignment(\r\n					\"throws\",//$NON-NLS-1$\r\n					this.preferences.method_throws_clause_alignment,\r\n					thrownExceptionsLength + 1, // throws is the first token\r\n					this.scribe.scanner.currentPosition);\r\n		\r\n			this.scribe.enterAlignment(throwsAlignment);\r\n			boolean ok = false;\r\n			do {\r\n				try {\r\n					this.scribe.alignFragment(throwsAlignment, 0);\r\n					this.scribe.printNextToken(ITerminalSymbols.TokenNamethrows, true); \r\n					this.scribe.space();\r\n		\r\n					for (int i = 0; i < thrownExceptionsLength; i++) {\r\n						if (i > 0) {\r\n							this.scribe.printNextToken(ITerminalSymbols.TokenNameCOMMA, spaceBeforeComma);\r\n							if (spaceAfterComma) {\r\n								this.scribe.space();\r\n							}\r\n						}\r\n						this.scribe.alignFragment(throwsAlignment, i + 1);\r\n						thrownExceptions[i].traverse(this, methodDeclaration.scope);\r\n					}\r\n					ok = true;\r\n				} catch (AlignmentException e) {\r\n					this.scribe.redoAlignment(e);\r\n				}\r\n			} while (!ok);\r\n			this.scribe.exitAlignment(throwsAlignment, true);\r\n		}\r\n	}\r\n\r\n	/*\r\n	 * Merged traversal of member (types, fields, methods)\r\n	 */\r\n	private void formatTypeMembers(TypeDeclaration typeDeclaration) {\r\n		final int FIELD = 1, METHOD = 2, TYPE = 3;\r\n		\r\n		Alignment memberAlignment = this.scribe.createAlignment(\"typeMembers\", this.preferences.type_member_alignment, 4, this.scribe.scanner.currentPosition); //$NON-NLS-1$\r\n		this.scribe.enterAlignment(memberAlignment);\r\n		AstNode[] members = computeMergedMemberDeclarations(typeDeclaration);\r\n		boolean isChunkStart = false;\r\n		boolean ok = false;\r\n		int startIndex = 0;\r\n		do {\r\n			try {\r\n				for (int i = startIndex, max = members.length; i < max; i++) {\r\n					AstNode member = members[i];\r\n					if (member instanceof FieldDeclaration) {\r\n						isChunkStart = memberAlignment.checkChunkStart(FIELD, i, this.scribe.scanner.currentPosition);\r\n						if (member instanceof MultiFieldDeclaration){\r\n							MultiFieldDeclaration multiField = (MultiFieldDeclaration) member;\r\n							\r\n							if (multiField.isStatic()) {\r\n								format(multiField, this, typeDeclaration.staticInitializerScope, isChunkStart);\r\n							} else {\r\n								format(multiField, this, typeDeclaration.initializerScope, isChunkStart);\r\n							}					\r\n						} else if (member instanceof Initializer) {\r\n							int newLineBeforeChunk = isChunkStart ? this.preferences.blank_lines_before_new_chunk : 0;\r\n							if (newLineBeforeChunk > 0) {\r\n								this.scribe.printNewLines(newLineBeforeChunk);\r\n							}\r\n							Initializer initializer = (Initializer) member;\r\n							if (initializer.isStatic()) {\r\n								initializer.traverse(this, typeDeclaration.staticInitializerScope);\r\n							} else {\r\n								initializer.traverse(this, typeDeclaration.initializerScope);\r\n							}					\r\n						} else {\r\n							FieldDeclaration field = (FieldDeclaration) member;\r\n							if (field.isStatic()) {\r\n								format(field, this, typeDeclaration.staticInitializerScope, isChunkStart);\r\n							} else {\r\n								format(field, this, typeDeclaration.initializerScope, isChunkStart);\r\n							}					\r\n						}\r\n					} else if (member instanceof AbstractMethodDeclaration) {\r\n						isChunkStart = memberAlignment.checkChunkStart(METHOD, i, this.scribe.scanner.currentPosition);\r\n						format((AbstractMethodDeclaration) member, typeDeclaration.scope, isChunkStart);\r\n					} else {\r\n						isChunkStart = memberAlignment.checkChunkStart(TYPE, i, this.scribe.scanner.currentPosition);\r\n						format((MemberTypeDeclaration)member, typeDeclaration.scope, isChunkStart);\r\n					}\r\n					if (isSemiColon()) {\r\n						this.scribe.printNextToken(ITerminalSymbols.TokenNameSEMICOLON, this.preferences.insert_space_before_semicolon);\r\n						this.scribe.printTrailingComment();\r\n						this.scribe.printNewLine();\r\n					}\r\n				}\r\n				ok = true;\r\n			} catch(AlignmentException e){\r\n				startIndex = memberAlignment.chunkStartIndex;\r\n				this.scribe.redoAlignment(e);\r\n			}\r\n		} while (!ok);		\r\n		this.scribe.exitAlignment(memberAlignment, true);\r\n	}\r\n\r\n	private void formatTypeOpeningBrace(String bracePosition, boolean insertSpaceBeforeBrace, TypeDeclaration typeDeclaration) {\r\n		int fieldCount = (typeDeclaration.fields == null) ? 0 : typeDeclaration.fields.length;\r\n		int methodCount = (typeDeclaration.methods == null) ? 0 : typeDeclaration.methods.length;\r\n		int typeCount = (typeDeclaration.memberTypes == null) ? 0 : typeDeclaration.memberTypes.length;\r\n	\r\n		if (methodCount == 1 && typeDeclaration.methods[0].isDefaultConstructor()) {\r\n			methodCount = 0;\r\n		}\r\n		final int memberLength = fieldCount+methodCount+typeCount;\r\n\r\n		boolean insertNewLine = memberLength > 0;\r\n		\r\n		if (!insertNewLine) {\r\n			if (typeDeclaration instanceof AnonymousLocalTypeDeclaration) {\r\n				insertNewLine = this.preferences.insert_new_line_in_empty_anonymous_type_declaration;\r\n			} else {\r\n				insertNewLine = this.preferences.insert_new_line_in_empty_type_declaration;\r\n			}\r\n		}\r\n	\r\n		formatOpeningBrace(bracePosition, insertSpaceBeforeBrace);\r\n		\r\n		if (insertNewLine) {\r\n			this.scribe.printNewLine();\r\n		}\r\n	}\r\n\r\n	private int getExtraDimension() {\r\n\r\n		this.localScanner.resetTo(this.scribe.scanner.currentPosition, this.scribe.scannerEndPosition - 1);\r\n		int dimensions = 0;\r\n		try {\r\n			int token;\r\n			while ((token = this.localScanner.getNextToken()) != ITerminalSymbols.TokenNameEOF) {\r\n				switch(token) {\r\n					case ITerminalSymbols.TokenNameRBRACKET://166 \r\n						dimensions++;\r\n						break;\r\n					case ITerminalSymbols.TokenNameIdentifier ://90						\r\n					case ITerminalSymbols.TokenNameLBRACE ://90						\r\n					case ITerminalSymbols.TokenNameLPAREN :\r\n					case ITerminalSymbols.TokenNameCOMMA ://90\r\n					case ITerminalSymbols.TokenNameEQUAL ://167\r\n					case ITerminalSymbols.TokenNameSEMICOLON ://64\r\n					case ITerminalSymbols.TokenNameRPAREN : //86\r\n						return dimensions;\r\n				}\r\n			}\r\n		} catch(InvalidInputException e) {\r\n		}\r\n		return dimensions;\r\n	}\r\n\r\n	private boolean isComma() {\r\n\r\n		this.localScanner.resetTo(this.scribe.scanner.currentPosition, this.scribe.scannerEndPosition - 1);\r\n		try {\r\n			return this.localScanner.getNextToken() == ITerminalSymbols.TokenNameCOMMA;\r\n		} catch(InvalidInputException e) {\r\n		}\r\n		return false;\r\n	}\r\n\r\n	private boolean isGuardClause(Block block) {\r\n		return block.statements != null \r\n				&& block.statements.length == 1\r\n				&& (block.statements[0] instanceof ReturnStatement\r\n					|| block.statements[0] instanceof ThrowStatement);\r\n	}	\r\n\r\n	private boolean isMultipleLocalDeclaration(LocalDeclaration localDeclaration) {\r\n\r\n		if (localDeclaration.declarationSourceStart == this.lastLocalDeclarationSourceStart) return true;\r\n		this.lastLocalDeclarationSourceStart = localDeclaration.declarationSourceStart;\r\n		return false;\r\n	}\r\n\r\n	private boolean isPartOfMultipleLocalDeclaration() {\r\n		this.localScanner.resetTo(this.scribe.scanner.currentPosition, this.scribe.scannerEndPosition - 1);\r\n		try {\r\n			int token;\r\n			while ((token = this.localScanner.getNextToken()) != ITerminalSymbols.TokenNameEOF) {\r\n				switch(token) {\r\n					case ITerminalSymbols.TokenNameCOMMA ://90\r\n						return true;\r\n					default:\r\n						return false;\r\n				}\r\n			}\r\n		} catch(InvalidInputException e) {\r\n		}\r\n		return false;\r\n	}\r\n\r\n	private boolean isSemiColon() {\r\n\r\n		this.localScanner.resetTo(this.scribe.scanner.currentPosition, this.scribe.scannerEndPosition - 1);\r\n		try {\r\n			return this.localScanner.getNextToken() == ITerminalSymbols.TokenNameSEMICOLON;\r\n		} catch(InvalidInputException e) {\r\n		}\r\n		return false;\r\n	}\r\n	\r\n	private void manageClosingParenthesizedExpression(Expression expression, int numberOfParens) {\r\n		for (int i = 0; i < numberOfParens; i++) {\r\n			this.scribe.printNextToken(ITerminalSymbols.TokenNameRPAREN, this.preferences.insert_space_before_closing_paren_in_parenthesized_expression);\r\n		}\r\n	}\r\n\r\n	private void manageOpeningParenthesizedExpression(Expression expression, int numberOfParens) {\r\n		for (int i = 0; i < numberOfParens; i++) {\r\n			this.scribe.printNextToken(ITerminalSymbols.TokenNameLPAREN, this.preferences.insert_space_before_open_paren_in_parenthesized_expression);\r\n			if (this.preferences.insert_space_after_open_paren_in_parenthesized_expression) {\r\n				this.scribe.space();\r\n			}\r\n		}\r\n	}\r\n			\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.AllocationExpression, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(\r\n		AllocationExpression allocationExpression,\r\n		BlockScope scope) {\r\n		// \'new\' ClassType \'(\' ArgumentListopt \')\' ClassBodyopt\r\n\r\n		final int numberOfParens = (allocationExpression.bits & AstNode.ParenthesizedMASK) >> AstNode.ParenthesizedSHIFT;\r\n		if (numberOfParens > 0) {\r\n			manageOpeningParenthesizedExpression(allocationExpression, numberOfParens);\r\n		}\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNamenew);\r\n		this.scribe.space();\r\n		allocationExpression.type.traverse(this, scope);\r\n		\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameLPAREN, this.preferences.insert_space_before_message_send);\r\n\r\n		final Expression[] arguments = allocationExpression.arguments;\r\n		if (arguments != null) {\r\n			int argumentLength = arguments.length;\r\n			Alignment argumentsAlignment =this.scribe.createAlignment(\r\n					\"allocation\",//$NON-NLS-1$\r\n					this.preferences.allocation_expression_arguments_alignment,\r\n					argumentLength,\r\n					this.scribe.scanner.currentPosition);\r\n			this.scribe.enterAlignment(argumentsAlignment);\r\n			boolean ok = false;\r\n			do {\r\n				try {\r\n					if (this.preferences.insert_space_within_message_send) {\r\n						this.scribe.space();\r\n					}\r\n					for (int i = 0; i < argumentLength; i++) {\r\n						if (i > 0) {\r\n							this.scribe.printNextToken(ITerminalSymbols.TokenNameCOMMA, this.preferences.insert_space_before_comma_in_allocation_expression);\r\n						}\r\n						this.scribe.alignFragment(argumentsAlignment, i);\r\n						if (i > 0 && this.preferences.insert_space_after_comma_in_allocation_expression) {\r\n							this.scribe.space();\r\n						}\r\n						arguments[i].traverse(this, scope);\r\n					}\r\n					ok = true;\r\n				} catch (AlignmentException e) {\r\n					this.scribe.redoAlignment(e);\r\n				}\r\n			} while (!ok);\r\n			this.scribe.exitAlignment(argumentsAlignment, true);\r\n			this.scribe.printNextToken(ITerminalSymbols.TokenNameRPAREN, this.preferences.insert_space_within_message_send); \r\n		} else {\r\n			this.scribe.printNextToken(ITerminalSymbols.TokenNameRPAREN, this.preferences.insert_space_between_empty_arguments); \r\n		}\r\n		\r\n		if (numberOfParens > 0) {\r\n			manageClosingParenthesizedExpression(allocationExpression, numberOfParens);\r\n		}\r\n		return false;\r\n	}\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.AND_AND_Expression, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(\r\n		AND_AND_Expression and_and_Expression,\r\n		BlockScope scope) {\r\n			\r\n		return dumpBinaryExpression(and_and_Expression, ITerminalSymbols.TokenNameAND_AND, scope);\r\n	}\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.AnonymousLocalTypeDeclaration, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(\r\n		AnonymousLocalTypeDeclaration anonymousTypeDeclaration,\r\n		BlockScope scope) {\r\n			\r\n		/*\r\n		 * Type body\r\n		 */\r\n		String anonymous_type_declaration_brace_position = this.preferences.anonymous_type_declaration_brace_position;\r\n		formatTypeOpeningBrace(anonymous_type_declaration_brace_position, this.preferences.insert_space_before_anonymous_type_open_brace, anonymousTypeDeclaration);\r\n		\r\n		this.scribe.indent();\r\n\r\n		formatTypeMembers(anonymousTypeDeclaration);\r\n		\r\n		this.scribe.printComment();\r\n		this.scribe.unIndent();\r\n		if (this.preferences.insert_new_line_in_empty_anonymous_type_declaration) {\r\n			this.scribe.printNewLine();\r\n		}\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameRBRACE);\r\n		if (anonymous_type_declaration_brace_position.equals(FormattingPreferences.NEXT_LINE_SHIFTED)) {\r\n			this.scribe.unIndent();\r\n		}\r\n		return false;\r\n	}\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.Argument, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(Argument argument, BlockScope scope) {\r\n\r\n		if (argument.modifiers != NO_MODIFIERS) {\r\n			this.scribe.printModifiers();\r\n			this.scribe.space();\r\n		}\r\n\r\n		/*\r\n		 * Argument type \r\n		 */		\r\n		if (argument.type != null) {\r\n			argument.type.traverse(this, scope);\r\n		}\r\n		\r\n		/*\r\n		 * Print the argument name\r\n		 */	\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameIdentifier, true);\r\n\r\n\r\n		/*\r\n		 * Check for extra dimensions\r\n		 */\r\n		int extraDimensions = getExtraDimension();\r\n		if (extraDimensions != 0) {\r\n			 for (int i = 0; i < extraDimensions; i++) {\r\n			 	this.scribe.printNextToken(ITerminalSymbols.TokenNameLBRACKET);\r\n			 	this.scribe.printNextToken(ITerminalSymbols.TokenNameRBRACKET);\r\n			 }\r\n		}\r\n		\r\n		return false;\r\n	}\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.ArrayAllocationExpression, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(\r\n		ArrayAllocationExpression arrayAllocationExpression,\r\n		BlockScope scope) {\r\n\r\n			final int numberOfParens = (arrayAllocationExpression.bits & AstNode.ParenthesizedMASK) >> AstNode.ParenthesizedSHIFT;\r\n			if (numberOfParens > 0) {\r\n				manageOpeningParenthesizedExpression(arrayAllocationExpression, numberOfParens);\r\n			}\r\n			this.scribe.printNextToken(ITerminalSymbols.TokenNamenew);\r\n			this.scribe.space();\r\n			arrayAllocationExpression.type.traverse(this, scope);\r\n			\r\n			final Expression[] dimensions = arrayAllocationExpression.dimensions;\r\n			int dimensionsLength = dimensions.length;\r\n			for (int i = 0; i < dimensionsLength; i++) {\r\n				this.scribe.printNextToken(ITerminalSymbols.TokenNameLBRACKET);\r\n				if (dimensions[i] != null) {\r\n					dimensions[i].traverse(this, scope);\r\n				}\r\n				this.scribe.printNextToken(ITerminalSymbols.TokenNameRBRACKET);\r\n			}\r\n			final ArrayInitializer initializer = arrayAllocationExpression.initializer;\r\n			if (initializer != null) {\r\n				initializer.traverse(this, scope);\r\n			}\r\n\r\n			if (numberOfParens > 0) {\r\n				manageClosingParenthesizedExpression(arrayAllocationExpression, numberOfParens);\r\n			}\r\n			return false;\r\n	}\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.ArrayInitializer, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(ArrayInitializer arrayInitializer, BlockScope scope) {\r\n\r\n		final int numberOfParens = (arrayInitializer.bits & AstNode.ParenthesizedMASK) >> AstNode.ParenthesizedSHIFT;\r\n		if (numberOfParens > 0) {\r\n			manageOpeningParenthesizedExpression(arrayInitializer, numberOfParens);\r\n		}\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameLBRACE);\r\n		\r\n		final Expression[] expressions = arrayInitializer.expressions;\r\n		if (expressions != null) {\r\n			int expressionsLength = expressions.length;\r\n			if (expressionsLength > 1) {\r\n				Alignment expressionsAlignment =this.scribe.createAlignment(\r\n						\"expressions\",//$NON-NLS-1$\r\n						this.preferences.array_initializer_expressions_alignment,\r\n						expressionsLength - 1,\r\n						this.scribe.scanner.currentPosition);\r\n				this.scribe.enterAlignment(expressionsAlignment);\r\n				boolean ok = false;\r\n				do {\r\n					try {\r\n						if (this.preferences.insert_space_before_first_initializer) {\r\n							this.scribe.space();\r\n						}\r\n						expressions[0].traverse(this, scope);\r\n						for (int i = 1; i < expressionsLength; i++) {\r\n							this.scribe.printNextToken(ITerminalSymbols.TokenNameCOMMA, this.preferences.insert_space_before_comma_in_array_initializer);\r\n							if (this.preferences.insert_space_after_comma_in_array_initializer) {\r\n								this.scribe.space();\r\n							}\r\n							this.scribe.alignFragment(expressionsAlignment, i - 1);\r\n							expressions[i].traverse(this, scope);\r\n						}\r\n						ok = true;\r\n					} catch (AlignmentException e) {\r\n						this.scribe.redoAlignment(e);\r\n					}\r\n				} while (!ok);\r\n				this.scribe.exitAlignment(expressionsAlignment, true);\r\n			} else {\r\n				// we don\'t need to use an alignment\r\n				if (this.preferences.insert_space_before_first_initializer) {\r\n					this.scribe.space();\r\n				}\r\n				expressions[0].traverse(this, scope);\r\n				for (int i = 1; i < expressionsLength; i++) {\r\n					this.scribe.printNextToken(ITerminalSymbols.TokenNameCOMMA, this.preferences.insert_space_before_comma_in_array_initializer);\r\n					if (this.preferences.insert_space_after_comma_in_array_initializer) {\r\n						this.scribe.space();\r\n					}\r\n					expressions[i].traverse(this, scope);\r\n				}\r\n			}\r\n			if (isComma()) {\r\n				this.scribe.printNextToken(ITerminalSymbols.TokenNameCOMMA, this.preferences.insert_space_before_comma_in_array_initializer);\r\n			}\r\n			this.scribe.printNextToken(ITerminalSymbols.TokenNameRBRACE, this.preferences.insert_space_before_closing_brace_in_array_initializer, true); \r\n		} else {\r\n			this.scribe.printNextToken(ITerminalSymbols.TokenNameRBRACE, this.preferences.insert_space_between_empty_array_initializer, true);\r\n		}\r\n\r\n		if (numberOfParens > 0) {\r\n			manageClosingParenthesizedExpression(arrayInitializer, numberOfParens);\r\n		}\r\n		return false;\r\n	}\r\n	\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.ArrayQualifiedTypeReference, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(\r\n		ArrayQualifiedTypeReference arrayQualifiedTypeReference,\r\n		BlockScope scope) {\r\n\r\n			final int numberOfParens = (arrayQualifiedTypeReference.bits & AstNode.ParenthesizedMASK) >> AstNode.ParenthesizedSHIFT;\r\n			if (numberOfParens > 0) {\r\n				manageOpeningParenthesizedExpression(arrayQualifiedTypeReference, numberOfParens);\r\n			}\r\n			this.scribe.printQualifiedReference(arrayQualifiedTypeReference.sourceEnd - 1);\r\n			int dimensions = getExtraDimension();\r\n			if (dimensions != 0) {\r\n				for (int i = 0; i < dimensions; i++) {\r\n					this.scribe.printNextToken(ITerminalSymbols.TokenNameLBRACKET);\r\n					this.scribe.printNextToken(ITerminalSymbols.TokenNameRBRACKET);\r\n				}\r\n			}\r\n			if (numberOfParens > 0) {\r\n				manageClosingParenthesizedExpression(arrayQualifiedTypeReference, numberOfParens);\r\n			}\r\n			return false;\r\n	}\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.ArrayQualifiedTypeReference, org.eclipse.jdt.internal.compiler.lookup.ClassScope)\r\n	 */\r\n	public boolean visit(\r\n		ArrayQualifiedTypeReference arrayQualifiedTypeReference,\r\n		ClassScope scope) {\r\n\r\n			final int numberOfParens = (arrayQualifiedTypeReference.bits & AstNode.ParenthesizedMASK) >> AstNode.ParenthesizedSHIFT;\r\n			if (numberOfParens > 0) {\r\n				manageOpeningParenthesizedExpression(arrayQualifiedTypeReference, numberOfParens);\r\n			}\r\n			this.scribe.printQualifiedReference(arrayQualifiedTypeReference.sourceEnd - 1);\r\n			int dimensions = getExtraDimension();\r\n			if (dimensions != 0) {\r\n				for (int i = 0; i < dimensions; i++) {\r\n					this.scribe.printNextToken(ITerminalSymbols.TokenNameLBRACKET);\r\n					this.scribe.printNextToken(ITerminalSymbols.TokenNameRBRACKET);\r\n				}\r\n			}\r\n			if (numberOfParens > 0) {\r\n				manageClosingParenthesizedExpression(arrayQualifiedTypeReference, numberOfParens);\r\n			}\r\n			return false;\r\n	}\r\n\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.ArrayReference, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(ArrayReference arrayReference, BlockScope scope) {\r\n\r\n		final int numberOfParens = (arrayReference.bits & AstNode.ParenthesizedMASK) >> AstNode.ParenthesizedSHIFT;\r\n		if (numberOfParens > 0) {\r\n			manageOpeningParenthesizedExpression(arrayReference, numberOfParens);\r\n		}\r\n		arrayReference.receiver.traverse(this, scope);\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameLBRACKET);\r\n		arrayReference.position.traverse(this, scope);\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameRBRACKET);\r\n		\r\n		if (numberOfParens > 0) {\r\n			manageClosingParenthesizedExpression(arrayReference, numberOfParens);\r\n		}\r\n		return false;\r\n	}\r\n	\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.ArrayTypeReference, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(\r\n		ArrayTypeReference arrayTypeReference,\r\n		BlockScope scope) {\r\n\r\n		final int numberOfParens = (arrayTypeReference.bits & AstNode.ParenthesizedMASK) >> AstNode.ParenthesizedSHIFT;\r\n		if (numberOfParens > 0) {\r\n			manageOpeningParenthesizedExpression(arrayTypeReference, numberOfParens);\r\n		}\r\n		this.scribe.printNextToken(SINGLETYPEREFERENCE_EXPECTEDTOKENS, false, true);\r\n		\r\n		int dimensions = getExtraDimension();\r\n		if (dimensions != 0) {\r\n			if (this.preferences.insert_space_before_bracket_in_array_type_reference) {\r\n				this.scribe.space();\r\n			}\r\n			for (int i = 0; i < dimensions; i++) {\r\n				this.scribe.printNextToken(ITerminalSymbols.TokenNameLBRACKET);\r\n				if (this.preferences.insert_space_between_brackets_in_array_type_reference) {\r\n					this.scribe.space();\r\n				}\r\n				this.scribe.printNextToken(ITerminalSymbols.TokenNameRBRACKET);\r\n			}\r\n		}\r\n		if (numberOfParens > 0) {\r\n			manageClosingParenthesizedExpression(arrayTypeReference, numberOfParens);\r\n		}\r\n		return false;\r\n	}\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.ArrayTypeReference, org.eclipse.jdt.internal.compiler.lookup.ClassScope)\r\n	 */\r\n	public boolean visit(\r\n		ArrayTypeReference arrayTypeReference,\r\n		ClassScope scope) {\r\n\r\n		final int numberOfParens = (arrayTypeReference.bits & AstNode.ParenthesizedMASK) >> AstNode.ParenthesizedSHIFT;\r\n		if (numberOfParens > 0) { \r\n			manageOpeningParenthesizedExpression(arrayTypeReference, numberOfParens);\r\n		}\r\n		this.scribe.printNextToken(SINGLETYPEREFERENCE_EXPECTEDTOKENS, false, true);\r\n		int dimensions = getExtraDimension();\r\n		if (dimensions != 0) {\r\n			if (this.preferences.insert_space_before_bracket_in_array_type_reference) {\r\n				this.scribe.space();\r\n			}\r\n			for (int i = 0; i < dimensions; i++) {\r\n				this.scribe.printNextToken(ITerminalSymbols.TokenNameLBRACKET);\r\n				if (this.preferences.insert_space_between_brackets_in_array_type_reference) {\r\n					this.scribe.space();\r\n				}\r\n				this.scribe.printNextToken(ITerminalSymbols.TokenNameRBRACKET);\r\n			}\r\n		}\r\n		if (numberOfParens > 0) {\r\n			manageClosingParenthesizedExpression(arrayTypeReference, numberOfParens);\r\n		}\r\n		return false;\r\n	}\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.AssertStatement, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(AssertStatement assertStatement, BlockScope scope) {\r\n		\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameassert);\r\n		this.scribe.space();\r\n		assertStatement.assertExpression.traverse(this, scope);\r\n		\r\n		if (assertStatement.exceptionArgument != null) {\r\n			this.scribe.printNextToken(ITerminalSymbols.TokenNameCOLON, this.preferences.insert_space_before_colon_in_assert);\r\n			if (this.preferences.insert_space_after_colon_in_assert) {\r\n				this.scribe.space();\r\n			}\r\n			assertStatement.exceptionArgument.traverse(this, scope);\r\n		}\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameSEMICOLON, this.preferences.insert_space_before_semicolon);		\r\n		return false;\r\n	}\r\n	\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.Assignment, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(Assignment assignment, BlockScope scope) {\r\n\r\n		final int numberOfParens = (assignment.bits & AstNode.ParenthesizedMASK) >> AstNode.ParenthesizedSHIFT;\r\n		if (numberOfParens > 0) {\r\n			manageOpeningParenthesizedExpression(assignment, numberOfParens);\r\n		}\r\n		assignment.lhs.traverse(this, scope);\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameEQUAL, this.preferences.insert_space_before_assignment_operators);\r\n		if (this.preferences.insert_space_after_assignment_operators) {\r\n			this.scribe.space();\r\n		}\r\n		assignment.expression.traverse(this, scope);\r\n		\r\n		if (numberOfParens > 0) {\r\n			manageClosingParenthesizedExpression(assignment, numberOfParens);\r\n		}\r\n		return false;\r\n	}\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.BinaryExpression, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(BinaryExpression binaryExpression, BlockScope scope) {\r\n\r\n		switch((binaryExpression.bits & AstNode.OperatorMASK) >> AstNode.OperatorSHIFT) {\r\n			case OperatorIds.AND :\r\n				return dumpBinaryExpression(binaryExpression, ITerminalSymbols.TokenNameAND, scope);\r\n			case OperatorIds.DIVIDE :\r\n				return dumpBinaryExpression(binaryExpression, ITerminalSymbols.TokenNameDIVIDE, scope);\r\n			case OperatorIds.GREATER :\r\n				return dumpBinaryExpression(binaryExpression, ITerminalSymbols.TokenNameGREATER, scope);\r\n			case OperatorIds.GREATER_EQUAL :\r\n				return dumpBinaryExpression(binaryExpression, ITerminalSymbols.TokenNameGREATER_EQUAL, scope);\r\n			case OperatorIds.LEFT_SHIFT :\r\n				return dumpBinaryExpression(binaryExpression, ITerminalSymbols.TokenNameLEFT_SHIFT, scope);\r\n			case OperatorIds.LESS :\r\n				return dumpBinaryExpression(binaryExpression, ITerminalSymbols.TokenNameLESS, scope);\r\n			case OperatorIds.LESS_EQUAL :\r\n				return dumpBinaryExpression(binaryExpression, ITerminalSymbols.TokenNameLESS_EQUAL, scope);\r\n			case OperatorIds.MINUS :\r\n				return dumpBinaryExpression(binaryExpression, ITerminalSymbols.TokenNameMINUS, scope);\r\n			case OperatorIds.MULTIPLY :\r\n				return dumpBinaryExpression(binaryExpression, ITerminalSymbols.TokenNameMULTIPLY, scope);\r\n			case OperatorIds.OR :\r\n				return dumpBinaryExpression(binaryExpression, ITerminalSymbols.TokenNameOR, scope);\r\n			case OperatorIds.PLUS :\r\n				return dumpBinaryExpression(binaryExpression, ITerminalSymbols.TokenNamePLUS, scope);\r\n			case OperatorIds.REMAINDER :\r\n				return dumpBinaryExpression(binaryExpression, ITerminalSymbols.TokenNameREMAINDER, scope);\r\n			case OperatorIds.RIGHT_SHIFT :\r\n				return dumpBinaryExpression(binaryExpression, ITerminalSymbols.TokenNameRIGHT_SHIFT, scope);\r\n			case OperatorIds.UNSIGNED_RIGHT_SHIFT :\r\n				return dumpBinaryExpression(binaryExpression, ITerminalSymbols.TokenNameUNSIGNED_RIGHT_SHIFT, scope);\r\n			case OperatorIds.XOR :\r\n				return dumpBinaryExpression(binaryExpression, ITerminalSymbols.TokenNameXOR, scope);\r\n			default:\r\n				throw new IllegalStateException();\r\n		}\r\n	}\r\n	\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.Block, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(Block block, BlockScope scope) {\r\n	\r\n		String block_brace_position = this.preferences.block_brace_position;\r\n		formatOpeningBrace(block_brace_position, this.preferences.insert_space_before_block_open_brace);\r\n		this.scribe.indent();\r\n	\r\n		final Statement[] statements = block.statements;\r\n		if (statements != null) {\r\n			this.scribe.printTrailingComment();\r\n			this.scribe.printNewLine();\r\n			formatStatements(scope, statements);\r\n		} else if (this.preferences.insert_new_line_in_empty_block) {\r\n			this.scribe.printNewLine();\r\n		}\r\n		this.scribe.printComment();\r\n\r\n		this.scribe.unIndent();\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameRBRACE);\r\n		this.scribe.printTrailingComment();\r\n		this.scribe.printNewLine();\r\n	\r\n		if (block_brace_position.equals(FormattingPreferences.NEXT_LINE_SHIFTED)) {\r\n			this.scribe.unIndent();\r\n		}		\r\n		return false;	\r\n	}\r\n\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.Break, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(BreakStatement breakStatement, BlockScope scope) {\r\n		\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNamebreak);\r\n		if (breakStatement.label != null) {\r\n			this.scribe.printNextToken(ITerminalSymbols.TokenNameIdentifier, true);\r\n		}\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameSEMICOLON, this.preferences.insert_space_before_semicolon);\r\n		return false;\r\n	}\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.Case, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(CaseStatement caseStatement, BlockScope scope) {		\r\n		if (caseStatement.constantExpression == null) {\r\n			this.scribe.printNextToken(ITerminalSymbols.TokenNamedefault);\r\n			this.scribe.printNextToken(ITerminalSymbols.TokenNameCOLON, this.preferences.insert_space_before_colon_in_default);\r\n		} else {\r\n			this.scribe.printNextToken(ITerminalSymbols.TokenNamecase);\r\n			this.scribe.space();\r\n			caseStatement.constantExpression.traverse(this, scope);\r\n			this.scribe.printNextToken(ITerminalSymbols.TokenNameCOLON, this.preferences.insert_space_before_colon_in_case);\r\n		}\r\n		return false;\r\n	}\r\n\r\n\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.CastExpression, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(CastExpression castExpression, BlockScope scope) {\r\n\r\n		final int numberOfParens = (castExpression.bits & AstNode.ParenthesizedMASK) >> AstNode.ParenthesizedSHIFT;\r\n		if (numberOfParens > 0) {\r\n			manageOpeningParenthesizedExpression(castExpression, numberOfParens);\r\n		}\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameLPAREN);\r\n		if (this.preferences.insert_space_after_opening_paren_in_cast) {\r\n			this.scribe.space();\r\n		}\r\n		castExpression.type.traverse(this, scope);\r\n\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameRPAREN, this.preferences.insert_space_before_closing_paren_in_cast);\r\n		if (this.preferences.insert_space_after_closing_paren_in_cast) {\r\n			this.scribe.space();\r\n		}\r\n		castExpression.expression.traverse(this, scope);\r\n		\r\n		if (numberOfParens > 0) {\r\n			manageClosingParenthesizedExpression(castExpression, numberOfParens);\r\n		}\r\n		return false;\r\n	}\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.CharLiteral, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(CharLiteral charLiteral, BlockScope scope) {\r\n\r\n		final int numberOfParens = (charLiteral.bits & AstNode.ParenthesizedMASK) >> AstNode.ParenthesizedSHIFT;\r\n		if (numberOfParens > 0) {\r\n			manageOpeningParenthesizedExpression(charLiteral, numberOfParens);\r\n		}\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameCharacterLiteral);\r\n\r\n		if (numberOfParens > 0) {\r\n			manageClosingParenthesizedExpression(charLiteral, numberOfParens);\r\n		}\r\n		return false;\r\n	}\r\n\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.ClassLiteralAccess, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(ClassLiteralAccess classLiteral, BlockScope scope) {\r\n\r\n		final int numberOfParens = (classLiteral.bits & AstNode.ParenthesizedMASK) >> AstNode.ParenthesizedSHIFT;\r\n		if (numberOfParens > 0) {\r\n			manageOpeningParenthesizedExpression(classLiteral, numberOfParens);\r\n		}\r\n		classLiteral.type.traverse(this, scope);\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameDOT);\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameclass);\r\n		\r\n		if (numberOfParens > 0) {\r\n			manageClosingParenthesizedExpression(classLiteral, numberOfParens);\r\n		}\r\n		return false;\r\n	}\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.Clinit, org.eclipse.jdt.internal.compiler.lookup.ClassScope)\r\n	 */\r\n	public boolean visit(Clinit clinit, ClassScope scope) {\r\n\r\n		return false;\r\n	}\r\n	\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration, org.eclipse.jdt.internal.compiler.lookup.CompilationUnitScope)\r\n	 */\r\n	public boolean visit(\r\n		CompilationUnitDeclaration compilationUnitDeclaration,\r\n		CompilationUnitScope scope) {\r\n		\r\n		/* \r\n		 * Package declaration\r\n		 */\r\n		if (compilationUnitDeclaration.currentPackage != null) {\r\n			// OPTION\r\n			// dump the package keyword\r\n			int blankLinesBeforePackage = this.preferences.blank_lines_before_package;\r\n			if (blankLinesBeforePackage > 0) {\r\n				this.scribe.printNewLines(blankLinesBeforePackage - 1);\r\n			}\r\n			this.scribe.printComment();\r\n			this.scribe.printNextToken(ITerminalSymbols.TokenNamepackage);\r\n			this.scribe.space();\r\n			this.scribe.printQualifiedReference(compilationUnitDeclaration.currentPackage.sourceEnd);\r\n			this.scribe.printNextToken(ITerminalSymbols.TokenNameSEMICOLON, this.preferences.insert_space_before_semicolon);\r\n			this.scribe.printTrailingComment();\r\n			int blankLinesAfterPackage = this.preferences.blank_lines_after_package;\r\n			if (blankLinesAfterPackage > 0) {\r\n				this.scribe.printNewLines(blankLinesAfterPackage);\r\n			}				\r\n		} else {\r\n			this.scribe.printComment();\r\n		}\r\n		\r\n		/*\r\n		 * Import statements\r\n		 */\r\n		final ImportReference[] imports = compilationUnitDeclaration.imports;\r\n		if (imports != null) {\r\n			int blankLinesBeforeImports = this.preferences.blank_lines_before_imports;\r\n			if (blankLinesBeforeImports > 0) {\r\n				this.scribe.printNewLines(blankLinesBeforeImports);\r\n			}\r\n			int importLength = imports.length;\r\n			for (int i = 0; i < importLength; i++) {\r\n				imports[i].traverse(this, scope);\r\n			}			\r\n			\r\n			int blankLinesAfterImports = this.preferences.blank_lines_after_imports;\r\n			if (blankLinesAfterImports > 0) {\r\n				this.scribe.printNewLines(blankLinesAfterImports);\r\n			}\r\n		}\r\n\r\n		/*\r\n		 * Type declarations\r\n		 */\r\n		final TypeDeclaration[] types = compilationUnitDeclaration.types;\r\n		if (types != null) {\r\n			int typesLength = types.length;\r\n			for (int i = 0; i < typesLength; i++) {\r\n				types[i].traverse(this, scope);\r\n			}\r\n		}\r\n		this.scribe.printComment();\r\n		return false;\r\n	}\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.CompoundAssignment, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(\r\n		CompoundAssignment compoundAssignment,\r\n		BlockScope scope) {\r\n			\r\n		final int numberOfParens = (compoundAssignment.bits & AstNode.ParenthesizedMASK) >> AstNode.ParenthesizedSHIFT;\r\n		if (numberOfParens > 0) {\r\n			manageOpeningParenthesizedExpression(compoundAssignment, numberOfParens);\r\n		}\r\n		compoundAssignment.lhs.traverse(this, scope);\r\n		\r\n		/*\r\n		 * Print the operator\r\n		 */\r\n		int operator;\r\n		switch(compoundAssignment.operator) {\r\n			case OperatorIds.PLUS :\r\n				operator = ITerminalSymbols.TokenNamePLUS_EQUAL;\r\n				break;\r\n			case OperatorIds.MINUS :\r\n				operator = ITerminalSymbols.TokenNameMINUS_EQUAL;\r\n				break;\r\n			case OperatorIds.MULTIPLY :\r\n				operator = ITerminalSymbols.TokenNameMULTIPLY_EQUAL;\r\n				break;\r\n			case OperatorIds.DIVIDE :\r\n				operator = ITerminalSymbols.TokenNameDIVIDE_EQUAL;\r\n				break;\r\n			case OperatorIds.AND :\r\n				operator = ITerminalSymbols.TokenNameAND_EQUAL;\r\n				break;\r\n			case OperatorIds.OR :\r\n				operator = ITerminalSymbols.TokenNameOR_EQUAL;\r\n				break;\r\n			case OperatorIds.XOR :\r\n				operator = ITerminalSymbols.TokenNameXOR_EQUAL;\r\n				break;\r\n			case OperatorIds.REMAINDER :\r\n				operator = ITerminalSymbols.TokenNameREMAINDER_EQUAL;\r\n				break;\r\n			case OperatorIds.LEFT_SHIFT :\r\n				operator = ITerminalSymbols.TokenNameLEFT_SHIFT_EQUAL;\r\n				break;\r\n			case OperatorIds.RIGHT_SHIFT :\r\n				operator = ITerminalSymbols.TokenNameRIGHT_SHIFT_EQUAL;\r\n				break;\r\n			default: // OperatorIds.UNSIGNED_RIGHT_SHIFT :\r\n				operator = ITerminalSymbols.TokenNameUNSIGNED_RIGHT_SHIFT_EQUAL;\r\n		}\r\n		\r\n		this.scribe.printNextToken(operator, this.preferences.insert_space_before_assignment_operators);\r\n		if (this.preferences.insert_space_after_assignment_operators) {\r\n			this.scribe.space();\r\n		}\r\n		compoundAssignment.expression.traverse(this, scope);\r\n		\r\n		if (numberOfParens > 0) {\r\n			manageClosingParenthesizedExpression(compoundAssignment, numberOfParens);\r\n		}\r\n		return false;\r\n	}\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.ConditionalExpression, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(\r\n		ConditionalExpression conditionalExpression,\r\n		BlockScope scope) {\r\n\r\n		final int numberOfParens = (conditionalExpression.bits & AstNode.ParenthesizedMASK) >> AstNode.ParenthesizedSHIFT;\r\n		if (numberOfParens > 0) {\r\n			manageOpeningParenthesizedExpression(conditionalExpression, numberOfParens);\r\n		}\r\n		conditionalExpression.condition.traverse(this, scope);\r\n\r\n		Alignment conditionalExpressionAlignment =this.scribe.createAlignment(\r\n				\"conditionalExpression\", //$NON-NLS-1$\r\n				this.preferences.conditional_expression_alignment,\r\n				2,\r\n				this.scribe.scanner.currentPosition);\r\n\r\n		this.scribe.enterAlignment(conditionalExpressionAlignment);\r\n		boolean ok = false;\r\n		do {\r\n			try {\r\n				this.scribe.alignFragment(conditionalExpressionAlignment, 0);\r\n				this.scribe.printNextToken(ITerminalSymbols.TokenNameQUESTION, this.preferences.insert_space_before_question_in_conditional);\r\n\r\n				if (this.preferences.insert_space_after_question_in_conditional) {\r\n					this.scribe.space();\r\n				}\r\n				conditionalExpression.valueIfTrue.traverse(this, scope);\r\n\r\n				this.scribe.alignFragment(conditionalExpressionAlignment, 1);\r\n				this.scribe.printNextToken(ITerminalSymbols.TokenNameCOLON, this.preferences.insert_space_before_colon_in_conditional);\r\n\r\n				if (this.preferences.insert_space_after_colon_in_conditional) {\r\n					this.scribe.space();\r\n				}\r\n				conditionalExpression.valueIfFalse.traverse(this, scope);\r\n\r\n				ok = true;\r\n			} catch (AlignmentException e) {\r\n				this.scribe.redoAlignment(e);\r\n			}\r\n		} while (!ok);\r\n		this.scribe.exitAlignment(conditionalExpressionAlignment, true);\r\n			\r\n		if (numberOfParens > 0) {\r\n			manageClosingParenthesizedExpression(conditionalExpression, numberOfParens);\r\n		}\r\n		return false;	\r\n	}\r\n\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.ConstructorDeclaration, org.eclipse.jdt.internal.compiler.lookup.ClassScope)\r\n	 */\r\n	public boolean visit(\r\n		ConstructorDeclaration constructorDeclaration,\r\n		ClassScope scope) {\r\n			\r\n		if (constructorDeclaration.modifiers != NO_MODIFIERS) {\r\n			this.scribe.printModifiers();\r\n		} else {\r\n			this.scribe.printComment();\r\n		}			\r\n		/*\r\n		 * Print the method name\r\n		 */	\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameIdentifier, true); \r\n\r\n		formatMethodArguments(\r\n			constructorDeclaration, \r\n			this.preferences.insert_space_before_method_declaration_open_paren,\r\n			this.preferences.insert_space_between_empty_arguments,\r\n			this.preferences.insert_space_before_closing_paren,\r\n			this.preferences.insert_space_before_first_argument,\r\n			this.preferences.insert_space_before_comma_in_constructor_arguments,\r\n			this.preferences.insert_space_after_comma_in_constructor_arguments);\r\n\r\n		formatThrowsClause(\r\n				constructorDeclaration,\r\n				this.preferences.insert_space_before_comma_in_constructor_throws,\r\n				this.preferences.insert_space_after_comma_in_constructor_throws);\r\n\r\n		if (!constructorDeclaration.isNative() && !constructorDeclaration.isAbstract()) {\r\n			/*\r\n			 * Method body\r\n			 */\r\n			String method_declaration_brace = this.preferences.method_declaration_brace_position;\r\n			formatOpeningBrace(method_declaration_brace, this.preferences.insert_space_before_method_open_brace);\r\n			this.scribe.indent();			\r\n			final int numberOfBlankLinesAtBeginningOfMethodBody = this.preferences.number_of_blank_lines_to_insert_at_beginning_of_method_body;\r\n			if (numberOfBlankLinesAtBeginningOfMethodBody > 0) {\r\n				this.scribe.printNewLines(numberOfBlankLinesAtBeginningOfMethodBody);\r\n			}\r\n			if (constructorDeclaration.constructorCall != null && !constructorDeclaration.constructorCall.isImplicitSuper()) {\r\n				this.scribe.printNewLine();\r\n				constructorDeclaration.constructorCall.traverse(this, constructorDeclaration.scope);\r\n				this.scribe.printNextToken(ITerminalSymbols.TokenNameSEMICOLON, this.preferences.insert_space_before_semicolon);\r\n				this.scribe.printTrailingComment();\r\n			}\r\n			final Statement[] statements = constructorDeclaration.statements;\r\n			if (statements != null) {\r\n				this.scribe.printNewLine();\r\n				formatStatements(constructorDeclaration.scope, statements);\r\n			} else if (this.preferences.insert_new_line_in_empty_method_body) {\r\n				this.scribe.printNewLine();\r\n			}\r\n			this.scribe.printComment();\r\n			this.scribe.unIndent();\r\n			this.scribe.printNextToken(ITerminalSymbols.TokenNameRBRACE);\r\n			this.scribe.printTrailingComment();\r\n			if (method_declaration_brace.equals(FormattingPreferences.NEXT_LINE_SHIFTED)) {\r\n				this.scribe.unIndent();\r\n			}\r\n		} else {\r\n			// no method body\r\n			this.scribe.printNextToken(ITerminalSymbols.TokenNameSEMICOLON, this.preferences.insert_space_before_semicolon);\r\n			this.scribe.printTrailingComment();\r\n		}\r\n		return false;\r\n	}\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.Continue, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(ContinueStatement continueStatement, BlockScope scope) {\r\n\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNamecontinue);\r\n		if (continueStatement.label != null) {\r\n			this.scribe.printNextToken(ITerminalSymbols.TokenNameIdentifier, true);\r\n		}\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameSEMICOLON, this.preferences.insert_space_before_semicolon);\r\n		return false;\r\n	}\r\n\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.DoStatement, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(DoStatement doStatement, BlockScope scope) {\r\n\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNamedo);\r\n		\r\n		final Statement action = doStatement.action;\r\n		if (action != null) {\r\n			if (action instanceof Block) {\r\n				action.traverse(this, scope);\r\n			} else {\r\n				this.scribe.printNewLine();\r\n				this.scribe.indent();\r\n				action.traverse(this, scope);\r\n				this.scribe.unIndent();\r\n			}\r\n			if (action instanceof Expression) {\r\n				this.scribe.printNextToken(ITerminalSymbols.TokenNameSEMICOLON, this.preferences.insert_space_before_semicolon);\r\n				this.scribe.printTrailingComment();\r\n			} else if (action instanceof Block && this.preferences.insert_new_line_in_control_statements) {\r\n				this.scribe.printTrailingComment();\r\n			}\r\n		} else {\r\n			this.scribe.indent();\r\n			/*\r\n			 * This is an empty statement\r\n			 */\r\n			formatEmptyStatement(); \r\n			this.scribe.unIndent();\r\n		}\r\n		\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNamewhile, this.preferences.insert_space_after_block_close_brace);\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameLPAREN, this.preferences.insert_space_before_while_condition);\r\n		\r\n		if (this.preferences.insert_space_in_while_condition) {\r\n			this.scribe.space();\r\n		}\r\n		\r\n		doStatement.condition.traverse(this, scope);\r\n		\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameRPAREN, this.preferences.insert_space_in_while_condition);\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameSEMICOLON, this.preferences.insert_space_before_semicolon);\r\n		return false;\r\n	}\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.DoubleLiteral, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(DoubleLiteral doubleLiteral, BlockScope scope) {\r\n\r\n		final int numberOfParens = (doubleLiteral.bits & AstNode.ParenthesizedMASK) >> AstNode.ParenthesizedSHIFT;\r\n		if (numberOfParens > 0) {\r\n			manageOpeningParenthesizedExpression(doubleLiteral, numberOfParens);\r\n		}\r\n		Constant constant = doubleLiteral.constant;\r\n		if (constant != null && constant.doubleValue() < 0) {\r\n			this.scribe.printNextToken(ITerminalSymbols.TokenNameMINUS);			\r\n		}\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameDoubleLiteral);\r\n\r\n		if (numberOfParens > 0) {\r\n			manageClosingParenthesizedExpression(doubleLiteral, numberOfParens);\r\n		}\r\n		return false;\r\n	}\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.EmptyStatement, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(EmptyStatement statement, BlockScope scope) {\r\n\r\n		formatEmptyStatement();\r\n		return false;	\r\n	}\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.EqualExpression, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(EqualExpression equalExpression, BlockScope scope) {\r\n\r\n		if ((equalExpression.bits & AstNode.OperatorMASK) >> AstNode.OperatorSHIFT == OperatorIds.EQUAL_EQUAL) {\r\n			return dumpBinaryExpression(equalExpression, ITerminalSymbols.TokenNameEQUAL_EQUAL, scope);\r\n		} else {\r\n			return dumpBinaryExpression(equalExpression, ITerminalSymbols.TokenNameNOT_EQUAL, scope);\r\n		}			\r\n	}\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.ExplicitConstructorCall, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(\r\n		ExplicitConstructorCall explicitConstructor,\r\n		BlockScope scope) {\r\n\r\n		if (explicitConstructor.isImplicitSuper()) {\r\n			return false;\r\n		}\r\n		final Expression qualification = explicitConstructor.qualification;\r\n		if (qualification != null) {\r\n			qualification.traverse(this, scope);\r\n		}\r\n\r\n		if (explicitConstructor.isSuperAccess()) {\r\n			this.scribe.printNextToken(ITerminalSymbols.TokenNamesuper);\r\n		} else {\r\n			this.scribe.printNextToken(ITerminalSymbols.TokenNamethis);\r\n		}\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameLPAREN, this.preferences.insert_space_before_message_send);\r\n		\r\n		final Expression[] arguments = explicitConstructor.arguments;\r\n		if (arguments != null) {\r\n			int argumentLength = arguments.length;\r\n			Alignment argumentsAlignment =this.scribe.createAlignment(\r\n					\"explicit_constructor_call\",//$NON-NLS-1$\r\n					this.preferences.explicit_constructor_arguments_alignment,\r\n					argumentLength,\r\n					this.scribe.scanner.currentPosition);\r\n			this.scribe.enterAlignment(argumentsAlignment);\r\n			boolean ok = false;\r\n			do {\r\n				try {\r\n					if (this.preferences.insert_space_within_message_send) {\r\n						this.scribe.space();\r\n					}\r\n					for (int i = 0; i < argumentLength; i++) {\r\n						if (i > 0) {\r\n							this.scribe.printNextToken(ITerminalSymbols.TokenNameCOMMA, this.preferences.insert_space_before_comma_in_explicitconstructorcall_arguments);\r\n						}\r\n						this.scribe.alignFragment(argumentsAlignment, i);\r\n						if (i > 0 && this.preferences.insert_space_after_comma_in_explicitconstructorcall_arguments) {\r\n							this.scribe.space();\r\n						}\r\n						arguments[i].traverse(this, scope);\r\n					}\r\n					ok = true;\r\n				} catch (AlignmentException e) {\r\n					this.scribe.redoAlignment(e);\r\n				}\r\n			} while (!ok);\r\n			this.scribe.exitAlignment(argumentsAlignment, true);\r\n			this.scribe.printNextToken(ITerminalSymbols.TokenNameRPAREN, this.preferences.insert_space_within_message_send); \r\n		} else {\r\n			this.scribe.printNextToken(ITerminalSymbols.TokenNameRPAREN, this.preferences.insert_space_between_empty_arguments); \r\n		}\r\n		return false;\r\n	}\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.FalseLiteral, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(FalseLiteral falseLiteral, BlockScope scope) {\r\n\r\n		final int numberOfParens = (falseLiteral.bits & AstNode.ParenthesizedMASK) >> AstNode.ParenthesizedSHIFT;\r\n		if (numberOfParens > 0) {\r\n			manageOpeningParenthesizedExpression(falseLiteral, numberOfParens);\r\n		}\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNamefalse);\r\n\r\n		if (numberOfParens > 0) {\r\n			manageClosingParenthesizedExpression(falseLiteral, numberOfParens);\r\n		}\r\n		return false;\r\n	}\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.FieldReference, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(FieldReference fieldReference, BlockScope scope) {\r\n\r\n		final int numberOfParens = (fieldReference.bits & AstNode.ParenthesizedMASK) >> AstNode.ParenthesizedSHIFT;\r\n		if (numberOfParens > 0) {\r\n			manageOpeningParenthesizedExpression(fieldReference, numberOfParens);\r\n		}\r\n		fieldReference.receiver.traverse(this, scope);\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameDOT);\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameIdentifier);\r\n		\r\n		if (numberOfParens > 0) {\r\n			manageClosingParenthesizedExpression(fieldReference, numberOfParens);\r\n		}\r\n		return false;\r\n	}\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.FloatLiteral, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(FloatLiteral floatLiteral, BlockScope scope) {\r\n\r\n		final int numberOfParens = (floatLiteral.bits & AstNode.ParenthesizedMASK) >> AstNode.ParenthesizedSHIFT;\r\n		if (numberOfParens > 0) {\r\n			manageOpeningParenthesizedExpression(floatLiteral, numberOfParens);\r\n		}\r\n		Constant constant = floatLiteral.constant;\r\n		if (constant != null && floatLiteral.constant.floatValue() < 0) {\r\n			this.scribe.printNextToken(ITerminalSymbols.TokenNameMINUS);			\r\n		}\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameFloatingPointLiteral);\r\n\r\n		if (numberOfParens > 0) {\r\n			manageClosingParenthesizedExpression(floatLiteral, numberOfParens);\r\n		}\r\n		return false;\r\n	}\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.ForStatement, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(ForStatement forStatement, BlockScope scope) {\r\n	\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNamefor);\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameLPAREN, this.preferences.insert_space_before_for_paren);\r\n		\r\n		if (this.preferences.insert_space_in_for_parens) {\r\n			this.scribe.space();\r\n		}\r\n		final Statement[] initializations = forStatement.initializations;\r\n		if (initializations != null) {\r\n			int length = initializations.length;\r\n			for (int i = 0; i < length; i++) {\r\n				initializations[i].traverse(this, scope);\r\n				if (i >= 0 && (i < length - 1) && !(initializations[i] instanceof LocalDeclaration)) {\r\n					this.scribe.printNextToken(ITerminalSymbols.TokenNameCOMMA, this.preferences.insert_space_before_comma_in_for_inits);\r\n					if (this.preferences.insert_space_after_comma_in_for_inits) {\r\n						this.scribe.space();\r\n					}\r\n				}				\r\n			}\r\n		}\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameSEMICOLON, this.preferences.insert_space_before_semicolon);\r\n		if (this.preferences.insert_space_after_semicolon_in_for) {\r\n			this.scribe.space();\r\n		}\r\n		final Expression condition = forStatement.condition;\r\n		if (condition != null) {\r\n			condition.traverse(this, scope);\r\n		}\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameSEMICOLON, this.preferences.insert_space_before_semicolon);\r\n		if (this.preferences.insert_space_after_semicolon_in_for) {\r\n			this.scribe.space();\r\n		}\r\n		final Statement[] increments = forStatement.increments;\r\n		if (increments != null) {\r\n			for (int i = 0, length = increments.length; i < length; i++) {\r\n				increments[i].traverse(this, scope);\r\n				if (i != length - 1) {\r\n					this.scribe.printNextToken(ITerminalSymbols.TokenNameCOMMA, this.preferences.insert_space_before_comma_in_for_increments);\r\n					if (this.preferences.insert_space_after_comma_in_for_increments) {\r\n						this.scribe.space();\r\n					}\r\n				}\r\n			}\r\n		}\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameRPAREN, this.preferences.insert_space_in_for_parens);\r\n		\r\n		final Statement action = forStatement.action;\r\n		if (action != null) {\r\n			if (action instanceof Block) {\r\n				action.traverse(this, scope);\r\n			} else {\r\n				this.scribe.indent();\r\n				this.scribe.printNewLine();\r\n				action.traverse(this, scope);\r\n				this.scribe.unIndent();\r\n			}\r\n			if (action instanceof Expression) {\r\n				this.scribe.printNextToken(ITerminalSymbols.TokenNameSEMICOLON, this.preferences.insert_space_before_semicolon);\r\n				this.scribe.printTrailingComment();\r\n				this.scribe.printNewLine();\r\n			} else if (action instanceof Block && this.preferences.insert_new_line_in_control_statements) {\r\n				this.scribe.printTrailingComment();\r\n				this.scribe.printNewLine();\r\n			}\r\n		} else {\r\n			this.scribe.indent();\r\n			/*\r\n			 * This is an empty statement\r\n			 */\r\n			formatEmptyStatement(); \r\n			this.scribe.unIndent();\r\n		}\r\n		return false;\r\n	}\r\n\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.IfStatement, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(IfStatement ifStatement, BlockScope scope) {\r\n\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameif);\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameLPAREN, this.preferences.insert_space_before_if_condition);\r\n		if (this.preferences.insert_space_in_if_condition) {\r\n			this.scribe.space();\r\n		}\r\n		ifStatement.condition.traverse(this, scope);\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameRPAREN, this.preferences.insert_space_in_if_condition);\r\n\r\n		final Statement thenStatement = ifStatement.thenStatement;\r\n		final Statement elseStatement = ifStatement.elseStatement;\r\n\r\n		if (thenStatement != null) {\r\n			if (thenStatement instanceof Block) {\r\n				if (isGuardClause((Block)thenStatement) && elseStatement == null && this.preferences.format_guardian_clause_on_one_line) {\r\n					/* \r\n					 * Need a specific formatting for guard clauses\r\n					 * guard clauses are block with a single return or throw\r\n					 * statement\r\n					 */\r\n					 formatGuardClauseBlock((Block) thenStatement, scope);\r\n				} else {\r\n					if (thenStatement instanceof Block) {\r\n						thenStatement.traverse(this, scope);\r\n					} else {\r\n						this.scribe.printNewLine();\r\n						this.scribe.indent();\r\n						thenStatement.traverse(this, scope);\r\n						this.scribe.unIndent();\r\n					}\r\n					if (elseStatement == null || this.preferences.insert_new_line_in_control_statements) {\r\n						this.scribe.printTrailingComment();\r\n					}\r\n				}\r\n			} else if (elseStatement == null && this.preferences.keep_simple_if_on_one_line) {\r\n				Alignment compactIfAlignment = this.scribe.createAlignment(\r\n					\"compactIf\", //$NON-NLS-1$\r\n					this.preferences.compact_if_alignment,\r\n					Alignment.R_OUTERMOST,\r\n					1, \r\n					this.scribe.scanner.currentPosition);\r\n				this.scribe.enterAlignment(compactIfAlignment);\r\n				boolean ok = false;\r\n				do {\r\n					try {\r\n						this.scribe.alignFragment(compactIfAlignment, 0);\r\n						this.scribe.space();\r\n						thenStatement.traverse(this, scope);\r\n						if (thenStatement instanceof Expression) {\r\n							this.scribe.printNextToken(ITerminalSymbols.TokenNameSEMICOLON, this.preferences.insert_space_before_semicolon);\r\n						}\r\n						ok = true;\r\n					} catch (AlignmentException e) {\r\n						this.scribe.redoAlignment(e);\r\n					}\r\n				} while (!ok);\r\n				this.scribe.exitAlignment(compactIfAlignment, true);				\r\n			} else if (this.preferences.keep_then_statement_on_same_line) {\r\n				this.scribe.space();\r\n				thenStatement.traverse(this, scope);\r\n				if (thenStatement instanceof Expression) {\r\n					this.scribe.printNextToken(ITerminalSymbols.TokenNameSEMICOLON, this.preferences.insert_space_before_semicolon);\r\n				}\r\n				this.scribe.printTrailingComment();\r\n				this.scribe.printNewLine();\r\n			} else {\r\n				this.scribe.printTrailingComment();\r\n				this.scribe.printNewLine();\r\n				this.scribe.indent();\r\n				thenStatement.traverse(this, scope);\r\n				if (thenStatement instanceof Expression) {\r\n					this.scribe.printNextToken(ITerminalSymbols.TokenNameSEMICOLON, this.preferences.insert_space_before_semicolon);\r\n				}\r\n				this.scribe.printTrailingComment();\r\n				this.scribe.printNewLine();\r\n				this.scribe.unIndent();\r\n			}\r\n		}\r\n		\r\n		if (elseStatement != null) {\r\n			this.scribe.printNextToken(ITerminalSymbols.TokenNameelse, true);\r\n			if (elseStatement instanceof Block) {\r\n				elseStatement.traverse(this, scope);\r\n			} else if (elseStatement instanceof IfStatement) {\r\n				if (!this.preferences.compact_else_if) {\r\n					this.scribe.printTrailingComment();\r\n					this.scribe.indent();\r\n				}\r\n				this.scribe.space();				\r\n				elseStatement.traverse(this, scope);\r\n				if (!this.preferences.compact_else_if) {\r\n					this.scribe.printTrailingComment();\r\n					this.scribe.unIndent();\r\n				}\r\n			} else if (this.preferences.keep_else_statement_on_same_line) {\r\n				this.scribe.space();\r\n				elseStatement.traverse(this, scope);\r\n				if (elseStatement instanceof Expression) {\r\n					this.scribe.printNextToken(ITerminalSymbols.TokenNameSEMICOLON, this.preferences.insert_space_before_semicolon);\r\n				}\r\n				this.scribe.printTrailingComment();\r\n				this.scribe.printNewLine();\r\n			} else {\r\n				this.scribe.printTrailingComment();\r\n				this.scribe.indent();\r\n				elseStatement.traverse(this, scope);\r\n				if (elseStatement instanceof Expression) {\r\n					this.scribe.printNextToken(ITerminalSymbols.TokenNameSEMICOLON, this.preferences.insert_space_before_semicolon);\r\n				}\r\n				this.scribe.printTrailingComment();\r\n				this.scribe.printNewLine();\r\n				this.scribe.unIndent();\r\n			}\r\n		}\r\n		return false;\r\n	}\r\n	\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.ImportReference, org.eclipse.jdt.internal.compiler.lookup.CompilationUnitScope)\r\n	 */\r\n	public boolean visit(\r\n		ImportReference importRef,\r\n		CompilationUnitScope scope) {\r\n		\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameimport);\r\n		this.scribe.space();\r\n		if (importRef.onDemand) {\r\n			this.scribe.printQualifiedReference(importRef.sourceEnd);\r\n			this.scribe.printNextToken(ITerminalSymbols.TokenNameDOT);\r\n			this.scribe.printNextToken(ITerminalSymbols.TokenNameMULTIPLY);			\r\n			this.scribe.printNextToken(ITerminalSymbols.TokenNameSEMICOLON, this.preferences.insert_space_before_semicolon);\r\n		} else {\r\n			this.scribe.printQualifiedReference(importRef.sourceEnd);\r\n			this.scribe.printNextToken(ITerminalSymbols.TokenNameSEMICOLON, this.preferences.insert_space_before_semicolon);\r\n		}\r\n		this.scribe.printTrailingComment();\r\n		this.scribe.printNewLine();\r\n		return false;\r\n	}\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.Initializer, org.eclipse.jdt.internal.compiler.lookup.MethodScope)\r\n	 */\r\n	public boolean visit(Initializer initializer, MethodScope scope) {\r\n\r\n		if (initializer.isStatic()) {\r\n			this.scribe.printNextToken(ITerminalSymbols.TokenNamestatic);\r\n		}\r\n		initializer.block.traverse(this, scope);\r\n		return false;\r\n	}\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.InstanceOfExpression, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(\r\n		InstanceOfExpression instanceOfExpression,\r\n		BlockScope scope) {\r\n\r\n		final int numberOfParens = (instanceOfExpression.bits & AstNode.ParenthesizedMASK) >> AstNode.ParenthesizedSHIFT;\r\n		if (numberOfParens > 0) {\r\n			manageOpeningParenthesizedExpression(instanceOfExpression, numberOfParens);\r\n		}\r\n		instanceOfExpression.expression.traverse(this, scope);\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameinstanceof, true);\r\n		this.scribe.space();\r\n		instanceOfExpression.type.traverse(this, scope);\r\n		\r\n		if (numberOfParens > 0) {\r\n			manageClosingParenthesizedExpression(instanceOfExpression, numberOfParens);\r\n		}\r\n		return false;\r\n	}\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.AbstractSyntaxTreeVisitorAdapter#visit(org.eclipse.jdt.internal.compiler.ast.IntLiteral, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(IntLiteral intLiteral, BlockScope scope) {\r\n\r\n		final int numberOfParens = (intLiteral.bits & AstNode.ParenthesizedMASK) >> AstNode.ParenthesizedSHIFT;\r\n		if (numberOfParens > 0) {\r\n			manageOpeningParenthesizedExpression(intLiteral, numberOfParens);\r\n		}\r\n		Constant constant = intLiteral.constant;\r\n		if (constant != null && constant.intValue() < 0) {\r\n			this.scribe.printNextToken(ITerminalSymbols.TokenNameMINUS);			\r\n		}\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameIntegerLiteral);\r\n\r\n		if (numberOfParens > 0) {\r\n			manageClosingParenthesizedExpression(intLiteral, numberOfParens);\r\n		}\r\n		return false;\r\n	}\r\n\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.LabeledStatement, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(LabeledStatement labeledStatement, BlockScope scope) {\r\n\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameIdentifier);\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameCOLON, this.preferences.insert_space_before_colon_in_labeled_statement);\r\n		if (this.preferences.insert_space_after_colon_in_labeled_statement) {\r\n			this.scribe.space();\r\n		}\r\n		labeledStatement.statement.traverse(this, scope);\r\n		return false;\r\n	}\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.LocalDeclaration, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(LocalDeclaration localDeclaration, BlockScope scope) {\r\n\r\n		if (!isMultipleLocalDeclaration(localDeclaration)) {\r\n			if (localDeclaration.modifiers != NO_MODIFIERS) {\r\n				this.scribe.printModifiers();\r\n				this.scribe.space();\r\n			}\r\n	\r\n			/*\r\n			 * Argument type \r\n			 */		\r\n			if (localDeclaration.type != null) {\r\n				localDeclaration.type.traverse(this, scope);\r\n			}\r\n		}\r\n		/*\r\n		 * Print the argument name\r\n		 */	\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameIdentifier, true); \r\n		/*\r\n		 * Check for extra dimensions\r\n		 */\r\n		int extraDimensions = getExtraDimension();\r\n		if (extraDimensions != 0) {\r\n			 for (int index = 0; index < extraDimensions; index++) {\r\n			 	this.scribe.printNextToken(ITerminalSymbols.TokenNameLBRACKET);\r\n			 	this.scribe.printNextToken(ITerminalSymbols.TokenNameRBRACKET);\r\n			 }\r\n		}\r\n	\r\n		if (localDeclaration.initialization != null) {\r\n			/*\r\n			 * Print the method name\r\n			 */	\r\n			this.scribe.printNextToken(ITerminalSymbols.TokenNameEQUAL, this.preferences.insert_space_before_assignment_operators);\r\n			if (this.preferences.insert_space_after_assignment_operators) {\r\n				this.scribe.space();\r\n			}			 \r\n			localDeclaration.initialization.traverse(this, scope);\r\n		}\r\n\r\n		if (isPartOfMultipleLocalDeclaration()) {\r\n			this.scribe.printNextToken(ITerminalSymbols.TokenNameCOMMA, this.preferences.insert_space_before_comma_in_multiple_local_declarations); \r\n			if (this.preferences.insert_space_after_comma_in_multiple_local_declarations) {\r\n				this.scribe.space();\r\n			}\r\n		}\r\n		return false;\r\n	}\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.LocalTypeDeclaration, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(\r\n		LocalTypeDeclaration localTypeDeclaration,\r\n		BlockScope scope) {\r\n\r\n			format(localTypeDeclaration);\r\n			return false;\r\n	}\r\n	\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.LongLiteral, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(LongLiteral longLiteral, BlockScope scope) {\r\n\r\n		final int numberOfParens = (longLiteral.bits & AstNode.ParenthesizedMASK) >> AstNode.ParenthesizedSHIFT;\r\n		if (numberOfParens > 0) {\r\n			manageOpeningParenthesizedExpression(longLiteral, numberOfParens);\r\n		}\r\n		Constant constant = longLiteral.constant;\r\n		if (constant != null && constant.longValue() < 0) {\r\n			this.scribe.printNextToken(ITerminalSymbols.TokenNameMINUS);			\r\n		}\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameLongLiteral);\r\n\r\n		if (numberOfParens > 0) {\r\n			manageClosingParenthesizedExpression(longLiteral, numberOfParens);\r\n		}\r\n		return false;\r\n	}\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.AbstractSyntaxTreeVisitorAdapter#visit(org.eclipse.jdt.internal.compiler.ast.MemberTypeDeclaration, org.eclipse.jdt.internal.compiler.lookup.ClassScope)\r\n	 */\r\n	public boolean visit(MemberTypeDeclaration memberTypeDeclaration, ClassScope scope) {\r\n		Alignment memberTypeAlignment = this.scribe.getAlignment(\"typeMembers\");		//$NON-NLS-1$\r\n		format(memberTypeDeclaration);\r\n		this.scribe.exitAlignment(memberTypeAlignment, false);		\r\n		return false;\r\n	}\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.MessageSend, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(MessageSend messageSend, BlockScope scope) {\r\n\r\n		final int numberOfParens = (messageSend.bits & AstNode.ParenthesizedMASK) >> AstNode.ParenthesizedSHIFT;\r\n		if (numberOfParens > 0) {\r\n			manageOpeningParenthesizedExpression(messageSend, numberOfParens);\r\n		}\r\n		Alignment messageAlignment = null;\r\n		if (!messageSend.receiver.isImplicitThis()) {\r\n			messageSend.receiver.traverse(this, scope);\r\n			messageAlignment = this.scribe.createAlignment(\r\n					\"messageAlignment\", //$NON-NLS-1$\r\n					this.preferences.message_send_selector_alignment,\r\n					1,\r\n					this.scribe.scanner.currentPosition);\r\n			this.scribe.enterAlignment(messageAlignment);\r\n			boolean ok = false;\r\n			do {\r\n				try {\r\n					formatMessageSend(messageSend, scope, messageAlignment);\r\n					ok = true;\r\n				} catch (AlignmentException e) {\r\n					this.scribe.redoAlignment(e);\r\n				}\r\n			} while (!ok);\r\n			this.scribe.exitAlignment(messageAlignment, true);\r\n		} else {\r\n			formatMessageSend(messageSend, scope, null);			\r\n		}\r\n		if (numberOfParens > 0) {\r\n			manageClosingParenthesizedExpression(messageSend, numberOfParens);\r\n		}\r\n		return false;\r\n	}\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.MethodDeclaration, org.eclipse.jdt.internal.compiler.lookup.ClassScope)\r\n	 */\r\n	public boolean visit(\r\n		MethodDeclaration methodDeclaration,\r\n		ClassScope scope) {\r\n\r\n		if (methodDeclaration.modifiers != NO_MODIFIERS) {\r\n			this.scribe.printModifiers();\r\n			this.scribe.space();\r\n		}\r\n		\r\n		/*\r\n		 * Print the method return type\r\n		 */	\r\n		final TypeReference returnType = methodDeclaration.returnType;\r\n		final MethodScope methodDeclarationScope = methodDeclaration.scope;\r\n		\r\n		if (returnType != null) {\r\n			returnType.traverse(this, methodDeclarationScope);\r\n		}\r\n		/*\r\n		 * Print the method name\r\n		 */\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameIdentifier, true); \r\n\r\n		/*\r\n		 * Check for extra dimensions\r\n		 */\r\n		int extraDimensions = getExtraDimension();\r\n		if (extraDimensions != 0) {\r\n			 for (int i = 0; i < extraDimensions; i++) {\r\n			 	this.scribe.printNextToken(ITerminalSymbols.TokenNameLBRACKET);\r\n			 	this.scribe.printNextToken(ITerminalSymbols.TokenNameRBRACKET);\r\n			 }\r\n		}\r\n\r\n		formatMethodArguments(\r\n			methodDeclaration, \r\n			this.preferences.insert_space_before_method_declaration_open_paren,\r\n			this.preferences.insert_space_between_empty_arguments,\r\n			this.preferences.insert_space_before_closing_paren,\r\n			this.preferences.insert_space_before_first_argument,\r\n			this.preferences.insert_space_before_comma_in_method_arguments,\r\n			this.preferences.insert_space_after_comma_in_method_arguments);\r\n\r\n		formatThrowsClause(\r\n			methodDeclaration,\r\n			this.preferences.insert_space_before_comma_in_method_throws,\r\n			this.preferences.insert_space_after_comma_in_method_throws);\r\n\r\n		if (!methodDeclaration.isNative() && !methodDeclaration.isAbstract() && ((methodDeclaration.modifiers & CompilerModifiers.AccSemicolonBody) == 0)) {\r\n			/*\r\n			 * Method body\r\n			 */\r\n			String method_declaration_brace = this.preferences.method_declaration_brace_position;\r\n			formatOpeningBrace(method_declaration_brace, this.preferences.insert_space_before_method_open_brace);\r\n			this.scribe.indent();			\r\n			final int numberOfBlankLinesAtBeginningOfMethodBody = this.preferences.number_of_blank_lines_to_insert_at_beginning_of_method_body;\r\n			if (numberOfBlankLinesAtBeginningOfMethodBody > 0) {\r\n				this.scribe.printNewLines(numberOfBlankLinesAtBeginningOfMethodBody);\r\n			}\r\n			final Statement[] statements = methodDeclaration.statements;\r\n			if (statements != null) {\r\n				this.scribe.printNewLine();\r\n				formatStatements(methodDeclarationScope, statements);\r\n			} else if (this.preferences.insert_new_line_in_empty_method_body) {\r\n				this.scribe.printNewLine();\r\n			}\r\n			this.scribe.printComment();\r\n			this.scribe.unIndent();\r\n			this.scribe.printNextToken(ITerminalSymbols.TokenNameRBRACE);\r\n			this.scribe.printTrailingComment();\r\n			this.scribe.printNewLine();\r\n			if (method_declaration_brace.equals(FormattingPreferences.NEXT_LINE_SHIFTED)) {\r\n				this.scribe.unIndent();\r\n			}\r\n		} else {\r\n			// no method body\r\n			this.scribe.printNextToken(ITerminalSymbols.TokenNameSEMICOLON, this.preferences.insert_space_before_semicolon);\r\n			this.scribe.printTrailingComment();\r\n			this.scribe.printNewLine();\r\n		}\r\n		return false;\r\n	}\r\n	\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.NullLiteral, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(NullLiteral nullLiteral, BlockScope scope) {\r\n\r\n		final int numberOfParens = (nullLiteral.bits & AstNode.ParenthesizedMASK) >> AstNode.ParenthesizedSHIFT;\r\n		if (numberOfParens > 0) {\r\n			manageOpeningParenthesizedExpression(nullLiteral, numberOfParens);\r\n		}\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNamenull);\r\n\r\n		if (numberOfParens > 0) {\r\n			manageClosingParenthesizedExpression(nullLiteral, numberOfParens);\r\n		}\r\n		return false;\r\n	}\r\n\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.OR_OR_Expression, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(OR_OR_Expression or_or_Expression, BlockScope scope) {\r\n\r\n		return dumpBinaryExpression(or_or_Expression, ITerminalSymbols.TokenNameOR_OR, scope);\r\n	}\r\n	\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.PostfixExpression, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(\r\n		PostfixExpression postfixExpression,\r\n		BlockScope scope) {\r\n\r\n		final int numberOfParens = (postfixExpression.bits & AstNode.ParenthesizedMASK) >> AstNode.ParenthesizedSHIFT;\r\n		if (numberOfParens > 0) {\r\n			manageOpeningParenthesizedExpression(postfixExpression, numberOfParens);\r\n		}\r\n		postfixExpression.lhs.traverse(this, scope);\r\n		int operator = postfixExpression.operator == OperatorIds.PLUS \r\n			? ITerminalSymbols.TokenNamePLUS_PLUS : ITerminalSymbols.TokenNameMINUS_MINUS;\r\n		this.scribe.printNextToken(operator, this.preferences.insert_space_before_postfix_operator);\r\n		if (this.preferences.insert_space_after_postfix_operator) {\r\n			this.scribe.space();\r\n		}\r\n		if (numberOfParens > 0) {\r\n			manageClosingParenthesizedExpression(postfixExpression, numberOfParens);\r\n		}\r\n		return false;\r\n	}\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.PrefixExpression, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(PrefixExpression prefixExpression, BlockScope scope) {\r\n\r\n		final int numberOfParens = (prefixExpression.bits & AstNode.ParenthesizedMASK) >> AstNode.ParenthesizedSHIFT;\r\n		if (numberOfParens > 0) {\r\n			manageOpeningParenthesizedExpression(prefixExpression, numberOfParens);\r\n		}\r\n		int operator = prefixExpression.operator == OperatorIds.PLUS \r\n			? ITerminalSymbols.TokenNamePLUS_PLUS : ITerminalSymbols.TokenNameMINUS_MINUS;\r\n		this.scribe.printNextToken(operator, this.preferences.insert_space_before_prefix_operator);\r\n		prefixExpression.lhs.traverse(this, scope);\r\n		if (this.preferences.insert_space_after_prefix_operator) {\r\n			this.scribe.space();\r\n		}\r\n		if (numberOfParens > 0) {\r\n			manageClosingParenthesizedExpression(prefixExpression, numberOfParens);\r\n		}\r\n		return false;\r\n	}\r\n	\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.QualifiedAllocationExpression, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(\r\n		QualifiedAllocationExpression qualifiedAllocationExpression,\r\n		BlockScope scope) {\r\n			\r\n		final int numberOfParens = (qualifiedAllocationExpression.bits & AstNode.ParenthesizedMASK) >> AstNode.ParenthesizedSHIFT;\r\n		if (numberOfParens > 0) {\r\n			manageOpeningParenthesizedExpression(qualifiedAllocationExpression, numberOfParens);\r\n		}\r\n		final Expression enclosingInstance = qualifiedAllocationExpression.enclosingInstance;\r\n		if (enclosingInstance != null) {\r\n			enclosingInstance.traverse(this, scope);\r\n			this.scribe.printNextToken(ITerminalSymbols.TokenNameDOT);\r\n		}\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNamenew);\r\n		this.scribe.space();\r\n		qualifiedAllocationExpression.type.traverse(this, scope);\r\n		\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameLPAREN, this.preferences.insert_space_before_message_send);\r\n\r\n		final Expression[] arguments = qualifiedAllocationExpression.arguments;\r\n		if (arguments != null) {\r\n			int argumentLength = arguments.length;\r\n			Alignment argumentsAlignment =this.scribe.createAlignment(\r\n					\"allocation\",//$NON-NLS-1$\r\n					this.preferences.qualified_allocation_expression_arguments_alignment,\r\n					argumentLength,\r\n					this.scribe.scanner.currentPosition);\r\n			this.scribe.enterAlignment(argumentsAlignment);\r\n			boolean ok = false;\r\n			do {\r\n				try {\r\n					if (this.preferences.insert_space_within_message_send) {\r\n						this.scribe.space();\r\n					}\r\n					for (int i = 0; i < argumentLength; i++) {\r\n						if (i > 0) {\r\n							this.scribe.printNextToken(ITerminalSymbols.TokenNameCOMMA, this.preferences.insert_space_before_comma_in_allocation_expression);\r\n						}\r\n						this.scribe.alignFragment(argumentsAlignment, i);\r\n						if (i > 0 && this.preferences.insert_space_after_comma_in_allocation_expression) {\r\n							this.scribe.space();\r\n						}\r\n						arguments[i].traverse(this, scope);\r\n					}\r\n					ok = true;\r\n				} catch (AlignmentException e) {\r\n					this.scribe.redoAlignment(e);\r\n				}\r\n			} while (!ok);\r\n			this.scribe.exitAlignment(argumentsAlignment, true);\r\n			this.scribe.printNextToken(ITerminalSymbols.TokenNameRPAREN, this.preferences.insert_space_within_message_send); \r\n		} else {\r\n			this.scribe.printNextToken(ITerminalSymbols.TokenNameRPAREN, this.preferences.insert_space_between_empty_arguments); \r\n		}\r\n		final AnonymousLocalTypeDeclaration anonymousType = qualifiedAllocationExpression.anonymousType;\r\n		if (anonymousType != null) {\r\n			anonymousType.traverse(this, scope);\r\n		}\r\n		if (numberOfParens > 0) {\r\n			manageClosingParenthesizedExpression(qualifiedAllocationExpression, numberOfParens);\r\n		}\r\n		return false;\r\n	}\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.QualifiedNameReference, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(\r\n		QualifiedNameReference qualifiedNameReference,\r\n		BlockScope scope) {\r\n\r\n		final int numberOfParens = (qualifiedNameReference.bits & AstNode.ParenthesizedMASK) >> AstNode.ParenthesizedSHIFT;\r\n		if (numberOfParens > 0) {\r\n			manageOpeningParenthesizedExpression(qualifiedNameReference, numberOfParens);\r\n		}\r\n		this.scribe.printQualifiedReference(qualifiedNameReference.sourceEnd);\r\n\r\n		if (numberOfParens > 0) {\r\n			manageClosingParenthesizedExpression(qualifiedNameReference, numberOfParens);\r\n		}\r\n		return false;\r\n	}\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.QualifiedSuperReference, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(\r\n		QualifiedSuperReference qualifiedSuperReference,\r\n		BlockScope scope) {\r\n\r\n		final int numberOfParens = (qualifiedSuperReference.bits & AstNode.ParenthesizedMASK) >> AstNode.ParenthesizedSHIFT;\r\n		if (numberOfParens > 0) {\r\n			manageOpeningParenthesizedExpression(qualifiedSuperReference, numberOfParens);\r\n		}\r\n		qualifiedSuperReference.qualification.traverse(this, scope);\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameDOT);\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNamesuper);\r\n		\r\n		if (numberOfParens > 0) {\r\n			manageClosingParenthesizedExpression(qualifiedSuperReference, numberOfParens);\r\n		}\r\n		return false;\r\n	}\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.QualifiedThisReference, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(\r\n		QualifiedThisReference qualifiedThisReference,\r\n		BlockScope scope) {\r\n\r\n		final int numberOfParens = (qualifiedThisReference.bits & AstNode.ParenthesizedMASK) >> AstNode.ParenthesizedSHIFT;\r\n		if (numberOfParens > 0) {\r\n			manageOpeningParenthesizedExpression(qualifiedThisReference, numberOfParens);\r\n		}\r\n		qualifiedThisReference.qualification.traverse(this, scope);\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameDOT);\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNamethis);\r\n		\r\n		if (numberOfParens > 0) {\r\n			manageClosingParenthesizedExpression(qualifiedThisReference, numberOfParens);\r\n		}\r\n		return false;\r\n	}\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.QualifiedTypeReference, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(\r\n		QualifiedTypeReference qualifiedTypeReference,\r\n		BlockScope scope) {\r\n\r\n		final int numberOfParens = (qualifiedTypeReference.bits & AstNode.ParenthesizedMASK) >> AstNode.ParenthesizedSHIFT;\r\n		if (numberOfParens > 0) {\r\n			manageOpeningParenthesizedExpression(qualifiedTypeReference, numberOfParens);\r\n		}\r\n		this.scribe.printQualifiedReference(qualifiedTypeReference.sourceEnd + 1);\r\n		\r\n		if (numberOfParens > 0) {\r\n			manageClosingParenthesizedExpression(qualifiedTypeReference, numberOfParens);\r\n		}\r\n		return false;\r\n	}\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.QualifiedTypeReference, org.eclipse.jdt.internal.compiler.lookup.ClassScope)\r\n	 */\r\n	public boolean visit(\r\n		QualifiedTypeReference qualifiedTypeReference,\r\n		ClassScope scope) {\r\n\r\n			final int numberOfParens = (qualifiedTypeReference.bits & AstNode.ParenthesizedMASK) >> AstNode.ParenthesizedSHIFT;\r\n			if (numberOfParens > 0) {\r\n				manageOpeningParenthesizedExpression(qualifiedTypeReference, numberOfParens);\r\n			}\r\n			this.scribe.printQualifiedReference(qualifiedTypeReference.sourceEnd + 1);\r\n			\r\n			if (numberOfParens > 0) {\r\n				manageClosingParenthesizedExpression(qualifiedTypeReference, numberOfParens);\r\n			}\r\n			return false;\r\n	}\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.ReturnStatement, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(ReturnStatement returnStatement, BlockScope scope) {\r\n		\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNamereturn);\r\n		final Expression expression = returnStatement.expression;\r\n		if (expression != null) {\r\n			this.scribe.space();\r\n			expression.traverse(this, scope);\r\n		}\r\n		/*\r\n		 * Print the semi-colon\r\n		 */	\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameSEMICOLON, this.preferences.insert_space_before_semicolon);\r\n		return false;\r\n	}\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.AbstractSyntaxTreeVisitorAdapter#visit(org.eclipse.jdt.internal.compiler.ast.SingleNameReference, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(SingleNameReference singleNameReference, BlockScope scope) {\r\n\r\n		final int numberOfParens = (singleNameReference.bits & AstNode.ParenthesizedMASK) >> AstNode.ParenthesizedSHIFT;\r\n		if (numberOfParens > 0) {\r\n			manageOpeningParenthesizedExpression(singleNameReference, numberOfParens);\r\n		}\r\n		this.scribe.printNextToken(SINGLETYPEREFERENCE_EXPECTEDTOKENS, false, true);\r\n		\r\n		if (numberOfParens > 0) {\r\n			manageClosingParenthesizedExpression(singleNameReference, numberOfParens);\r\n		}\r\n		return false;\r\n	}\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.SingleTypeReference, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(\r\n		SingleTypeReference singleTypeReference,\r\n		BlockScope scope) {\r\n\r\n		final int numberOfParens = (singleTypeReference.bits & AstNode.ParenthesizedMASK) >> AstNode.ParenthesizedSHIFT;\r\n		if (numberOfParens > 0) {\r\n			manageOpeningParenthesizedExpression(singleTypeReference, numberOfParens);\r\n		}\r\n		this.scribe.printNextToken(SINGLETYPEREFERENCE_EXPECTEDTOKENS, false, true);\r\n\r\n		if (numberOfParens > 0) {\r\n			manageClosingParenthesizedExpression(singleTypeReference, numberOfParens);\r\n		}\r\n		return false;\r\n	}\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.SingleTypeReference, org.eclipse.jdt.internal.compiler.lookup.ClassScope)\r\n	 */\r\n	public boolean visit(\r\n		SingleTypeReference singleTypeReference,\r\n		ClassScope scope) {\r\n\r\n		final int numberOfParens = (singleTypeReference.bits & AstNode.ParenthesizedMASK) >> AstNode.ParenthesizedSHIFT;\r\n		if (numberOfParens > 0) {\r\n			manageOpeningParenthesizedExpression(singleTypeReference, numberOfParens);\r\n		}\r\n		this.scribe.printNextToken(SINGLETYPEREFERENCE_EXPECTEDTOKENS, false, true);\r\n\r\n		if (numberOfParens > 0) {\r\n			manageClosingParenthesizedExpression(singleTypeReference, numberOfParens);\r\n		}\r\n		return false;\r\n	}\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.StringLiteral, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(StringLiteral stringLiteral, BlockScope scope) {\r\n\r\n		final int numberOfParens = (stringLiteral.bits & AstNode.ParenthesizedMASK) >> AstNode.ParenthesizedSHIFT;\r\n		if (numberOfParens > 0) {\r\n			manageOpeningParenthesizedExpression(stringLiteral, numberOfParens);\r\n		}\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameStringLiteral);\r\n		\r\n		if (numberOfParens > 0) {\r\n			manageClosingParenthesizedExpression(stringLiteral, numberOfParens);\r\n		}\r\n		return false;\r\n	}\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.SuperReference, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(SuperReference superReference, BlockScope scope) {\r\n\r\n		final int numberOfParens = (superReference.bits & AstNode.ParenthesizedMASK) >> AstNode.ParenthesizedSHIFT;\r\n		if (numberOfParens > 0) {\r\n			manageOpeningParenthesizedExpression(superReference, numberOfParens);\r\n		}\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNamesuper);\r\n\r\n		if (numberOfParens > 0) {\r\n			manageClosingParenthesizedExpression(superReference, numberOfParens);\r\n		}\r\n		return false;\r\n	}\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.SwitchStatement, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(SwitchStatement switchStatement, BlockScope scope) {\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameswitch);\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameLPAREN, this.preferences.insert_space_before_switch_condition);\r\n		\r\n		if (this.preferences.insert_space_in_switch_condition) {\r\n			this.scribe.space();\r\n		}\r\n		\r\n		switchStatement.testExpression.traverse(this, scope);\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameRPAREN, this.preferences.insert_space_in_switch_condition);\r\n		/*\r\n		 * Type body\r\n		 */\r\n		String switch_brace = this.preferences.switch_brace_position;\r\n		formatOpeningBrace(switch_brace, this.preferences.insert_space_before_switch_open_brace);\r\n		this.scribe.printNewLine();\r\n\r\n		if (preferences.indent_switchstatements_compare_to_switch) {\r\n			this.scribe.indent();\r\n		}\r\n		final Statement[] statements = switchStatement.statements;\r\n		if (statements != null) {\r\n			int statementsLength = statements.length;\r\n			boolean wasABreak = false;\r\n			for (int i = 0; i < statementsLength; i++) {\r\n				final Statement statement = statements[i];\r\n				if (i == 0) {\r\n					// this is a case or a default statement\r\n					statement.traverse(this, scope);\r\n					if (this.preferences.indent_switchstatements_compare_to_cases) {\r\n						this.scribe.indent();\r\n					}\r\n				} else if (statement instanceof CaseStatement) {\r\n					if (wasABreak) {\r\n						if (this.preferences.indent_breaks_compare_to_cases) {\r\n							this.scribe.unIndent();\r\n						}\r\n					} else if (this.preferences.indent_switchstatements_compare_to_cases) {\r\n						this.scribe.unIndent();\r\n					}\r\n					statement.traverse(this, scope);\r\n					wasABreak = false;\r\n					if (this.preferences.indent_switchstatements_compare_to_cases) {\r\n						this.scribe.indent();\r\n					}\r\n				} else if (statement instanceof BreakStatement) {\r\n					wasABreak = true;\r\n					if (this.preferences.indent_switchstatements_compare_to_cases) {\r\n						if (!this.preferences.indent_breaks_compare_to_cases) {\r\n							this.scribe.unIndent();\r\n						}\r\n					} else if (this.preferences.indent_breaks_compare_to_cases) {\r\n						this.scribe.indent();\r\n					}\r\n					statement.traverse(this, scope);\r\n					if (i == statementsLength - 1 && this.preferences.indent_breaks_compare_to_cases) {\r\n						this.scribe.unIndent();\r\n					}\r\n				} else {\r\n					wasABreak = false;\r\n					statement.traverse(this, scope);\r\n					if (i == statementsLength - 1 && this.preferences.indent_switchstatements_compare_to_cases) {\r\n						this.scribe.unIndent();\r\n					}\r\n				}\r\n				if (statement instanceof Expression) {\r\n					/*\r\n					 * Print the semi-colon\r\n					 */	\r\n					this.scribe.printNextToken(ITerminalSymbols.TokenNameSEMICOLON, this.preferences.insert_space_before_semicolon);\r\n					this.scribe.printTrailingComment();\r\n				} else if (statement instanceof LocalDeclaration) {\r\n					LocalDeclaration currentLocal = (LocalDeclaration) statement;\r\n					if (i < (statementsLength - 1)) {\r\n						/* \r\n						 * We need to check that the next statement is a local declaration\r\n						 */\r\n						if (statements[i + 1] instanceof LocalDeclaration) {\r\n							LocalDeclaration nextLocal = (LocalDeclaration) statements[i + 1];\r\n							if (currentLocal.declarationSourceStart != nextLocal.declarationSourceStart) {\r\n								/*\r\n								 * Print the semi-colon\r\n								 */	\r\n								this.scribe.printNextToken(ITerminalSymbols.TokenNameSEMICOLON, this.preferences.insert_space_before_semicolon);\r\n								this.scribe.printTrailingComment();\r\n							}\r\n						} else {\r\n							/*\r\n							 * Print the semi-colon\r\n							 */	\r\n							this.scribe.printNextToken(ITerminalSymbols.TokenNameSEMICOLON, this.preferences.insert_space_before_semicolon);\r\n							this.scribe.printTrailingComment();\r\n						}\r\n					} else {\r\n						/*\r\n						 * Print the semi-colon\r\n						 */	\r\n						this.scribe.printNextToken(ITerminalSymbols.TokenNameSEMICOLON, this.preferences.insert_space_before_semicolon);\r\n						this.scribe.printTrailingComment();\r\n					}\r\n				} else {\r\n					this.scribe.printTrailingComment();\r\n				}\r\n				this.scribe.printNewLine();\r\n			}\r\n		}		\r\n		\r\n		if (preferences.indent_switchstatements_compare_to_switch) {\r\n			this.scribe.unIndent();\r\n		}\r\n		this.scribe.printNewLine();\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameRBRACE);\r\n		this.scribe.printTrailingComment();\r\n		if (switch_brace.equals(FormattingPreferences.NEXT_LINE_SHIFTED)) {\r\n			this.scribe.unIndent();\r\n		}		\r\n		return false;\r\n	}\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.SynchronizedStatement, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(\r\n		SynchronizedStatement synchronizedStatement,\r\n		BlockScope scope) {\r\n		\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNamesynchronized);\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameLPAREN, this.preferences.insert_space_before_synchronized_condition);\r\n		\r\n		if (this.preferences.insert_space_in_synchronized_condition) {\r\n			this.scribe.space();\r\n		}\r\n		synchronizedStatement.expression.traverse(this, scope);\r\n	\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameRPAREN, this.preferences.insert_space_in_synchronized_condition);\r\n		\r\n		synchronizedStatement.block.traverse(this, scope);\r\n		this.scribe.printTrailingComment();\r\n		return false;\r\n	}\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.ThisReference, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(ThisReference thisReference, BlockScope scope) {\r\n		\r\n		if (!thisReference.isImplicitThis()) {\r\n			final int numberOfParens = (thisReference.bits & AstNode.ParenthesizedMASK) >> AstNode.ParenthesizedSHIFT;\r\n			if (numberOfParens > 0) {\r\n				manageOpeningParenthesizedExpression(thisReference, numberOfParens);\r\n			}\r\n			this.scribe.printNextToken(ITerminalSymbols.TokenNamethis);\r\n			\r\n			if (numberOfParens > 0) {\r\n				manageClosingParenthesizedExpression(thisReference, numberOfParens);\r\n			}\r\n		}\r\n		return false;\r\n	}\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.ThrowStatement, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(ThrowStatement throwStatement, BlockScope scope) {\r\n\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNamethrow);\r\n		this.scribe.space();\r\n		throwStatement.exception.traverse(this, scope);\r\n		/*\r\n		 * Print the semi-colon\r\n		 */	\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameSEMICOLON, this.preferences.insert_space_before_semicolon);\r\n		return false;\r\n	}\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.TrueLiteral, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(TrueLiteral trueLiteral, BlockScope scope) {\r\n\r\n		final int numberOfParens = (trueLiteral.bits & AstNode.ParenthesizedMASK) >> AstNode.ParenthesizedSHIFT;\r\n		if (numberOfParens > 0) {\r\n			manageOpeningParenthesizedExpression(trueLiteral, numberOfParens);\r\n		}\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNametrue);\r\n\r\n		if (numberOfParens > 0) {\r\n			manageClosingParenthesizedExpression(trueLiteral, numberOfParens);\r\n		}\r\n		return false;\r\n	}\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.TryStatement, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(TryStatement tryStatement, BlockScope scope) {\r\n\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNametry);\r\n		tryStatement.tryBlock.traverse(this, scope);\r\n		if (this.preferences.insert_new_line_in_control_statements) {\r\n			this.scribe.printTrailingComment();\r\n		}	\r\n		if (tryStatement.catchArguments != null) {\r\n			for (int i = 0, max = tryStatement.catchBlocks.length; i < max; i++) {\r\n				this.scribe.printNextToken(ITerminalSymbols.TokenNamecatch, this.preferences.insert_space_after_block_close_brace);\r\n				this.scribe.printNextToken(ITerminalSymbols.TokenNameLPAREN, this.preferences.insert_space_before_catch_expression);\r\n				\r\n				if (this.preferences.insert_space_in_catch_expression) {\r\n					this.scribe.space();\r\n				}\r\n				\r\n				tryStatement.catchArguments[i].traverse(this, scope);\r\n			\r\n				this.scribe.printNextToken(ITerminalSymbols.TokenNameRPAREN, this.preferences.insert_space_in_catch_expression);\r\n				\r\n				tryStatement.catchBlocks[i].traverse(this, scope);\r\n				if (this.preferences.insert_new_line_in_control_statements) {\r\n					this.scribe.printTrailingComment();\r\n				}	\r\n			}\r\n		}\r\n		if (tryStatement.finallyBlock != null) {\r\n			this.scribe.printNextToken(ITerminalSymbols.TokenNamefinally, this.preferences.insert_space_after_block_close_brace);\r\n			tryStatement.finallyBlock.traverse(this, scope);\r\n			if (this.preferences.insert_new_line_in_control_statements) {\r\n				this.scribe.printTrailingComment();\r\n			}	\r\n		}\r\n		return false;\r\n	}\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.TypeDeclaration, org.eclipse.jdt.internal.compiler.lookup.CompilationUnitScope)\r\n	 */\r\n	public boolean visit(\r\n		TypeDeclaration typeDeclaration,\r\n		CompilationUnitScope scope) {\r\n\r\n		format(typeDeclaration);\r\n		return false;\r\n	}\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.UnaryExpression, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(UnaryExpression unaryExpression, BlockScope scope) {\r\n\r\n		final int numberOfParens = (unaryExpression.bits & AstNode.ParenthesizedMASK) >> AstNode.ParenthesizedSHIFT;\r\n		if (numberOfParens > 0) {\r\n			manageOpeningParenthesizedExpression(unaryExpression, numberOfParens);\r\n		}\r\n\r\n		/*\r\n		 * Print the operator\r\n		 */\r\n		int operator;\r\n		switch((unaryExpression.bits & AstNode.OperatorMASK) >> AstNode.OperatorSHIFT) {\r\n			case OperatorIds.PLUS:\r\n				operator = ITerminalSymbols.TokenNamePLUS;\r\n				break;\r\n			case OperatorIds.MINUS:\r\n				operator = ITerminalSymbols.TokenNameMINUS;\r\n				break;\r\n			case OperatorIds.TWIDDLE:\r\n				operator = ITerminalSymbols.TokenNameTWIDDLE;\r\n				break;\r\n			default:\r\n				operator = ITerminalSymbols.TokenNameNOT;\r\n		}\r\n\r\n		if (operator == ITerminalSymbols.TokenNameMINUS) {\r\n			this.scribe.printNextToken(operator, true);\r\n		} else {\r\n			this.scribe.printNextToken(operator, this.preferences.insert_space_before_unary_operator);\r\n		}\r\n		if (this.preferences.insert_space_after_unary_operator) {\r\n			this.scribe.space();\r\n		}\r\n		unaryExpression.expression.traverse(this, scope);\r\n\r\n		if (numberOfParens > 0) {\r\n			manageClosingParenthesizedExpression(unaryExpression, numberOfParens);\r\n		}\r\n		return false;\r\n	}\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.WhileStatement, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(WhileStatement whileStatement, BlockScope scope) {\r\n\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNamewhile);\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameLPAREN, this.preferences.insert_space_before_while_condition);\r\n		\r\n		if (this.preferences.insert_space_in_while_condition) {\r\n			this.scribe.space();\r\n		}\r\n		whileStatement.condition.traverse(this, scope);\r\n		\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameRPAREN, this.preferences.insert_space_in_while_condition);\r\n		\r\n		final Statement action = whileStatement.action;\r\n		if (action != null) {\r\n			if (action instanceof Block) {\r\n				action.traverse(this, scope);\r\n			} else {\r\n				this.scribe.printNewLine();\r\n				this.scribe.indent();\r\n				action.traverse(this, scope);\r\n				this.scribe.unIndent();\r\n			}\r\n			if (action instanceof Expression) {\r\n				this.scribe.printNextToken(ITerminalSymbols.TokenNameSEMICOLON, this.preferences.insert_space_before_semicolon);\r\n				this.scribe.printTrailingComment();\r\n			} else if (action instanceof Block) {\r\n				this.scribe.printTrailingComment();\r\n			}		\r\n		} else {\r\n			this.scribe.indent();\r\n			/*\r\n			 * This is an empty statement\r\n			 */\r\n			formatEmptyStatement(); \r\n			this.scribe.unIndent();\r\n		}\r\n\r\n		return false;\r\n	}\r\n}\r\n/*******************************************************************************\r\n * Copyright (c) 2002, 2003 International Business Machines Corp. and others.\r\n * All rights reserved. This program and the accompanying materials \r\n * are made available under the terms of the Common Public License v1.0 \r\n * which accompanies this distribution, and is available at\r\n * http://www.eclipse.org/legal/cpl-v10.html\r\n * \r\n * Contributors:\r\n *     IBM Corporation - initial API and implementation\r\n ******************************************************************************/\r\npackage org.eclipse.jdt.internal.formatter;\r\n\r\nimport java.util.Map;\r\n\r\nimport org.eclipse.jdt.core.JavaCore;\r\nimport org.eclipse.jdt.core.ToolFactory;\r\nimport org.eclipse.jdt.core.compiler.IProblem;\r\nimport org.eclipse.jdt.core.compiler.IScanner;\r\nimport org.eclipse.jdt.core.compiler.ITerminalSymbols;\r\nimport org.eclipse.jdt.core.compiler.InvalidInputException;\r\nimport org.eclipse.jdt.internal.compiler.AbstractSyntaxTreeVisitorAdapter;\r\nimport org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor;\r\nimport org.eclipse.jdt.internal.compiler.ast.AND_AND_Expression;\r\nimport org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration;\r\nimport org.eclipse.jdt.internal.compiler.ast.AllocationExpression;\r\nimport org.eclipse.jdt.internal.compiler.ast.AnonymousLocalTypeDeclaration;\r\nimport org.eclipse.jdt.internal.compiler.ast.Argument;\r\nimport org.eclipse.jdt.internal.compiler.ast.ArrayAllocationExpression;\r\nimport org.eclipse.jdt.internal.compiler.ast.ArrayInitializer;\r\nimport org.eclipse.jdt.internal.compiler.ast.ArrayQualifiedTypeReference;\r\nimport org.eclipse.jdt.internal.compiler.ast.ArrayReference;\r\nimport org.eclipse.jdt.internal.compiler.ast.ArrayTypeReference;\r\nimport org.eclipse.jdt.internal.compiler.ast.AssertStatement;\r\nimport org.eclipse.jdt.internal.compiler.ast.Assignment;\r\nimport org.eclipse.jdt.internal.compiler.ast.AstNode;\r\nimport org.eclipse.jdt.internal.compiler.ast.BinaryExpression;\r\nimport org.eclipse.jdt.internal.compiler.ast.Block;\r\nimport org.eclipse.jdt.internal.compiler.ast.BreakStatement;\r\nimport org.eclipse.jdt.internal.compiler.ast.CaseStatement;\r\nimport org.eclipse.jdt.internal.compiler.ast.CastExpression;\r\nimport org.eclipse.jdt.internal.compiler.ast.CharLiteral;\r\nimport org.eclipse.jdt.internal.compiler.ast.ClassLiteralAccess;\r\nimport org.eclipse.jdt.internal.compiler.ast.Clinit;\r\nimport org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration;\r\nimport org.eclipse.jdt.internal.compiler.ast.CompoundAssignment;\r\nimport org.eclipse.jdt.internal.compiler.ast.ConditionalExpression;\r\nimport org.eclipse.jdt.internal.compiler.ast.ConstructorDeclaration;\r\nimport org.eclipse.jdt.internal.compiler.ast.ContinueStatement;\r\nimport org.eclipse.jdt.internal.compiler.ast.DoStatement;\r\nimport org.eclipse.jdt.internal.compiler.ast.DoubleLiteral;\r\nimport org.eclipse.jdt.internal.compiler.ast.EmptyStatement;\r\nimport org.eclipse.jdt.internal.compiler.ast.EqualExpression;\r\nimport org.eclipse.jdt.internal.compiler.ast.ExplicitConstructorCall;\r\nimport org.eclipse.jdt.internal.compiler.ast.Expression;\r\nimport org.eclipse.jdt.internal.compiler.ast.FalseLiteral;\r\nimport org.eclipse.jdt.internal.compiler.ast.FieldDeclaration;\r\nimport org.eclipse.jdt.internal.compiler.ast.FieldReference;\r\nimport org.eclipse.jdt.internal.compiler.ast.FloatLiteral;\r\nimport org.eclipse.jdt.internal.compiler.ast.ForStatement;\r\nimport org.eclipse.jdt.internal.compiler.ast.IfStatement;\r\nimport org.eclipse.jdt.internal.compiler.ast.ImportReference;\r\nimport org.eclipse.jdt.internal.compiler.ast.Initializer;\r\nimport org.eclipse.jdt.internal.compiler.ast.InstanceOfExpression;\r\nimport org.eclipse.jdt.internal.compiler.ast.IntLiteral;\r\nimport org.eclipse.jdt.internal.compiler.ast.LabeledStatement;\r\nimport org.eclipse.jdt.internal.compiler.ast.LocalDeclaration;\r\nimport org.eclipse.jdt.internal.compiler.ast.LocalTypeDeclaration;\r\nimport org.eclipse.jdt.internal.compiler.ast.LongLiteral;\r\nimport org.eclipse.jdt.internal.compiler.ast.MemberTypeDeclaration;\r\nimport org.eclipse.jdt.internal.compiler.ast.MessageSend;\r\nimport org.eclipse.jdt.internal.compiler.ast.MethodDeclaration;\r\nimport org.eclipse.jdt.internal.compiler.ast.NullLiteral;\r\nimport org.eclipse.jdt.internal.compiler.ast.OR_OR_Expression;\r\nimport org.eclipse.jdt.internal.compiler.ast.OperatorIds;\r\nimport org.eclipse.jdt.internal.compiler.ast.PostfixExpression;\r\nimport org.eclipse.jdt.internal.compiler.ast.PrefixExpression;\r\nimport org.eclipse.jdt.internal.compiler.ast.QualifiedAllocationExpression;\r\nimport org.eclipse.jdt.internal.compiler.ast.QualifiedNameReference;\r\nimport org.eclipse.jdt.internal.compiler.ast.QualifiedSuperReference;\r\nimport org.eclipse.jdt.internal.compiler.ast.QualifiedThisReference;\r\nimport org.eclipse.jdt.internal.compiler.ast.QualifiedTypeReference;\r\nimport org.eclipse.jdt.internal.compiler.ast.ReturnStatement;\r\nimport org.eclipse.jdt.internal.compiler.ast.SingleNameReference;\r\nimport org.eclipse.jdt.internal.compiler.ast.SingleTypeReference;\r\nimport org.eclipse.jdt.internal.compiler.ast.Statement;\r\nimport org.eclipse.jdt.internal.compiler.ast.StringLiteral;\r\nimport org.eclipse.jdt.internal.compiler.ast.SuperReference;\r\nimport org.eclipse.jdt.internal.compiler.ast.SwitchStatement;\r\nimport org.eclipse.jdt.internal.compiler.ast.SynchronizedStatement;\r\nimport org.eclipse.jdt.internal.compiler.ast.ThisReference;\r\nimport org.eclipse.jdt.internal.compiler.ast.ThrowStatement;\r\nimport org.eclipse.jdt.internal.compiler.ast.TrueLiteral;\r\nimport org.eclipse.jdt.internal.compiler.ast.TryStatement;\r\nimport org.eclipse.jdt.internal.compiler.ast.TypeDeclaration;\r\nimport org.eclipse.jdt.internal.compiler.ast.TypeReference;\r\nimport org.eclipse.jdt.internal.compiler.ast.UnaryExpression;\r\nimport org.eclipse.jdt.internal.compiler.ast.WhileStatement;\r\nimport org.eclipse.jdt.internal.compiler.impl.Constant;\r\nimport org.eclipse.jdt.internal.compiler.lookup.BlockScope;\r\nimport org.eclipse.jdt.internal.compiler.lookup.ClassScope;\r\nimport org.eclipse.jdt.internal.compiler.lookup.CompilationUnitScope;\r\nimport org.eclipse.jdt.internal.compiler.lookup.CompilerModifiers;\r\nimport org.eclipse.jdt.internal.compiler.lookup.MethodScope;\r\nimport org.eclipse.jdt.internal.formatter.align.Alignment;\r\nimport org.eclipse.jdt.internal.formatter.align.AlignmentException;\r\n\r\n/**\r\n * This class is responsible for formatting a valid java source code.\r\n * @since 2.1\r\n */\r\n// TODO add line splitting for all remaining expression and statements\r\n// TODO find a way to handle complex boolean expression\r\n// TODO Add the ICodeFormatter extension point once the UI has fixed their code\r\n/*\r\n   <extension\r\n         id=\"org.eclipse.jdt.core.newformatter.codeformatter\"\r\n         name=\"org.eclipse.jdt.core.newformatter.codeformatter\"\r\n         point=\"org.eclipse.jdt.core.codeFormatter\">\r\n      <codeFormatter\r\n            class=\"org.eclipse.jdt.internal.formatter.CodeFormatterVisitor\">\r\n      </codeFormatter>\r\n   </extension>\r\n*/\r\npublic class CodeFormatterVisitor extends AbstractSyntaxTreeVisitorAdapter {\r\n\r\n	public static class MultiFieldDeclaration extends FieldDeclaration {\r\n		\r\n		FieldDeclaration[] declarations;\r\n		\r\n		MultiFieldDeclaration(FieldDeclaration[] declarations){\r\n			this.declarations = declarations;\r\n			this.modifiers = declarations[0].modifiers; \r\n		}\r\n	}\r\n	\r\n	public static boolean DEBUG = false;\r\n	private static final int NO_MODIFIERS = 0;\r\n	/*\r\n	 * Set of expected tokens type for a single type reference.\r\n	 * This array needs to be SORTED.\r\n	 */\r\n	private static final int[] SINGLETYPEREFERENCE_EXPECTEDTOKENS = new int[] {\r\n		ITerminalSymbols.TokenNameIdentifier,\r\n		ITerminalSymbols.TokenNameboolean,\r\n		ITerminalSymbols.TokenNamebyte,\r\n		ITerminalSymbols.TokenNamechar,\r\n		ITerminalSymbols.TokenNamedouble,\r\n		ITerminalSymbols.TokenNamefloat,\r\n		ITerminalSymbols.TokenNameint,\r\n		ITerminalSymbols.TokenNamelong,\r\n		ITerminalSymbols.TokenNameshort,\r\n		ITerminalSymbols.TokenNamevoid\r\n	};\r\n	private int chunkKind;\r\n	public int lastLocalDeclarationSourceStart;\r\n	private IScanner localScanner;\r\n	public FormattingPreferences preferences;\r\n	public Scribe scribe;\r\n	\r\n	/*\r\n	 * TODO: See how to choose the formatter\'s options. The extension point is calling\r\n	 * this constructor, but then there is no way to initialize the option used by the formatter.\r\n	 */ \r\n	public CodeFormatterVisitor() {\r\n		this(FormattingPreferences.getSunSetttings(), JavaCore.getOptions());\r\n	}\r\n\r\n	public CodeFormatterVisitor(FormattingPreferences preferences, Map settings) {\r\n		if (settings != null) {\r\n			String compiler_source = (String) settings.get(JavaCore.COMPILER_SOURCE);\r\n			if (compiler_source == null) {\r\n				this.localScanner = ToolFactory.createScanner(false, false, false, false);\r\n			} else {\r\n				this.localScanner = ToolFactory.createScanner(false, false, false, compiler_source);\r\n			}\r\n		} else {\r\n			this.localScanner = ToolFactory.createScanner(false, false, false, false);\r\n		}\r\n		// TODO set the java core options when common preferences are changed\r\n//		convertOldOptionsToPreferences(settings, preferences);\r\n		this.preferences = preferences;\r\n		this.scribe = new Scribe(this, settings);\r\n	}\r\n	\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#acceptProblem(org.eclipse.jdt.core.compiler.IProblem)\r\n	 */\r\n	public void acceptProblem(IProblem problem) {\r\n		super.acceptProblem(problem);\r\n	}\r\n\r\n	private BinaryExpressionFragmentBuilder buildFragments(BinaryExpression binaryExpression, BlockScope scope) {\r\n		BinaryExpressionFragmentBuilder builder = new BinaryExpressionFragmentBuilder();\r\n		\r\n		switch((binaryExpression.bits & AstNode.OperatorMASK) >> AstNode.OperatorSHIFT) {\r\n			case OperatorIds.AND_AND :\r\n				binaryExpression.left.traverse(builder, scope);\r\n				builder.operatorsList.add(new Integer(ITerminalSymbols.TokenNameAND_AND));\r\n				binaryExpression.right.traverse(builder, scope);\r\n				break;\r\n			case OperatorIds.OR_OR :\r\n				binaryExpression.left.traverse(builder, scope);\r\n				builder.operatorsList.add(new Integer(ITerminalSymbols.TokenNameOR_OR));\r\n				binaryExpression.right.traverse(builder, scope);\r\n				break;\r\n		}\r\n\r\n		return builder;\r\n	}\r\n\r\n	public boolean checkChunkStart(int kind) {\r\n		if (this.chunkKind != kind) {\r\n			this.chunkKind = kind;\r\n			return true;\r\n		}\r\n		return false;\r\n	}\r\n	\r\n	private AstNode[] computeMergedMemberDeclarations(TypeDeclaration typeDeclaration){\r\n		\r\n		int fieldIndex = 0, fieldCount = (typeDeclaration.fields == null) ? 0 : typeDeclaration.fields.length;\r\n		FieldDeclaration field = fieldCount == 0 ? null : typeDeclaration.fields[fieldIndex];\r\n		int fieldStart = field == null ? Integer.MAX_VALUE : field.declarationSourceStart;\r\n\r\n		int methodIndex = 0, methodCount = (typeDeclaration.methods == null) ? 0 : typeDeclaration.methods.length;\r\n		AbstractMethodDeclaration method = methodCount == 0 ? null : typeDeclaration.methods[methodIndex];\r\n		int methodStart = method == null ? Integer.MAX_VALUE : method.declarationSourceStart;\r\n\r\n		int typeIndex = 0, typeCount = (typeDeclaration.memberTypes == null) ? 0 : typeDeclaration.memberTypes.length;\r\n		MemberTypeDeclaration type = typeCount == 0 ? null : typeDeclaration.memberTypes[typeIndex];\r\n		int typeStart = type == null ? Integer.MAX_VALUE : type.declarationSourceStart;\r\n	\r\n		final int memberLength = fieldCount+methodCount+typeCount;\r\n		AstNode[] members = new AstNode[memberLength];\r\n		if (memberLength != 0) {\r\n			int index = 0;\r\n			int previousFieldStart = -1;\r\n			do {\r\n				if (fieldStart < methodStart && fieldStart < typeStart) {\r\n					// next member is a field\r\n					if (fieldStart == previousFieldStart){ \r\n						AstNode previousMember = members[index - 1];\r\n						if (previousMember instanceof MultiFieldDeclaration) {\r\n							MultiFieldDeclaration multiField = (MultiFieldDeclaration) previousMember;\r\n							int length = multiField.declarations.length;\r\n							System.arraycopy(multiField.declarations, 0, multiField.declarations=new FieldDeclaration[length+1], 0, length);\r\n							multiField.declarations[length] = (FieldDeclaration) field;\r\n						} else {\r\n							members[index - 1] = new MultiFieldDeclaration(new FieldDeclaration[]{ (FieldDeclaration)previousMember, field});\r\n						}\r\n					} else {\r\n						members[index++] = field;					\r\n					}\r\n					previousFieldStart = fieldStart;\r\n					if (++fieldIndex < fieldCount) { // find next field if any\r\n						fieldStart = (field = typeDeclaration.fields[fieldIndex]).declarationSourceStart;\r\n					} else {\r\n						fieldStart = Integer.MAX_VALUE;\r\n					}\r\n				} else if (methodStart < fieldStart && methodStart < typeStart) {\r\n					// next member is a method\r\n					if (!method.isDefaultConstructor() && !method.isClinit()) {\r\n						members[index++] = method;					\r\n					}\r\n					if (++methodIndex < methodCount) { // find next method if any\r\n						methodStart = (method = typeDeclaration.methods[methodIndex]).declarationSourceStart;\r\n					} else {\r\n						methodStart = Integer.MAX_VALUE;\r\n					}\r\n				} else {\r\n					// next member is a type\r\n					members[index++] = type;\r\n					if (++typeIndex < typeCount) { // find next type if any\r\n						typeStart = (type = typeDeclaration.memberTypes[typeIndex]).declarationSourceStart;\r\n					} else {\r\n						typeStart = Integer.MAX_VALUE;\r\n					}\r\n				}\r\n			} while ((fieldIndex < fieldCount) || (typeIndex < typeCount) || (methodIndex < methodCount));\r\n			\r\n			if (members.length != index) {\r\n				System.arraycopy(members, 0, members=new AstNode[index], 0, index);\r\n			}\r\n		}\r\n		return members;\r\n	}\r\n\r\n	void convertOldOptionsToPreferences(Map oldOptions, FormattingPreferences formattingPreferences) {\r\n		if (oldOptions == null) {\r\n			return;\r\n		}\r\n		Object[] entries = oldOptions.entrySet().toArray();\r\n		\r\n		for (int i = 0, max = entries.length; i < max; i++){\r\n			Map.Entry entry = (Map.Entry)entries[i];\r\n			if (!(entry.getKey() instanceof String)) continue;\r\n			if (!(entry.getValue() instanceof String)) continue;\r\n			String optionID = (String) entry.getKey();\r\n			String optionValue = (String) entry.getValue();\r\n			\r\n			if(optionID.equals(JavaCore.FORMATTER_NEWLINE_OPENING_BRACE)){\r\n				if (optionValue.equals(JavaCore.INSERT)){\r\n					formattingPreferences.anonymous_type_declaration_brace_position = FormattingPreferences.NEXT_LINE;\r\n					formattingPreferences.type_declaration_brace_position = FormattingPreferences.NEXT_LINE;\r\n					formattingPreferences.method_declaration_brace_position = FormattingPreferences.NEXT_LINE;\r\n					formattingPreferences.block_brace_position = FormattingPreferences.NEXT_LINE;\r\n					formattingPreferences.switch_brace_position = FormattingPreferences.NEXT_LINE;\r\n				} else if (optionValue.equals(JavaCore.DO_NOT_INSERT)){\r\n					formattingPreferences.anonymous_type_declaration_brace_position = FormattingPreferences.END_OF_LINE;\r\n					formattingPreferences.type_declaration_brace_position = FormattingPreferences.END_OF_LINE;\r\n					formattingPreferences.method_declaration_brace_position = FormattingPreferences.END_OF_LINE;\r\n					formattingPreferences.block_brace_position = FormattingPreferences.END_OF_LINE;\r\n					formattingPreferences.switch_brace_position = FormattingPreferences.END_OF_LINE;\r\n				}\r\n				continue;\r\n			}\r\n			if(optionID.equals(JavaCore.FORMATTER_NEWLINE_CONTROL)) {\r\n				if (optionValue.equals(JavaCore.INSERT)){\r\n					formattingPreferences.insert_new_line_in_control_statements = true;\r\n				} else if (optionValue.equals(JavaCore.DO_NOT_INSERT)){\r\n					formattingPreferences.insert_new_line_in_control_statements = false;\r\n				}\r\n				continue;\r\n			}\r\n			if(optionID.equals(JavaCore.FORMATTER_CLEAR_BLANK_LINES)) {\r\n				if (optionValue.equals(JavaCore.CLEAR_ALL)){\r\n					formattingPreferences.number_of_empty_lines_to_preserve = 0;\r\n				} else if (optionValue.equals(JavaCore.PRESERVE_ONE)){\r\n					formattingPreferences.number_of_empty_lines_to_preserve = 1;\r\n				}\r\n				continue;\r\n			}\r\n			if(optionID.equals(JavaCore.FORMATTER_NEWLINE_ELSE_IF)){\r\n				if (optionValue.equals(JavaCore.INSERT)){\r\n					formattingPreferences.compact_else_if = false;\r\n				} else if (optionValue.equals(JavaCore.DO_NOT_INSERT)){\r\n					formattingPreferences.compact_else_if = true;\r\n				}\r\n				continue;\r\n			}\r\n			if(optionID.equals(JavaCore.FORMATTER_NEWLINE_EMPTY_BLOCK)){\r\n				if (optionValue.equals(JavaCore.INSERT)){\r\n					formattingPreferences.insert_new_line_in_empty_anonymous_type_declaration = true;\r\n					formattingPreferences.insert_new_line_in_empty_type_declaration = true;\r\n					formattingPreferences.insert_new_line_in_empty_method_body = true;\r\n					formattingPreferences.insert_new_line_in_empty_block = true;\r\n				} else if (optionValue.equals(JavaCore.DO_NOT_INSERT)){\r\n					formattingPreferences.insert_new_line_in_empty_anonymous_type_declaration = false;\r\n					formattingPreferences.insert_new_line_in_empty_type_declaration = false;\r\n					formattingPreferences.insert_new_line_in_empty_method_body = false;\r\n					formattingPreferences.insert_new_line_in_empty_block = false;\r\n				}\r\n				continue;\r\n			}\r\n			if(optionID.equals(JavaCore.FORMATTER_LINE_SPLIT)){\r\n				try {\r\n					int val = Integer.parseInt(optionValue);\r\n					if (val >= 0) {\r\n						formattingPreferences.page_width = val;\r\n					}\r\n				} catch(NumberFormatException e){\r\n				}\r\n			}\r\n			if(optionID.equals(JavaCore.FORMATTER_COMPACT_ASSIGNMENT)){\r\n				if (optionValue.equals(JavaCore.COMPACT)){\r\n					formattingPreferences.insert_space_before_assignment_operators = false;\r\n				} else if (optionValue.equals(JavaCore.NORMAL)){\r\n					formattingPreferences.insert_space_before_assignment_operators = true;\r\n				}\r\n				continue;\r\n			}\r\n			if(optionID.equals(JavaCore.FORMATTER_TAB_CHAR)){\r\n				if (optionValue.equals(JavaCore.TAB)){\r\n					formattingPreferences.use_tab = true;\r\n				} else if (optionValue.equals(JavaCore.SPACE)){\r\n					formattingPreferences.use_tab = false;\r\n				}\r\n				continue;\r\n			}\r\n			if(optionID.equals(JavaCore.FORMATTER_TAB_SIZE)){\r\n				try {\r\n					int val = Integer.parseInt(optionValue);\r\n					if (val > 0) {\r\n						formattingPreferences.tab_size = val;\r\n					}\r\n				} catch(NumberFormatException e){\r\n				}\r\n			}\r\n			if(optionID.equals(JavaCore.FORMATTER_SPACE_CASTEXPRESSION)){\r\n				if (optionValue.equals(JavaCore.INSERT)){\r\n					formattingPreferences.insert_space_after_closing_paren_in_cast = true;\r\n				} else if (optionValue.equals(JavaCore.DO_NOT_INSERT)){\r\n					formattingPreferences.insert_space_after_closing_paren_in_cast = false;\r\n				}\r\n				continue;\r\n			}		\r\n		}		\r\n	}\r\n\r\n	private boolean dumpBinaryExpression(\r\n		BinaryExpression binaryExpression,\r\n		int operator,\r\n		BlockScope scope) {\r\n\r\n		final int numberOfParens = (binaryExpression.bits & AstNode.ParenthesizedMASK) >> AstNode.ParenthesizedSHIFT;\r\n\r\n		if (numberOfParens > 0) {\r\n			manageOpeningParenthesizedExpression(binaryExpression, numberOfParens);\r\n		}	\r\n		BinaryExpressionFragmentBuilder builder = buildFragments(binaryExpression, scope);\r\n		final int fragmentsSize = builder.size();\r\n		\r\n		if (fragmentsSize > 1) {\r\n			Alignment binaryExpressionAlignment = this.scribe.createAlignment(\"binaryExpressionAlignment\", this.preferences.binary_expression_alignment, fragmentsSize, this.scribe.scanner.currentPosition); //$NON-NLS-1$\r\n			this.scribe.enterAlignment(binaryExpressionAlignment);\r\n			boolean ok = false;\r\n			AstNode[] fragments = builder.fragments();\r\n			int[] operators = builder.operators();\r\n			do {\r\n				try {\r\n					for (int i = 0; i < fragmentsSize - 1; i++) {\r\n						AstNode fragment = fragments[i];\r\n						fragment.traverse(this, scope);\r\n						this.scribe.alignFragment(binaryExpressionAlignment, i);\r\n						this.scribe.printNextToken(operators[i], this.preferences.insert_space_before_binary_operator);\r\n						if (this.preferences.insert_space_after_binary_operator) {\r\n							this.scribe.space();\r\n						}						\r\n					}\r\n					fragments[fragmentsSize - 1].traverse(this, scope);\r\n					ok = true;\r\n				} catch(AlignmentException e){\r\n					this.scribe.redoAlignment(e);\r\n				}\r\n			} while (!ok);		\r\n			this.scribe.exitAlignment(binaryExpressionAlignment, true);\r\n		} else {\r\n			binaryExpression.left.traverse(this, scope);\r\n			this.scribe.printNextToken(operator, this.preferences.insert_space_before_binary_operator);\r\n			if (this.preferences.insert_space_after_binary_operator) {\r\n				this.scribe.space();\r\n			}\r\n			binaryExpression.right.traverse(this, scope);\r\n		}	\r\n		if (numberOfParens > 0) {\r\n			manageClosingParenthesizedExpression(binaryExpression, numberOfParens);\r\n		}\r\n		return false;\r\n	}\r\n\r\n	private String failedToFormat(final char[] compilationUnitSource) {\r\n		StringBuffer buffer = new StringBuffer(this.scribe.formattedSource());\r\n		buffer.append(compilationUnitSource, this.scribe.scanner.getCurrentTokenEndPosition(), this.scribe.scannerEndPosition - this.scribe.scanner.getCurrentTokenEndPosition());\r\n		System.out.println(\"COULD NOT FORMAT \\n\" + this.scribe.scanner); //$NON-NLS-1$\r\n		if (DEBUG) {\r\n			System.out.println(this.scribe);\r\n		}\r\n		return buffer.toString();\r\n	}\r\n\r\n	private void format(\r\n		AbstractMethodDeclaration methodDeclaration,\r\n		ClassScope scope,\r\n		boolean isChunkStart) {\r\n\r\n		final int newLineBeforeChunk = isChunkStart ? this.preferences.blank_lines_before_new_chunk : 0;\r\n		if (newLineBeforeChunk > 0) {\r\n			this.scribe.printNewLines(newLineBeforeChunk);\r\n		}\r\n		final int newLinesBeforeMethod = this.preferences.blank_lines_before_method;\r\n		if (newLinesBeforeMethod > 0) {\r\n			this.scribe.printNewLines(newLinesBeforeMethod);\r\n		}\r\n		methodDeclaration.traverse(this, scope);\r\n	}\r\n	\r\n	private void format(FieldDeclaration fieldDeclaration, IAbstractSyntaxTreeVisitor visitor, MethodScope scope, boolean isChunkStart) {\r\n		\r\n		int newLineBeforeChunk = isChunkStart ? this.preferences.blank_lines_before_new_chunk : 0;\r\n		if (newLineBeforeChunk > 0) {\r\n			this.scribe.printNewLines(newLineBeforeChunk);\r\n		}\r\n		final int newLinesBeforeField = this.preferences.blank_lines_before_field;\r\n		if (newLinesBeforeField > 0) {\r\n			this.scribe.printNewLines(newLinesBeforeField);\r\n		}\r\n		Alignment fieldAlignment = this.scribe.getAlignment(\"typeMembers\");	//$NON-NLS-1$\r\n\r\n		if (fieldDeclaration.modifiers != NO_MODIFIERS) {\r\n			this.scribe.printModifiers();\r\n		}\r\n		/*\r\n		 * Field type\r\n		 */\r\n		this.scribe.alignFragment(fieldAlignment, 0);\r\n\r\n		fieldDeclaration.type.traverse(this, scope);\r\n		\r\n		/*\r\n		 * Field name\r\n		 */\r\n		this.scribe.alignFragment(fieldAlignment, 1);\r\n\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameIdentifier, true);\r\n\r\n		/*\r\n		 * Check for extra dimensions\r\n		 */\r\n		int extraDimensions = getExtraDimension();\r\n		if (extraDimensions != 0) {\r\n			 for (int i = 0; i < extraDimensions; i++) {\r\n			 	this.scribe.printNextToken(ITerminalSymbols.TokenNameLBRACKET);\r\n			 	this.scribe.printNextToken(ITerminalSymbols.TokenNameRBRACKET);\r\n			 }\r\n		}\r\n	\r\n		/*\r\n		 * Field initialization\r\n		 */\r\n		if (fieldDeclaration.initialization != null) {\r\n			this.scribe.alignFragment(fieldAlignment, 2);\r\n			this.scribe.printNextToken(ITerminalSymbols.TokenNameEQUAL, this.preferences.insert_space_before_assignment_operators);\r\n			if (this.preferences.insert_space_after_assignment_operators) {\r\n				this.scribe.space();\r\n			}\r\n			fieldDeclaration.initialization.traverse(this, scope);\r\n		}\r\n		\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameSEMICOLON, this.preferences.insert_space_before_semicolon);\r\n\r\n		if (fieldDeclaration.initialization == null) {\r\n			this.scribe.alignFragment(fieldAlignment, 2);\r\n		}\r\n\r\n		if (fieldAlignment != null) {\r\n			this.scribe.alignFragment(fieldAlignment, 3);\r\n			this.scribe.printTrailingComment();\r\n			this.scribe.printNewLine();\r\n			this.scribe.exitAlignment(fieldAlignment, false);\r\n		} else {\r\n			this.scribe.space();\r\n			this.scribe.printTrailingComment();\r\n			this.scribe.printNewLine();\r\n		}\r\n	}\r\n\r\n	private void format(\r\n		MemberTypeDeclaration memberTypeDeclaration,\r\n		ClassScope scope,\r\n		boolean isChunkStart) {\r\n\r\n		int newLineBeforeChunk = isChunkStart ? this.preferences.blank_lines_before_new_chunk : 0;\r\n		if (newLineBeforeChunk > 0) {\r\n			this.scribe.printNewLines(newLineBeforeChunk);\r\n		}\r\n		final int newLinesBeforeMember = this.preferences.blank_lines_before_member_type;\r\n		if (newLinesBeforeMember > 0) {\r\n			this.scribe.printNewLines(newLinesBeforeMember);\r\n		}\r\n		memberTypeDeclaration.traverse(this, scope);\r\n	}\r\n	\r\n	private void format(MultiFieldDeclaration multiFieldDeclaration, IAbstractSyntaxTreeVisitor visitor, MethodScope scope, boolean isChunkStart) {\r\n\r\n		int newLineBeforeChunk = isChunkStart ? this.preferences.blank_lines_before_new_chunk : 0;\r\n		if (newLineBeforeChunk > 0) {\r\n			this.scribe.printNewLines(newLineBeforeChunk);\r\n		}\r\n		final int newLinesBeforeField = this.preferences.blank_lines_before_field;\r\n		if (newLinesBeforeField > 0) {\r\n			this.scribe.printNewLines(newLinesBeforeField);\r\n		}\r\n		Alignment fieldAlignment = this.scribe.getAlignment(\"typeMembers\");	//$NON-NLS-1$\r\n\r\n		if (multiFieldDeclaration.declarations[0].modifiers != NO_MODIFIERS) {\r\n			this.scribe.printModifiers();\r\n		}\r\n		this.scribe.alignFragment(fieldAlignment, 0);\r\n\r\n		multiFieldDeclaration.declarations[0].type.traverse(this, scope);\r\n\r\n		for (int i = 0, length = multiFieldDeclaration.declarations.length; i < length; i++) {\r\n			FieldDeclaration fieldDeclaration = multiFieldDeclaration.declarations[i];\r\n			/*\r\n			 * Field name\r\n			 */\r\n			if (i == 0) {\r\n				this.scribe.alignFragment(fieldAlignment, 1);\r\n			}\r\n			this.scribe.printNextToken(ITerminalSymbols.TokenNameIdentifier, true);\r\n	\r\n			/*\r\n			 * Check for extra dimensions\r\n			 */\r\n			int extraDimensions = getExtraDimension();\r\n			if (extraDimensions != 0) {\r\n				 for (int index = 0; index < extraDimensions; index++) {\r\n				 	this.scribe.printNextToken(ITerminalSymbols.TokenNameLBRACKET);\r\n				 	this.scribe.printNextToken(ITerminalSymbols.TokenNameRBRACKET);\r\n				 }\r\n			}\r\n		\r\n			/*\r\n			 * Field initialization\r\n			 */\r\n			if (fieldDeclaration.initialization != null) {\r\n				if (i == 0) {\r\n					this.scribe.alignFragment(fieldAlignment, 2);\r\n				}\r\n				this.scribe.printNextToken(ITerminalSymbols.TokenNameEQUAL, this.preferences.insert_space_before_assignment_operators);\r\n				if (this.preferences.insert_space_after_assignment_operators) {\r\n					this.scribe.space();\r\n				}\r\n				fieldDeclaration.initialization.traverse(this, scope);\r\n			}\r\n			\r\n			if (i != length - 1) {\r\n				if (i == 0 && fieldDeclaration.initialization == null) {\r\n					this.scribe.alignFragment(fieldAlignment, 2);\r\n				}				\r\n				this.scribe.printNextToken(ITerminalSymbols.TokenNameCOMMA, this.preferences.insert_space_before_comma_in_multiple_field_declarations);\r\n				if (this.preferences.insert_space_after_comma_in_multiple_field_declarations) {\r\n					this.scribe.space();\r\n				}\r\n			} else {\r\n				this.scribe.printNextToken(ITerminalSymbols.TokenNameSEMICOLON, this.preferences.insert_space_before_semicolon);\r\n				\r\n				this.scribe.alignFragment(fieldAlignment, 3);\r\n				this.scribe.printTrailingComment();\r\n				this.scribe.printNewLine();\r\n			}\r\n		}\r\n		if (fieldAlignment != null) {\r\n			this.scribe.exitAlignment(fieldAlignment, false);\r\n		}\r\n	}\r\n	\r\n	/**\r\n	 * @see org.eclipse.jdt.core.ICodeFormatter#format(java.lang.String, int, int, java.lang.String)\r\n	 */\r\n	public String format(String string, int[] positions, AstNode[] nodes) {\r\n		// reset the scribe\r\n		this.scribe.reset(positions);\r\n		\r\n		long startTime = System.currentTimeMillis();\r\n\r\n		final char[] compilationUnitSource = string.toCharArray();\r\n		\r\n		this.scribe.scanner.setSource(compilationUnitSource);\r\n		this.localScanner.setSource(compilationUnitSource);\r\n		this.scribe.scannerEndPosition = compilationUnitSource.length;\r\n		this.scribe.scanner.resetTo(0, this.scribe.scannerEndPosition);\r\n		if (nodes == null) {\r\n			return string;\r\n		}\r\n\r\n		this.lastLocalDeclarationSourceStart = 0;\r\n		try {\r\n			if (nodes != null) {\r\n				formatClassBodyDeclarations(nodes);\r\n			}\r\n		} catch(AbortFormatting e){\r\n			return failedToFormat(compilationUnitSource);\r\n		}\r\n		if (DEBUG){\r\n			System.out.println(\"Formatting time: \" + (System.currentTimeMillis() - startTime));  //$NON-NLS-1$\r\n		}\r\n		return this.scribe.toString();\r\n	}\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.core.ICodeFormatter#format(java.lang.String, int, int, java.lang.String)\r\n	 */\r\n	public String format(String string, int[] positions, CompilationUnitDeclaration compilationUnitDeclaration) {\r\n		// reset the scribe\r\n		this.scribe.reset(positions);\r\n		\r\n		long startTime = System.currentTimeMillis();\r\n\r\n		final char[] compilationUnitSource = string.toCharArray();\r\n		\r\n		this.scribe.scanner.setSource(compilationUnitSource);\r\n		this.localScanner.setSource(compilationUnitSource);\r\n		this.scribe.scannerEndPosition = compilationUnitSource.length;\r\n		this.scribe.scanner.resetTo(0, this.scribe.scannerEndPosition);\r\n		if (compilationUnitDeclaration == null || compilationUnitDeclaration.ignoreFurtherInvestigation) {\r\n			return string;\r\n		}\r\n\r\n		this.lastLocalDeclarationSourceStart = 0;\r\n		try {\r\n			compilationUnitDeclaration.traverse(this, compilationUnitDeclaration.scope);\r\n		} catch(AbortFormatting e){\r\n			return failedToFormat(compilationUnitSource);\r\n		}\r\n		if (DEBUG){\r\n			System.out.println(\"Formatting time: \" + (System.currentTimeMillis() - startTime));  //$NON-NLS-1$\r\n		}\r\n		return this.scribe.toString();\r\n	}\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.core.ICodeFormatter#format(java.lang.String, int, int, java.lang.String)\r\n	 */\r\n	public String format(String string, int[] positions, ConstructorDeclaration constructorDeclaration) {\r\n		// reset the scribe\r\n		this.scribe.reset(positions);\r\n		\r\n		long startTime = System.currentTimeMillis();\r\n\r\n		final char[] compilationUnitSource = string.toCharArray();\r\n		\r\n		this.scribe.scanner.setSource(compilationUnitSource);\r\n		this.localScanner.setSource(compilationUnitSource);\r\n		this.scribe.scannerEndPosition = compilationUnitSource.length;\r\n		this.scribe.scanner.resetTo(0, this.scribe.scannerEndPosition);\r\n		if (constructorDeclaration == null) {\r\n			return string;\r\n		}\r\n\r\n		this.lastLocalDeclarationSourceStart = 0;\r\n		try {\r\n			ExplicitConstructorCall explicitConstructorCall = constructorDeclaration.constructorCall;\r\n			if (explicitConstructorCall != SuperReference.implicitSuperConstructorCall()) {\r\n				explicitConstructorCall.traverse(this, null);\r\n			}\r\n			Statement[] statements = constructorDeclaration.statements;\r\n			if (statements != null) {\r\n				formatStatements(null, statements);\r\n			}\r\n			this.scribe.printComment();\r\n		} catch(AbortFormatting e){\r\n			return failedToFormat(compilationUnitSource);\r\n		}\r\n		if (DEBUG){\r\n			System.out.println(\"Formatting time: \" + (System.currentTimeMillis() - startTime));  //$NON-NLS-1$\r\n		}\r\n		return this.scribe.toString();\r\n	}\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.core.ICodeFormatter#format(java.lang.String, int, int, java.lang.String)\r\n	 */\r\n	public String format(String string, int[] positions, Expression expression) {\r\n		// reset the scribe\r\n		this.scribe.reset(positions);\r\n		\r\n		long startTime = System.currentTimeMillis();\r\n\r\n		final char[] compilationUnitSource = string.toCharArray();\r\n		\r\n		this.scribe.scanner.setSource(compilationUnitSource);\r\n		this.localScanner.setSource(compilationUnitSource);\r\n		this.scribe.scannerEndPosition = compilationUnitSource.length;\r\n		this.scribe.scanner.resetTo(0, this.scribe.scannerEndPosition);\r\n		if (expression == null) {\r\n			return string;\r\n		}\r\n\r\n		this.lastLocalDeclarationSourceStart = 0;\r\n		try {\r\n			expression.traverse(this, null);\r\n			this.scribe.printComment();\r\n		} catch(AbortFormatting e){\r\n			return failedToFormat(compilationUnitSource);\r\n		}\r\n		if (DEBUG){\r\n			System.out.println(\"Formatting time: \" + (System.currentTimeMillis() - startTime));  //$NON-NLS-1$\r\n		}\r\n		return this.scribe.toString();\r\n	}\r\n	\r\n	private void format(TypeDeclaration typeDeclaration){\r\n\r\n		if (typeDeclaration.modifiers != NO_MODIFIERS) {\r\n			this.scribe.printModifiers();\r\n		} else {\r\n			this.scribe.printComment();\r\n		}\r\n		/*\r\n		 * Type name\r\n		 */\r\n		if (typeDeclaration.isInterface()) {\r\n			this.scribe.printNextToken(ITerminalSymbols.TokenNameinterface, true); \r\n		} else {\r\n			this.scribe.printNextToken(ITerminalSymbols.TokenNameclass, true); \r\n		}\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameIdentifier, true); \r\n\r\n		/* \r\n		 * Superclass \r\n		 */\r\n		final TypeReference superclass = typeDeclaration.superclass;\r\n		if (superclass != null) {\r\n			Alignment superclassAlignment =this.scribe.createAlignment(\r\n					\"superclass\", //$NON-NLS-1$\r\n					this.preferences.type_declaration_superclass_alignment,\r\n					2,\r\n					this.scribe.scanner.currentPosition);\r\n			this.scribe.enterAlignment(superclassAlignment);\r\n			boolean ok = false;\r\n			do {\r\n				try {\r\n					this.scribe.alignFragment(superclassAlignment, 0);\r\n					this.scribe.printNextToken(ITerminalSymbols.TokenNameextends, true);\r\n					this.scribe.alignFragment(superclassAlignment, 1);\r\n					this.scribe.space();\r\n					superclass.traverse(this, typeDeclaration.scope);\r\n					ok = true;\r\n				} catch (AlignmentException e) {\r\n					this.scribe.redoAlignment(e);\r\n				}\r\n			} while (!ok);\r\n			this.scribe.exitAlignment(superclassAlignment, true); \r\n		}\r\n\r\n		/* \r\n		 * Super Interfaces \r\n		 */\r\n		final TypeReference[] superInterfaces = typeDeclaration.superInterfaces;\r\n		if (superInterfaces != null) {\r\n			\r\n			int superInterfaceLength = superInterfaces.length;\r\n			Alignment interfaceAlignment =this.scribe.createAlignment(\r\n					\"superInterfaces\",//$NON-NLS-1$\r\n					this.preferences.type_declaration_superinterfaces_alignment,\r\n					superInterfaceLength+1,  // implements token is first fragment\r\n					this.scribe.scanner.currentPosition);\r\n			this.scribe.enterAlignment(interfaceAlignment);\r\n			boolean ok = false;\r\n			do {\r\n				try {\r\n					this.scribe.alignFragment(interfaceAlignment, 0);\r\n					if (typeDeclaration.isInterface()) {\r\n						this.scribe.printNextToken(ITerminalSymbols.TokenNameextends, true);\r\n					} else  {\r\n						this.scribe.printNextToken(ITerminalSymbols.TokenNameimplements, true);\r\n					}\r\n					for (int i = 0; i < superInterfaceLength; i++) {\r\n						if (i > 0) {\r\n							this.scribe.printNextToken(ITerminalSymbols.TokenNameCOMMA, this.preferences.insert_space_before_comma_in_superinterfaces);\r\n							this.scribe.alignFragment(interfaceAlignment, i+1);\r\n							if (this.preferences.insert_space_after_comma_in_superinterfaces) {\r\n								this.scribe.space();\r\n							}\r\n							superInterfaces[i].traverse(this, typeDeclaration.scope);\r\n						} else {\r\n							this.scribe.alignFragment(interfaceAlignment, i+1);\r\n							this.scribe.space();\r\n							superInterfaces[i].traverse(this, typeDeclaration.scope);\r\n						}\r\n					}\r\n					ok = true;\r\n				} catch (AlignmentException e) {\r\n					this.scribe.redoAlignment(e);\r\n				}\r\n			} while (!ok);\r\n			this.scribe.exitAlignment(interfaceAlignment, true);\r\n		}\r\n\r\n		/*\r\n		 * Type body\r\n		 */\r\n		String class_declaration_brace = this.preferences.type_declaration_brace_position;\r\n\r\n		formatTypeOpeningBrace(class_declaration_brace, this.preferences.insert_space_before_type_open_brace, typeDeclaration);\r\n		\r\n		if (this.preferences.indent_body_declarations_compare_to_type_header) {\r\n			this.scribe.indent();\r\n		}\r\n\r\n		formatTypeMembers(typeDeclaration);\r\n\r\n		this.scribe.printComment();\r\n		\r\n		if (this.preferences.indent_body_declarations_compare_to_type_header) {\r\n			this.scribe.unIndent();\r\n		}\r\n		\r\n		if (this.preferences.insert_new_line_in_empty_type_declaration) {\r\n			this.scribe.printNewLine();\r\n		}\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameRBRACE);\r\n		this.scribe.printTrailingComment();\r\n		if (class_declaration_brace.equals(FormattingPreferences.NEXT_LINE_SHIFTED)) {\r\n			this.scribe.unIndent();\r\n		}\r\n	}\r\n\r\n	/*\r\n	 * Merged traversal of member (types, fields, methods)\r\n	 */\r\n	private void formatClassBodyDeclarations(AstNode[] nodes) {\r\n		final int FIELD = 1, METHOD = 2, TYPE = 3;\r\n		\r\n		Alignment memberAlignment = this.scribe.createAlignment(\"typeMembers\", this.preferences.type_member_alignment, 4, this.scribe.scanner.currentPosition); //$NON-NLS-1$\r\n		this.scribe.enterAlignment(memberAlignment);\r\n		boolean isChunkStart = false;\r\n		boolean ok = false;\r\n		int startIndex = 0;\r\n		do {\r\n			try {\r\n				for (int i = startIndex, max = nodes.length; i < max; i++) {\r\n					AstNode member = nodes[i];\r\n					if (member instanceof FieldDeclaration) {\r\n						isChunkStart = memberAlignment.checkChunkStart(FIELD, i, this.scribe.scanner.currentPosition);\r\n						if (member instanceof MultiFieldDeclaration){\r\n							MultiFieldDeclaration multiField = (MultiFieldDeclaration) member;\r\n							\r\n							if (multiField.isStatic()) {\r\n								format(multiField, this, null, isChunkStart);\r\n							} else {\r\n								format(multiField, this, null, isChunkStart);\r\n							}					\r\n						} else if (member instanceof Initializer) {\r\n							Initializer initializer = (Initializer) member;\r\n							if (initializer.isStatic()) {\r\n								initializer.traverse(this, null);\r\n							} else {\r\n								initializer.traverse(this, null);\r\n							}					\r\n						} else {\r\n							FieldDeclaration field = (FieldDeclaration) member;\r\n							if (field.isStatic()) {\r\n								format(field, this, null, isChunkStart);\r\n							} else {\r\n								format(field, this, null, isChunkStart);\r\n							}					\r\n						}\r\n					} else if (member instanceof AbstractMethodDeclaration) {\r\n						isChunkStart = memberAlignment.checkChunkStart(METHOD, i, this.scribe.scanner.currentPosition);\r\n						format((AbstractMethodDeclaration) member, null, isChunkStart);\r\n					} else {\r\n						isChunkStart = memberAlignment.checkChunkStart(TYPE, i, this.scribe.scanner.currentPosition);\r\n						format((MemberTypeDeclaration)member, null, isChunkStart);\r\n					}\r\n					if (isSemiColon()) {\r\n						this.scribe.printNextToken(ITerminalSymbols.TokenNameSEMICOLON, this.preferences.insert_space_before_semicolon);\r\n						this.scribe.printTrailingComment();\r\n					}\r\n				}\r\n				ok = true;\r\n			} catch(AlignmentException e){\r\n				startIndex = memberAlignment.chunkStartIndex;\r\n				this.scribe.redoAlignment(e);\r\n			}\r\n		} while (!ok);		\r\n		this.scribe.exitAlignment(memberAlignment, true);\r\n		this.scribe.printComment();\r\n	}\r\n	\r\n	private void formatEmptyStatement() {\r\n\r\n		if (this.preferences.put_empty_statement_on_new_line) {\r\n			this.scribe.printNewLine();\r\n		}\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameSEMICOLON, this.preferences.insert_space_before_semicolon);\r\n		this.scribe.printTrailingComment();\r\n		this.scribe.printNewLine();\r\n	}\r\n\r\n	private void formatGuardClauseBlock(Block block, BlockScope scope) {\r\n\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameLBRACE, this.preferences.insert_space_before_block_open_brace);\r\n		this.scribe.space();\r\n\r\n		final Statement[] statements = block.statements;\r\n		statements[0].traverse(this, scope);\r\n		this.scribe.space();\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameRBRACE, false, true);\r\n		this.scribe.printTrailingComment();\r\n	}	\r\n\r\n	public void formatMessageSend(\r\n		MessageSend messageSend,\r\n		BlockScope scope,\r\n		Alignment messageAlignment) {\r\n\r\n		if (messageAlignment != null) {\r\n			this.scribe.alignFragment(messageAlignment, 0);\r\n			this.scribe.printNextToken(ITerminalSymbols.TokenNameDOT);\r\n		}\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameIdentifier); // selector\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameLPAREN, this.preferences.insert_space_before_message_send);\r\n\r\n		final Expression[] arguments = messageSend.arguments;\r\n		if (arguments != null) {\r\n			int argumentLength = arguments.length;\r\n			Alignment argumentsAlignment = this.scribe.createAlignment(\r\n					\"messageArguments\", //$NON-NLS-1$\r\n					this.preferences.message_send_arguments_alignment,\r\n					argumentLength,\r\n					this.scribe.scanner.currentPosition);\r\n			this.scribe.enterAlignment(argumentsAlignment);\r\n			boolean ok = false;\r\n			do {\r\n				try {\r\n					if (this.preferences.insert_space_within_message_send) {\r\n						this.scribe.space();\r\n					}\r\n					for (int i = 0; i < argumentLength; i++) {\r\n						if (i > 0) {\r\n							this.scribe.printNextToken(ITerminalSymbols.TokenNameCOMMA, this.preferences.insert_space_before_comma_in_messagesend_arguments);\r\n						}\r\n						this.scribe.alignFragment(argumentsAlignment, i);\r\n						if (i > 0 && this.preferences.insert_space_after_comma_in_messagesend_arguments) {\r\n							this.scribe.space();\r\n						}\r\n						arguments[i].traverse(this, scope);\r\n					}\r\n					this.scribe.printNextToken(ITerminalSymbols.TokenNameRPAREN, this.preferences.insert_space_within_message_send);\r\n					ok = true;\r\n				} catch (AlignmentException e) {\r\n					this.scribe.redoAlignment(e);\r\n				}\r\n			} while (!ok);\r\n			this.scribe.exitAlignment(argumentsAlignment, true);\r\n		} else {\r\n			this.scribe.printNextToken(ITerminalSymbols.TokenNameRPAREN, this.preferences.insert_space_between_empty_arguments);\r\n		}\r\n	}\r\n\r\n	public void formatMethodArguments(\r\n			AbstractMethodDeclaration methodDeclaration, \r\n			boolean spaceBeforeOpenParen, \r\n			boolean spaceBetweenEmptyArgument,\r\n			boolean spaceBeforeClosingParen, \r\n			boolean spaceBeforeFirstArgument, \r\n			boolean spaceBeforeComma, \r\n			boolean spaceAfterComma) {\r\n				\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameLPAREN, spaceBeforeOpenParen); \r\n		\r\n		final Argument[] arguments = methodDeclaration.arguments;\r\n		if (arguments != null) {\r\n			int argumentLength = arguments.length;\r\n			Alignment argumentsAlignment = this.scribe.createAlignment(\r\n					\"methodArguments\",//$NON-NLS-1$\r\n					this.preferences.method_declaration_arguments_alignment,\r\n					argumentLength,\r\n					this.scribe.scanner.currentPosition);\r\n			this.scribe.enterAlignment(argumentsAlignment);\r\n			boolean ok = false;\r\n			do {\r\n				try {\r\n					if (spaceBeforeFirstArgument) {\r\n						this.scribe.space();\r\n					}\r\n					for (int i = 0; i < argumentLength; i++) {\r\n						if (i > 0) {\r\n							this.scribe.printNextToken(ITerminalSymbols.TokenNameCOMMA, spaceBeforeComma);\r\n						}\r\n						this.scribe.alignFragment(argumentsAlignment, i);\r\n						if (i > 0 && spaceAfterComma) {\r\n							this.scribe.space();\r\n						}\r\n						arguments[i].traverse(this, methodDeclaration.scope);\r\n					}\r\n					ok = true;\r\n				} catch (AlignmentException e) {\r\n					this.scribe.redoAlignment(e);\r\n				}\r\n			} while (!ok);\r\n			this.scribe.exitAlignment(argumentsAlignment, true);\r\n		\r\n			this.scribe.printNextToken(ITerminalSymbols.TokenNameRPAREN, spaceBeforeClosingParen); \r\n		} else {\r\n			this.scribe.printNextToken(ITerminalSymbols.TokenNameRPAREN, spaceBetweenEmptyArgument); \r\n		}\r\n	}\r\n\r\n	private void formatOpeningBrace(String bracePosition, boolean insertSpaceBeforeBrace) {\r\n	\r\n		if (bracePosition.equals(FormattingPreferences.NEXT_LINE)) {\r\n			this.scribe.printNewLine();\r\n		} else if (bracePosition.equals(FormattingPreferences.NEXT_LINE_SHIFTED)) {\r\n			this.scribe.printNewLine();\r\n			this.scribe.indent();\r\n		}\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameLBRACE, insertSpaceBeforeBrace);\r\n\r\n		this.scribe.printTrailingComment();\r\n		this.scribe.printNewLine();\r\n	}\r\n\r\n	public void formatStatements(BlockScope scope, final Statement[] statements) {\r\n		int statementsLength = statements.length;\r\n		for (int i = 0; i < statementsLength; i++) {\r\n			final Statement statement = statements[i];\r\n			statement.traverse(this, scope);\r\n			if (statement instanceof Expression) {\r\n				this.scribe.printNextToken(ITerminalSymbols.TokenNameSEMICOLON, this.preferences.insert_space_before_semicolon);\r\n				this.scribe.printTrailingComment();\r\n			} else if (statement instanceof LocalDeclaration) {\r\n				LocalDeclaration currentLocal = (LocalDeclaration) statement;\r\n				if (i < (statementsLength - 1)) {\r\n					/* \r\n					 * We need to check that the next statement is a local declaration\r\n					 */\r\n					if (statements[i + 1] instanceof LocalDeclaration) {\r\n						LocalDeclaration nextLocal = (LocalDeclaration) statements[i + 1];\r\n						if (currentLocal.declarationSourceStart != nextLocal.declarationSourceStart) {\r\n							this.scribe.printNextToken(ITerminalSymbols.TokenNameSEMICOLON, this.preferences.insert_space_before_semicolon);\r\n							this.scribe.printTrailingComment();\r\n						}\r\n					} else {\r\n						this.scribe.printNextToken(ITerminalSymbols.TokenNameSEMICOLON, this.preferences.insert_space_before_semicolon);\r\n						this.scribe.printTrailingComment();\r\n					}\r\n				} else {\r\n					this.scribe.printNextToken(ITerminalSymbols.TokenNameSEMICOLON, this.preferences.insert_space_before_semicolon);\r\n					this.scribe.printTrailingComment();\r\n				}\r\n			} else {\r\n				this.scribe.printTrailingComment();\r\n			}\r\n			this.scribe.printNewLine();\r\n		}\r\n	}\r\n	\r\n	private void formatThrowsClause(\r\n		AbstractMethodDeclaration methodDeclaration,\r\n		boolean spaceBeforeComma,\r\n		boolean spaceAfterComma) {\r\n			\r\n		final TypeReference[] thrownExceptions = methodDeclaration.thrownExceptions;\r\n		if (thrownExceptions != null) {\r\n			int thrownExceptionsLength = thrownExceptions.length;\r\n			Alignment throwsAlignment = this.scribe.createAlignment(\r\n					\"throws\",//$NON-NLS-1$\r\n					this.preferences.method_throws_clause_alignment,\r\n					thrownExceptionsLength + 1, // throws is the first token\r\n					this.scribe.scanner.currentPosition);\r\n		\r\n			this.scribe.enterAlignment(throwsAlignment);\r\n			boolean ok = false;\r\n			do {\r\n				try {\r\n					this.scribe.alignFragment(throwsAlignment, 0);\r\n					this.scribe.printNextToken(ITerminalSymbols.TokenNamethrows, true); \r\n					this.scribe.space();\r\n		\r\n					for (int i = 0; i < thrownExceptionsLength; i++) {\r\n						if (i > 0) {\r\n							this.scribe.printNextToken(ITerminalSymbols.TokenNameCOMMA, spaceBeforeComma);\r\n							if (spaceAfterComma) {\r\n								this.scribe.space();\r\n							}\r\n						}\r\n						this.scribe.alignFragment(throwsAlignment, i + 1);\r\n						thrownExceptions[i].traverse(this, methodDeclaration.scope);\r\n					}\r\n					ok = true;\r\n				} catch (AlignmentException e) {\r\n					this.scribe.redoAlignment(e);\r\n				}\r\n			} while (!ok);\r\n			this.scribe.exitAlignment(throwsAlignment, true);\r\n		}\r\n	}\r\n\r\n	/*\r\n	 * Merged traversal of member (types, fields, methods)\r\n	 */\r\n	private void formatTypeMembers(TypeDeclaration typeDeclaration) {\r\n		final int FIELD = 1, METHOD = 2, TYPE = 3;\r\n		\r\n		Alignment memberAlignment = this.scribe.createAlignment(\"typeMembers\", this.preferences.type_member_alignment, 4, this.scribe.scanner.currentPosition); //$NON-NLS-1$\r\n		this.scribe.enterAlignment(memberAlignment);\r\n		AstNode[] members = computeMergedMemberDeclarations(typeDeclaration);\r\n		boolean isChunkStart = false;\r\n		boolean ok = false;\r\n		int startIndex = 0;\r\n		do {\r\n			try {\r\n				for (int i = startIndex, max = members.length; i < max; i++) {\r\n					AstNode member = members[i];\r\n					if (member instanceof FieldDeclaration) {\r\n						isChunkStart = memberAlignment.checkChunkStart(FIELD, i, this.scribe.scanner.currentPosition);\r\n						if (member instanceof MultiFieldDeclaration){\r\n							MultiFieldDeclaration multiField = (MultiFieldDeclaration) member;\r\n							\r\n							if (multiField.isStatic()) {\r\n								format(multiField, this, typeDeclaration.staticInitializerScope, isChunkStart);\r\n							} else {\r\n								format(multiField, this, typeDeclaration.initializerScope, isChunkStart);\r\n							}					\r\n						} else if (member instanceof Initializer) {\r\n							int newLineBeforeChunk = isChunkStart ? this.preferences.blank_lines_before_new_chunk : 0;\r\n							if (newLineBeforeChunk > 0) {\r\n								this.scribe.printNewLines(newLineBeforeChunk);\r\n							}\r\n							Initializer initializer = (Initializer) member;\r\n							if (initializer.isStatic()) {\r\n								initializer.traverse(this, typeDeclaration.staticInitializerScope);\r\n							} else {\r\n								initializer.traverse(this, typeDeclaration.initializerScope);\r\n							}					\r\n						} else {\r\n							FieldDeclaration field = (FieldDeclaration) member;\r\n							if (field.isStatic()) {\r\n								format(field, this, typeDeclaration.staticInitializerScope, isChunkStart);\r\n							} else {\r\n								format(field, this, typeDeclaration.initializerScope, isChunkStart);\r\n							}					\r\n						}\r\n					} else if (member instanceof AbstractMethodDeclaration) {\r\n						isChunkStart = memberAlignment.checkChunkStart(METHOD, i, this.scribe.scanner.currentPosition);\r\n						format((AbstractMethodDeclaration) member, typeDeclaration.scope, isChunkStart);\r\n					} else {\r\n						isChunkStart = memberAlignment.checkChunkStart(TYPE, i, this.scribe.scanner.currentPosition);\r\n						format((MemberTypeDeclaration)member, typeDeclaration.scope, isChunkStart);\r\n					}\r\n					if (isSemiColon()) {\r\n						this.scribe.printNextToken(ITerminalSymbols.TokenNameSEMICOLON, this.preferences.insert_space_before_semicolon);\r\n						this.scribe.printTrailingComment();\r\n						this.scribe.printNewLine();\r\n					}\r\n				}\r\n				ok = true;\r\n			} catch(AlignmentException e){\r\n				startIndex = memberAlignment.chunkStartIndex;\r\n				this.scribe.redoAlignment(e);\r\n			}\r\n		} while (!ok);		\r\n		this.scribe.exitAlignment(memberAlignment, true);\r\n	}\r\n\r\n	private void formatTypeOpeningBrace(String bracePosition, boolean insertSpaceBeforeBrace, TypeDeclaration typeDeclaration) {\r\n		int fieldCount = (typeDeclaration.fields == null) ? 0 : typeDeclaration.fields.length;\r\n		int methodCount = (typeDeclaration.methods == null) ? 0 : typeDeclaration.methods.length;\r\n		int typeCount = (typeDeclaration.memberTypes == null) ? 0 : typeDeclaration.memberTypes.length;\r\n	\r\n		if (methodCount == 1 && typeDeclaration.methods[0].isDefaultConstructor()) {\r\n			methodCount = 0;\r\n		}\r\n		final int memberLength = fieldCount+methodCount+typeCount;\r\n\r\n		boolean insertNewLine = memberLength > 0;\r\n		\r\n		if (!insertNewLine) {\r\n			if (typeDeclaration instanceof AnonymousLocalTypeDeclaration) {\r\n				insertNewLine = this.preferences.insert_new_line_in_empty_anonymous_type_declaration;\r\n			} else {\r\n				insertNewLine = this.preferences.insert_new_line_in_empty_type_declaration;\r\n			}\r\n		}\r\n	\r\n		formatOpeningBrace(bracePosition, insertSpaceBeforeBrace);\r\n		\r\n		if (insertNewLine) {\r\n			this.scribe.printNewLine();\r\n		}\r\n	}\r\n\r\n	private int getExtraDimension() {\r\n\r\n		this.localScanner.resetTo(this.scribe.scanner.currentPosition, this.scribe.scannerEndPosition - 1);\r\n		int dimensions = 0;\r\n		try {\r\n			int token;\r\n			while ((token = this.localScanner.getNextToken()) != ITerminalSymbols.TokenNameEOF) {\r\n				switch(token) {\r\n					case ITerminalSymbols.TokenNameRBRACKET://166 \r\n						dimensions++;\r\n						break;\r\n					case ITerminalSymbols.TokenNameIdentifier ://90						\r\n					case ITerminalSymbols.TokenNameLBRACE ://90						\r\n					case ITerminalSymbols.TokenNameLPAREN :\r\n					case ITerminalSymbols.TokenNameCOMMA ://90\r\n					case ITerminalSymbols.TokenNameEQUAL ://167\r\n					case ITerminalSymbols.TokenNameSEMICOLON ://64\r\n					case ITerminalSymbols.TokenNameRPAREN : //86\r\n						return dimensions;\r\n				}\r\n			}\r\n		} catch(InvalidInputException e) {\r\n		}\r\n		return dimensions;\r\n	}\r\n\r\n	private boolean isComma() {\r\n\r\n		this.localScanner.resetTo(this.scribe.scanner.currentPosition, this.scribe.scannerEndPosition - 1);\r\n		try {\r\n			return this.localScanner.getNextToken() == ITerminalSymbols.TokenNameCOMMA;\r\n		} catch(InvalidInputException e) {\r\n		}\r\n		return false;\r\n	}\r\n\r\n	private boolean isGuardClause(Block block) {\r\n		return block.statements != null \r\n				&& block.statements.length == 1\r\n				&& (block.statements[0] instanceof ReturnStatement\r\n					|| block.statements[0] instanceof ThrowStatement);\r\n	}	\r\n\r\n	private boolean isMultipleLocalDeclaration(LocalDeclaration localDeclaration) {\r\n\r\n		if (localDeclaration.declarationSourceStart == this.lastLocalDeclarationSourceStart) return true;\r\n		this.lastLocalDeclarationSourceStart = localDeclaration.declarationSourceStart;\r\n		return false;\r\n	}\r\n\r\n	private boolean isPartOfMultipleLocalDeclaration() {\r\n		this.localScanner.resetTo(this.scribe.scanner.currentPosition, this.scribe.scannerEndPosition - 1);\r\n		try {\r\n			int token;\r\n			while ((token = this.localScanner.getNextToken()) != ITerminalSymbols.TokenNameEOF) {\r\n				switch(token) {\r\n					case ITerminalSymbols.TokenNameCOMMA ://90\r\n						return true;\r\n					default:\r\n						return false;\r\n				}\r\n			}\r\n		} catch(InvalidInputException e) {\r\n		}\r\n		return false;\r\n	}\r\n\r\n	private boolean isSemiColon() {\r\n\r\n		this.localScanner.resetTo(this.scribe.scanner.currentPosition, this.scribe.scannerEndPosition - 1);\r\n		try {\r\n			return this.localScanner.getNextToken() == ITerminalSymbols.TokenNameSEMICOLON;\r\n		} catch(InvalidInputException e) {\r\n		}\r\n		return false;\r\n	}\r\n	\r\n	private void manageClosingParenthesizedExpression(Expression expression, int numberOfParens) {\r\n		for (int i = 0; i < numberOfParens; i++) {\r\n			this.scribe.printNextToken(ITerminalSymbols.TokenNameRPAREN, this.preferences.insert_space_before_closing_paren_in_parenthesized_expression);\r\n		}\r\n	}\r\n\r\n	private void manageOpeningParenthesizedExpression(Expression expression, int numberOfParens) {\r\n		for (int i = 0; i < numberOfParens; i++) {\r\n			this.scribe.printNextToken(ITerminalSymbols.TokenNameLPAREN, this.preferences.insert_space_before_open_paren_in_parenthesized_expression);\r\n			if (this.preferences.insert_space_after_open_paren_in_parenthesized_expression) {\r\n				this.scribe.space();\r\n			}\r\n		}\r\n	}\r\n			\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.AllocationExpression, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(\r\n		AllocationExpression allocationExpression,\r\n		BlockScope scope) {\r\n		// \'new\' ClassType \'(\' ArgumentListopt \')\' ClassBodyopt\r\n\r\n		final int numberOfParens = (allocationExpression.bits & AstNode.ParenthesizedMASK) >> AstNode.ParenthesizedSHIFT;\r\n		if (numberOfParens > 0) {\r\n			manageOpeningParenthesizedExpression(allocationExpression, numberOfParens);\r\n		}\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNamenew);\r\n		this.scribe.space();\r\n		allocationExpression.type.traverse(this, scope);\r\n		\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameLPAREN, this.preferences.insert_space_before_message_send);\r\n\r\n		final Expression[] arguments = allocationExpression.arguments;\r\n		if (arguments != null) {\r\n			int argumentLength = arguments.length;\r\n			Alignment argumentsAlignment =this.scribe.createAlignment(\r\n					\"allocation\",//$NON-NLS-1$\r\n					this.preferences.allocation_expression_arguments_alignment,\r\n					argumentLength,\r\n					this.scribe.scanner.currentPosition);\r\n			this.scribe.enterAlignment(argumentsAlignment);\r\n			boolean ok = false;\r\n			do {\r\n				try {\r\n					if (this.preferences.insert_space_within_message_send) {\r\n						this.scribe.space();\r\n					}\r\n					for (int i = 0; i < argumentLength; i++) {\r\n						if (i > 0) {\r\n							this.scribe.printNextToken(ITerminalSymbols.TokenNameCOMMA, this.preferences.insert_space_before_comma_in_allocation_expression);\r\n						}\r\n						this.scribe.alignFragment(argumentsAlignment, i);\r\n						if (i > 0 && this.preferences.insert_space_after_comma_in_allocation_expression) {\r\n							this.scribe.space();\r\n						}\r\n						arguments[i].traverse(this, scope);\r\n					}\r\n					ok = true;\r\n				} catch (AlignmentException e) {\r\n					this.scribe.redoAlignment(e);\r\n				}\r\n			} while (!ok);\r\n			this.scribe.exitAlignment(argumentsAlignment, true);\r\n			this.scribe.printNextToken(ITerminalSymbols.TokenNameRPAREN, this.preferences.insert_space_within_message_send); \r\n		} else {\r\n			this.scribe.printNextToken(ITerminalSymbols.TokenNameRPAREN, this.preferences.insert_space_between_empty_arguments); \r\n		}\r\n		\r\n		if (numberOfParens > 0) {\r\n			manageClosingParenthesizedExpression(allocationExpression, numberOfParens);\r\n		}\r\n		return false;\r\n	}\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.AND_AND_Expression, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(\r\n		AND_AND_Expression and_and_Expression,\r\n		BlockScope scope) {\r\n			\r\n		return dumpBinaryExpression(and_and_Expression, ITerminalSymbols.TokenNameAND_AND, scope);\r\n	}\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.AnonymousLocalTypeDeclaration, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(\r\n		AnonymousLocalTypeDeclaration anonymousTypeDeclaration,\r\n		BlockScope scope) {\r\n			\r\n		/*\r\n		 * Type body\r\n		 */\r\n		String anonymous_type_declaration_brace_position = this.preferences.anonymous_type_declaration_brace_position;\r\n		formatTypeOpeningBrace(anonymous_type_declaration_brace_position, this.preferences.insert_space_before_anonymous_type_open_brace, anonymousTypeDeclaration);\r\n		\r\n		this.scribe.indent();\r\n\r\n		formatTypeMembers(anonymousTypeDeclaration);\r\n		\r\n		this.scribe.printComment();\r\n		this.scribe.unIndent();\r\n		if (this.preferences.insert_new_line_in_empty_anonymous_type_declaration) {\r\n			this.scribe.printNewLine();\r\n		}\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameRBRACE);\r\n		if (anonymous_type_declaration_brace_position.equals(FormattingPreferences.NEXT_LINE_SHIFTED)) {\r\n			this.scribe.unIndent();\r\n		}\r\n		return false;\r\n	}\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.Argument, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(Argument argument, BlockScope scope) {\r\n\r\n		if (argument.modifiers != NO_MODIFIERS) {\r\n			this.scribe.printModifiers();\r\n			this.scribe.space();\r\n		}\r\n\r\n		/*\r\n		 * Argument type \r\n		 */		\r\n		if (argument.type != null) {\r\n			argument.type.traverse(this, scope);\r\n		}\r\n		\r\n		/*\r\n		 * Print the argument name\r\n		 */	\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameIdentifier, true);\r\n\r\n\r\n		/*\r\n		 * Check for extra dimensions\r\n		 */\r\n		int extraDimensions = getExtraDimension();\r\n		if (extraDimensions != 0) {\r\n			 for (int i = 0; i < extraDimensions; i++) {\r\n			 	this.scribe.printNextToken(ITerminalSymbols.TokenNameLBRACKET);\r\n			 	this.scribe.printNextToken(ITerminalSymbols.TokenNameRBRACKET);\r\n			 }\r\n		}\r\n		\r\n		return false;\r\n	}\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.ArrayAllocationExpression, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(\r\n		ArrayAllocationExpression arrayAllocationExpression,\r\n		BlockScope scope) {\r\n\r\n			final int numberOfParens = (arrayAllocationExpression.bits & AstNode.ParenthesizedMASK) >> AstNode.ParenthesizedSHIFT;\r\n			if (numberOfParens > 0) {\r\n				manageOpeningParenthesizedExpression(arrayAllocationExpression, numberOfParens);\r\n			}\r\n			this.scribe.printNextToken(ITerminalSymbols.TokenNamenew);\r\n			this.scribe.space();\r\n			arrayAllocationExpression.type.traverse(this, scope);\r\n			\r\n			final Expression[] dimensions = arrayAllocationExpression.dimensions;\r\n			int dimensionsLength = dimensions.length;\r\n			for (int i = 0; i < dimensionsLength; i++) {\r\n				this.scribe.printNextToken(ITerminalSymbols.TokenNameLBRACKET);\r\n				if (dimensions[i] != null) {\r\n					dimensions[i].traverse(this, scope);\r\n				}\r\n				this.scribe.printNextToken(ITerminalSymbols.TokenNameRBRACKET);\r\n			}\r\n			final ArrayInitializer initializer = arrayAllocationExpression.initializer;\r\n			if (initializer != null) {\r\n				initializer.traverse(this, scope);\r\n			}\r\n\r\n			if (numberOfParens > 0) {\r\n				manageClosingParenthesizedExpression(arrayAllocationExpression, numberOfParens);\r\n			}\r\n			return false;\r\n	}\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.ArrayInitializer, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(ArrayInitializer arrayInitializer, BlockScope scope) {\r\n\r\n		final int numberOfParens = (arrayInitializer.bits & AstNode.ParenthesizedMASK) >> AstNode.ParenthesizedSHIFT;\r\n		if (numberOfParens > 0) {\r\n			manageOpeningParenthesizedExpression(arrayInitializer, numberOfParens);\r\n		}\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameLBRACE);\r\n		\r\n		final Expression[] expressions = arrayInitializer.expressions;\r\n		if (expressions != null) {\r\n			int expressionsLength = expressions.length;\r\n			if (expressionsLength > 1) {\r\n				Alignment expressionsAlignment =this.scribe.createAlignment(\r\n						\"expressions\",//$NON-NLS-1$\r\n						this.preferences.array_initializer_expressions_alignment,\r\n						expressionsLength - 1,\r\n						this.scribe.scanner.currentPosition);\r\n				this.scribe.enterAlignment(expressionsAlignment);\r\n				boolean ok = false;\r\n				do {\r\n					try {\r\n						if (this.preferences.insert_space_before_first_initializer) {\r\n							this.scribe.space();\r\n						}\r\n						expressions[0].traverse(this, scope);\r\n						for (int i = 1; i < expressionsLength; i++) {\r\n							this.scribe.printNextToken(ITerminalSymbols.TokenNameCOMMA, this.preferences.insert_space_before_comma_in_array_initializer);\r\n							if (this.preferences.insert_space_after_comma_in_array_initializer) {\r\n								this.scribe.space();\r\n							}\r\n							this.scribe.alignFragment(expressionsAlignment, i - 1);\r\n							expressions[i].traverse(this, scope);\r\n						}\r\n						ok = true;\r\n					} catch (AlignmentException e) {\r\n						this.scribe.redoAlignment(e);\r\n					}\r\n				} while (!ok);\r\n				this.scribe.exitAlignment(expressionsAlignment, true);\r\n			} else {\r\n				// we don\'t need to use an alignment\r\n				if (this.preferences.insert_space_before_first_initializer) {\r\n					this.scribe.space();\r\n				}\r\n				expressions[0].traverse(this, scope);\r\n				for (int i = 1; i < expressionsLength; i++) {\r\n					this.scribe.printNextToken(ITerminalSymbols.TokenNameCOMMA, this.preferences.insert_space_before_comma_in_array_initializer);\r\n					if (this.preferences.insert_space_after_comma_in_array_initializer) {\r\n						this.scribe.space();\r\n					}\r\n					expressions[i].traverse(this, scope);\r\n				}\r\n			}\r\n			if (isComma()) {\r\n				this.scribe.printNextToken(ITerminalSymbols.TokenNameCOMMA, this.preferences.insert_space_before_comma_in_array_initializer);\r\n			}\r\n			this.scribe.printNextToken(ITerminalSymbols.TokenNameRBRACE, this.preferences.insert_space_before_closing_brace_in_array_initializer, true); \r\n		} else {\r\n			this.scribe.printNextToken(ITerminalSymbols.TokenNameRBRACE, this.preferences.insert_space_between_empty_array_initializer, true);\r\n		}\r\n\r\n		if (numberOfParens > 0) {\r\n			manageClosingParenthesizedExpression(arrayInitializer, numberOfParens);\r\n		}\r\n		return false;\r\n	}\r\n	\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.ArrayQualifiedTypeReference, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(\r\n		ArrayQualifiedTypeReference arrayQualifiedTypeReference,\r\n		BlockScope scope) {\r\n\r\n			final int numberOfParens = (arrayQualifiedTypeReference.bits & AstNode.ParenthesizedMASK) >> AstNode.ParenthesizedSHIFT;\r\n			if (numberOfParens > 0) {\r\n				manageOpeningParenthesizedExpression(arrayQualifiedTypeReference, numberOfParens);\r\n			}\r\n			this.scribe.printQualifiedReference(arrayQualifiedTypeReference.sourceEnd - 1);\r\n			int dimensions = getExtraDimension();\r\n			if (dimensions != 0) {\r\n				for (int i = 0; i < dimensions; i++) {\r\n					this.scribe.printNextToken(ITerminalSymbols.TokenNameLBRACKET);\r\n					this.scribe.printNextToken(ITerminalSymbols.TokenNameRBRACKET);\r\n				}\r\n			}\r\n			if (numberOfParens > 0) {\r\n				manageClosingParenthesizedExpression(arrayQualifiedTypeReference, numberOfParens);\r\n			}\r\n			return false;\r\n	}\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.ArrayQualifiedTypeReference, org.eclipse.jdt.internal.compiler.lookup.ClassScope)\r\n	 */\r\n	public boolean visit(\r\n		ArrayQualifiedTypeReference arrayQualifiedTypeReference,\r\n		ClassScope scope) {\r\n\r\n			final int numberOfParens = (arrayQualifiedTypeReference.bits & AstNode.ParenthesizedMASK) >> AstNode.ParenthesizedSHIFT;\r\n			if (numberOfParens > 0) {\r\n				manageOpeningParenthesizedExpression(arrayQualifiedTypeReference, numberOfParens);\r\n			}\r\n			this.scribe.printQualifiedReference(arrayQualifiedTypeReference.sourceEnd - 1);\r\n			int dimensions = getExtraDimension();\r\n			if (dimensions != 0) {\r\n				for (int i = 0; i < dimensions; i++) {\r\n					this.scribe.printNextToken(ITerminalSymbols.TokenNameLBRACKET);\r\n					this.scribe.printNextToken(ITerminalSymbols.TokenNameRBRACKET);\r\n				}\r\n			}\r\n			if (numberOfParens > 0) {\r\n				manageClosingParenthesizedExpression(arrayQualifiedTypeReference, numberOfParens);\r\n			}\r\n			return false;\r\n	}\r\n\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.ArrayReference, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(ArrayReference arrayReference, BlockScope scope) {\r\n\r\n		final int numberOfParens = (arrayReference.bits & AstNode.ParenthesizedMASK) >> AstNode.ParenthesizedSHIFT;\r\n		if (numberOfParens > 0) {\r\n			manageOpeningParenthesizedExpression(arrayReference, numberOfParens);\r\n		}\r\n		arrayReference.receiver.traverse(this, scope);\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameLBRACKET);\r\n		arrayReference.position.traverse(this, scope);\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameRBRACKET);\r\n		\r\n		if (numberOfParens > 0) {\r\n			manageClosingParenthesizedExpression(arrayReference, numberOfParens);\r\n		}\r\n		return false;\r\n	}\r\n	\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.ArrayTypeReference, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(\r\n		ArrayTypeReference arrayTypeReference,\r\n		BlockScope scope) {\r\n\r\n		final int numberOfParens = (arrayTypeReference.bits & AstNode.ParenthesizedMASK) >> AstNode.ParenthesizedSHIFT;\r\n		if (numberOfParens > 0) {\r\n			manageOpeningParenthesizedExpression(arrayTypeReference, numberOfParens);\r\n		}\r\n		this.scribe.printNextToken(SINGLETYPEREFERENCE_EXPECTEDTOKENS, false, true);\r\n		\r\n		int dimensions = getExtraDimension();\r\n		if (dimensions != 0) {\r\n			if (this.preferences.insert_space_before_bracket_in_array_type_reference) {\r\n				this.scribe.space();\r\n			}\r\n			for (int i = 0; i < dimensions; i++) {\r\n				this.scribe.printNextToken(ITerminalSymbols.TokenNameLBRACKET);\r\n				if (this.preferences.insert_space_between_brackets_in_array_type_reference) {\r\n					this.scribe.space();\r\n				}\r\n				this.scribe.printNextToken(ITerminalSymbols.TokenNameRBRACKET);\r\n			}\r\n		}\r\n		if (numberOfParens > 0) {\r\n			manageClosingParenthesizedExpression(arrayTypeReference, numberOfParens);\r\n		}\r\n		return false;\r\n	}\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.ArrayTypeReference, org.eclipse.jdt.internal.compiler.lookup.ClassScope)\r\n	 */\r\n	public boolean visit(\r\n		ArrayTypeReference arrayTypeReference,\r\n		ClassScope scope) {\r\n\r\n		final int numberOfParens = (arrayTypeReference.bits & AstNode.ParenthesizedMASK) >> AstNode.ParenthesizedSHIFT;\r\n		if (numberOfParens > 0) { \r\n			manageOpeningParenthesizedExpression(arrayTypeReference, numberOfParens);\r\n		}\r\n		this.scribe.printNextToken(SINGLETYPEREFERENCE_EXPECTEDTOKENS, false, true);\r\n		int dimensions = getExtraDimension();\r\n		if (dimensions != 0) {\r\n			if (this.preferences.insert_space_before_bracket_in_array_type_reference) {\r\n				this.scribe.space();\r\n			}\r\n			for (int i = 0; i < dimensions; i++) {\r\n				this.scribe.printNextToken(ITerminalSymbols.TokenNameLBRACKET);\r\n				if (this.preferences.insert_space_between_brackets_in_array_type_reference) {\r\n					this.scribe.space();\r\n				}\r\n				this.scribe.printNextToken(ITerminalSymbols.TokenNameRBRACKET);\r\n			}\r\n		}\r\n		if (numberOfParens > 0) {\r\n			manageClosingParenthesizedExpression(arrayTypeReference, numberOfParens);\r\n		}\r\n		return false;\r\n	}\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.AssertStatement, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(AssertStatement assertStatement, BlockScope scope) {\r\n		\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameassert);\r\n		this.scribe.space();\r\n		assertStatement.assertExpression.traverse(this, scope);\r\n		\r\n		if (assertStatement.exceptionArgument != null) {\r\n			this.scribe.printNextToken(ITerminalSymbols.TokenNameCOLON, this.preferences.insert_space_before_colon_in_assert);\r\n			if (this.preferences.insert_space_after_colon_in_assert) {\r\n				this.scribe.space();\r\n			}\r\n			assertStatement.exceptionArgument.traverse(this, scope);\r\n		}\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameSEMICOLON, this.preferences.insert_space_before_semicolon);		\r\n		return false;\r\n	}\r\n	\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.Assignment, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(Assignment assignment, BlockScope scope) {\r\n\r\n		final int numberOfParens = (assignment.bits & AstNode.ParenthesizedMASK) >> AstNode.ParenthesizedSHIFT;\r\n		if (numberOfParens > 0) {\r\n			manageOpeningParenthesizedExpression(assignment, numberOfParens);\r\n		}\r\n		assignment.lhs.traverse(this, scope);\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameEQUAL, this.preferences.insert_space_before_assignment_operators);\r\n		if (this.preferences.insert_space_after_assignment_operators) {\r\n			this.scribe.space();\r\n		}\r\n		assignment.expression.traverse(this, scope);\r\n		\r\n		if (numberOfParens > 0) {\r\n			manageClosingParenthesizedExpression(assignment, numberOfParens);\r\n		}\r\n		return false;\r\n	}\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.BinaryExpression, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(BinaryExpression binaryExpression, BlockScope scope) {\r\n\r\n		switch((binaryExpression.bits & AstNode.OperatorMASK) >> AstNode.OperatorSHIFT) {\r\n			case OperatorIds.AND :\r\n				return dumpBinaryExpression(binaryExpression, ITerminalSymbols.TokenNameAND, scope);\r\n			case OperatorIds.DIVIDE :\r\n				return dumpBinaryExpression(binaryExpression, ITerminalSymbols.TokenNameDIVIDE, scope);\r\n			case OperatorIds.GREATER :\r\n				return dumpBinaryExpression(binaryExpression, ITerminalSymbols.TokenNameGREATER, scope);\r\n			case OperatorIds.GREATER_EQUAL :\r\n				return dumpBinaryExpression(binaryExpression, ITerminalSymbols.TokenNameGREATER_EQUAL, scope);\r\n			case OperatorIds.LEFT_SHIFT :\r\n				return dumpBinaryExpression(binaryExpression, ITerminalSymbols.TokenNameLEFT_SHIFT, scope);\r\n			case OperatorIds.LESS :\r\n				return dumpBinaryExpression(binaryExpression, ITerminalSymbols.TokenNameLESS, scope);\r\n			case OperatorIds.LESS_EQUAL :\r\n				return dumpBinaryExpression(binaryExpression, ITerminalSymbols.TokenNameLESS_EQUAL, scope);\r\n			case OperatorIds.MINUS :\r\n				return dumpBinaryExpression(binaryExpression, ITerminalSymbols.TokenNameMINUS, scope);\r\n			case OperatorIds.MULTIPLY :\r\n				return dumpBinaryExpression(binaryExpression, ITerminalSymbols.TokenNameMULTIPLY, scope);\r\n			case OperatorIds.OR :\r\n				return dumpBinaryExpression(binaryExpression, ITerminalSymbols.TokenNameOR, scope);\r\n			case OperatorIds.PLUS :\r\n				return dumpBinaryExpression(binaryExpression, ITerminalSymbols.TokenNamePLUS, scope);\r\n			case OperatorIds.REMAINDER :\r\n				return dumpBinaryExpression(binaryExpression, ITerminalSymbols.TokenNameREMAINDER, scope);\r\n			case OperatorIds.RIGHT_SHIFT :\r\n				return dumpBinaryExpression(binaryExpression, ITerminalSymbols.TokenNameRIGHT_SHIFT, scope);\r\n			case OperatorIds.UNSIGNED_RIGHT_SHIFT :\r\n				return dumpBinaryExpression(binaryExpression, ITerminalSymbols.TokenNameUNSIGNED_RIGHT_SHIFT, scope);\r\n			case OperatorIds.XOR :\r\n				return dumpBinaryExpression(binaryExpression, ITerminalSymbols.TokenNameXOR, scope);\r\n			default:\r\n				throw new IllegalStateException();\r\n		}\r\n	}\r\n	\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.Block, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(Block block, BlockScope scope) {\r\n	\r\n		String block_brace_position = this.preferences.block_brace_position;\r\n		formatOpeningBrace(block_brace_position, this.preferences.insert_space_before_block_open_brace);\r\n		this.scribe.indent();\r\n	\r\n		final Statement[] statements = block.statements;\r\n		if (statements != null) {\r\n			this.scribe.printTrailingComment();\r\n			this.scribe.printNewLine();\r\n			formatStatements(scope, statements);\r\n		} else if (this.preferences.insert_new_line_in_empty_block) {\r\n			this.scribe.printNewLine();\r\n		}\r\n		this.scribe.printComment();\r\n\r\n		this.scribe.unIndent();\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameRBRACE);\r\n		this.scribe.printTrailingComment();\r\n		this.scribe.printNewLine();\r\n	\r\n		if (block_brace_position.equals(FormattingPreferences.NEXT_LINE_SHIFTED)) {\r\n			this.scribe.unIndent();\r\n		}		\r\n		return false;	\r\n	}\r\n\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.Break, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(BreakStatement breakStatement, BlockScope scope) {\r\n		\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNamebreak);\r\n		if (breakStatement.label != null) {\r\n			this.scribe.printNextToken(ITerminalSymbols.TokenNameIdentifier, true);\r\n		}\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameSEMICOLON, this.preferences.insert_space_before_semicolon);\r\n		return false;\r\n	}\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.Case, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(CaseStatement caseStatement, BlockScope scope) {		\r\n		if (caseStatement.constantExpression == null) {\r\n			this.scribe.printNextToken(ITerminalSymbols.TokenNamedefault);\r\n			this.scribe.printNextToken(ITerminalSymbols.TokenNameCOLON, this.preferences.insert_space_before_colon_in_default);\r\n		} else {\r\n			this.scribe.printNextToken(ITerminalSymbols.TokenNamecase);\r\n			this.scribe.space();\r\n			caseStatement.constantExpression.traverse(this, scope);\r\n			this.scribe.printNextToken(ITerminalSymbols.TokenNameCOLON, this.preferences.insert_space_before_colon_in_case);\r\n		}\r\n		return false;\r\n	}\r\n\r\n\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.CastExpression, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(CastExpression castExpression, BlockScope scope) {\r\n\r\n		final int numberOfParens = (castExpression.bits & AstNode.ParenthesizedMASK) >> AstNode.ParenthesizedSHIFT;\r\n		if (numberOfParens > 0) {\r\n			manageOpeningParenthesizedExpression(castExpression, numberOfParens);\r\n		}\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameLPAREN);\r\n		if (this.preferences.insert_space_after_opening_paren_in_cast) {\r\n			this.scribe.space();\r\n		}\r\n		castExpression.type.traverse(this, scope);\r\n\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameRPAREN, this.preferences.insert_space_before_closing_paren_in_cast);\r\n		if (this.preferences.insert_space_after_closing_paren_in_cast) {\r\n			this.scribe.space();\r\n		}\r\n		castExpression.expression.traverse(this, scope);\r\n		\r\n		if (numberOfParens > 0) {\r\n			manageClosingParenthesizedExpression(castExpression, numberOfParens);\r\n		}\r\n		return false;\r\n	}\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.CharLiteral, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(CharLiteral charLiteral, BlockScope scope) {\r\n\r\n		final int numberOfParens = (charLiteral.bits & AstNode.ParenthesizedMASK) >> AstNode.ParenthesizedSHIFT;\r\n		if (numberOfParens > 0) {\r\n			manageOpeningParenthesizedExpression(charLiteral, numberOfParens);\r\n		}\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameCharacterLiteral);\r\n\r\n		if (numberOfParens > 0) {\r\n			manageClosingParenthesizedExpression(charLiteral, numberOfParens);\r\n		}\r\n		return false;\r\n	}\r\n\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.ClassLiteralAccess, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(ClassLiteralAccess classLiteral, BlockScope scope) {\r\n\r\n		final int numberOfParens = (classLiteral.bits & AstNode.ParenthesizedMASK) >> AstNode.ParenthesizedSHIFT;\r\n		if (numberOfParens > 0) {\r\n			manageOpeningParenthesizedExpression(classLiteral, numberOfParens);\r\n		}\r\n		classLiteral.type.traverse(this, scope);\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameDOT);\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameclass);\r\n		\r\n		if (numberOfParens > 0) {\r\n			manageClosingParenthesizedExpression(classLiteral, numberOfParens);\r\n		}\r\n		return false;\r\n	}\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.Clinit, org.eclipse.jdt.internal.compiler.lookup.ClassScope)\r\n	 */\r\n	public boolean visit(Clinit clinit, ClassScope scope) {\r\n\r\n		return false;\r\n	}\r\n	\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration, org.eclipse.jdt.internal.compiler.lookup.CompilationUnitScope)\r\n	 */\r\n	public boolean visit(\r\n		CompilationUnitDeclaration compilationUnitDeclaration,\r\n		CompilationUnitScope scope) {\r\n		\r\n		/* \r\n		 * Package declaration\r\n		 */\r\n		if (compilationUnitDeclaration.currentPackage != null) {\r\n			// OPTION\r\n			// dump the package keyword\r\n			int blankLinesBeforePackage = this.preferences.blank_lines_before_package;\r\n			if (blankLinesBeforePackage > 0) {\r\n				this.scribe.printNewLines(blankLinesBeforePackage - 1);\r\n			}\r\n			this.scribe.printComment();\r\n			this.scribe.printNextToken(ITerminalSymbols.TokenNamepackage);\r\n			this.scribe.space();\r\n			this.scribe.printQualifiedReference(compilationUnitDeclaration.currentPackage.sourceEnd);\r\n			this.scribe.printNextToken(ITerminalSymbols.TokenNameSEMICOLON, this.preferences.insert_space_before_semicolon);\r\n			this.scribe.printTrailingComment();\r\n			int blankLinesAfterPackage = this.preferences.blank_lines_after_package;\r\n			if (blankLinesAfterPackage > 0) {\r\n				this.scribe.printNewLines(blankLinesAfterPackage);\r\n			}				\r\n		} else {\r\n			this.scribe.printComment();\r\n		}\r\n		\r\n		/*\r\n		 * Import statements\r\n		 */\r\n		final ImportReference[] imports = compilationUnitDeclaration.imports;\r\n		if (imports != null) {\r\n			int blankLinesBeforeImports = this.preferences.blank_lines_before_imports;\r\n			if (blankLinesBeforeImports > 0) {\r\n				this.scribe.printNewLines(blankLinesBeforeImports);\r\n			}\r\n			int importLength = imports.length;\r\n			for (int i = 0; i < importLength; i++) {\r\n				imports[i].traverse(this, scope);\r\n			}			\r\n			\r\n			int blankLinesAfterImports = this.preferences.blank_lines_after_imports;\r\n			if (blankLinesAfterImports > 0) {\r\n				this.scribe.printNewLines(blankLinesAfterImports);\r\n			}\r\n		}\r\n\r\n		/*\r\n		 * Type declarations\r\n		 */\r\n		final TypeDeclaration[] types = compilationUnitDeclaration.types;\r\n		if (types != null) {\r\n			int typesLength = types.length;\r\n			for (int i = 0; i < typesLength; i++) {\r\n				types[i].traverse(this, scope);\r\n			}\r\n		}\r\n		this.scribe.printComment();\r\n		return false;\r\n	}\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.CompoundAssignment, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(\r\n		CompoundAssignment compoundAssignment,\r\n		BlockScope scope) {\r\n			\r\n		final int numberOfParens = (compoundAssignment.bits & AstNode.ParenthesizedMASK) >> AstNode.ParenthesizedSHIFT;\r\n		if (numberOfParens > 0) {\r\n			manageOpeningParenthesizedExpression(compoundAssignment, numberOfParens);\r\n		}\r\n		compoundAssignment.lhs.traverse(this, scope);\r\n		\r\n		/*\r\n		 * Print the operator\r\n		 */\r\n		int operator;\r\n		switch(compoundAssignment.operator) {\r\n			case OperatorIds.PLUS :\r\n				operator = ITerminalSymbols.TokenNamePLUS_EQUAL;\r\n				break;\r\n			case OperatorIds.MINUS :\r\n				operator = ITerminalSymbols.TokenNameMINUS_EQUAL;\r\n				break;\r\n			case OperatorIds.MULTIPLY :\r\n				operator = ITerminalSymbols.TokenNameMULTIPLY_EQUAL;\r\n				break;\r\n			case OperatorIds.DIVIDE :\r\n				operator = ITerminalSymbols.TokenNameDIVIDE_EQUAL;\r\n				break;\r\n			case OperatorIds.AND :\r\n				operator = ITerminalSymbols.TokenNameAND_EQUAL;\r\n				break;\r\n			case OperatorIds.OR :\r\n				operator = ITerminalSymbols.TokenNameOR_EQUAL;\r\n				break;\r\n			case OperatorIds.XOR :\r\n				operator = ITerminalSymbols.TokenNameXOR_EQUAL;\r\n				break;\r\n			case OperatorIds.REMAINDER :\r\n				operator = ITerminalSymbols.TokenNameREMAINDER_EQUAL;\r\n				break;\r\n			case OperatorIds.LEFT_SHIFT :\r\n				operator = ITerminalSymbols.TokenNameLEFT_SHIFT_EQUAL;\r\n				break;\r\n			case OperatorIds.RIGHT_SHIFT :\r\n				operator = ITerminalSymbols.TokenNameRIGHT_SHIFT_EQUAL;\r\n				break;\r\n			default: // OperatorIds.UNSIGNED_RIGHT_SHIFT :\r\n				operator = ITerminalSymbols.TokenNameUNSIGNED_RIGHT_SHIFT_EQUAL;\r\n		}\r\n		\r\n		this.scribe.printNextToken(operator, this.preferences.insert_space_before_assignment_operators);\r\n		if (this.preferences.insert_space_after_assignment_operators) {\r\n			this.scribe.space();\r\n		}\r\n		compoundAssignment.expression.traverse(this, scope);\r\n		\r\n		if (numberOfParens > 0) {\r\n			manageClosingParenthesizedExpression(compoundAssignment, numberOfParens);\r\n		}\r\n		return false;\r\n	}\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.ConditionalExpression, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(\r\n		ConditionalExpression conditionalExpression,\r\n		BlockScope scope) {\r\n\r\n		final int numberOfParens = (conditionalExpression.bits & AstNode.ParenthesizedMASK) >> AstNode.ParenthesizedSHIFT;\r\n		if (numberOfParens > 0) {\r\n			manageOpeningParenthesizedExpression(conditionalExpression, numberOfParens);\r\n		}\r\n		conditionalExpression.condition.traverse(this, scope);\r\n\r\n		Alignment conditionalExpressionAlignment =this.scribe.createAlignment(\r\n				\"conditionalExpression\", //$NON-NLS-1$\r\n				this.preferences.conditional_expression_alignment,\r\n				2,\r\n				this.scribe.scanner.currentPosition);\r\n\r\n		this.scribe.enterAlignment(conditionalExpressionAlignment);\r\n		boolean ok = false;\r\n		do {\r\n			try {\r\n				this.scribe.alignFragment(conditionalExpressionAlignment, 0);\r\n				this.scribe.printNextToken(ITerminalSymbols.TokenNameQUESTION, this.preferences.insert_space_before_question_in_conditional);\r\n\r\n				if (this.preferences.insert_space_after_question_in_conditional) {\r\n					this.scribe.space();\r\n				}\r\n				conditionalExpression.valueIfTrue.traverse(this, scope);\r\n\r\n				this.scribe.alignFragment(conditionalExpressionAlignment, 1);\r\n				this.scribe.printNextToken(ITerminalSymbols.TokenNameCOLON, this.preferences.insert_space_before_colon_in_conditional);\r\n\r\n				if (this.preferences.insert_space_after_colon_in_conditional) {\r\n					this.scribe.space();\r\n				}\r\n				conditionalExpression.valueIfFalse.traverse(this, scope);\r\n\r\n				ok = true;\r\n			} catch (AlignmentException e) {\r\n				this.scribe.redoAlignment(e);\r\n			}\r\n		} while (!ok);\r\n		this.scribe.exitAlignment(conditionalExpressionAlignment, true);\r\n			\r\n		if (numberOfParens > 0) {\r\n			manageClosingParenthesizedExpression(conditionalExpression, numberOfParens);\r\n		}\r\n		return false;	\r\n	}\r\n\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.ConstructorDeclaration, org.eclipse.jdt.internal.compiler.lookup.ClassScope)\r\n	 */\r\n	public boolean visit(\r\n		ConstructorDeclaration constructorDeclaration,\r\n		ClassScope scope) {\r\n			\r\n		if (constructorDeclaration.modifiers != NO_MODIFIERS) {\r\n			this.scribe.printModifiers();\r\n		} else {\r\n			this.scribe.printComment();\r\n		}			\r\n		/*\r\n		 * Print the method name\r\n		 */	\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameIdentifier, true); \r\n\r\n		formatMethodArguments(\r\n			constructorDeclaration, \r\n			this.preferences.insert_space_before_method_declaration_open_paren,\r\n			this.preferences.insert_space_between_empty_arguments,\r\n			this.preferences.insert_space_before_closing_paren,\r\n			this.preferences.insert_space_before_first_argument,\r\n			this.preferences.insert_space_before_comma_in_constructor_arguments,\r\n			this.preferences.insert_space_after_comma_in_constructor_arguments);\r\n\r\n		formatThrowsClause(\r\n				constructorDeclaration,\r\n				this.preferences.insert_space_before_comma_in_constructor_throws,\r\n				this.preferences.insert_space_after_comma_in_constructor_throws);\r\n\r\n		if (!constructorDeclaration.isNative() && !constructorDeclaration.isAbstract()) {\r\n			/*\r\n			 * Method body\r\n			 */\r\n			String method_declaration_brace = this.preferences.method_declaration_brace_position;\r\n			formatOpeningBrace(method_declaration_brace, this.preferences.insert_space_before_method_open_brace);\r\n			this.scribe.indent();			\r\n			final int numberOfBlankLinesAtBeginningOfMethodBody = this.preferences.number_of_blank_lines_to_insert_at_beginning_of_method_body;\r\n			if (numberOfBlankLinesAtBeginningOfMethodBody > 0) {\r\n				this.scribe.printNewLines(numberOfBlankLinesAtBeginningOfMethodBody);\r\n			}\r\n			if (constructorDeclaration.constructorCall != null && !constructorDeclaration.constructorCall.isImplicitSuper()) {\r\n				this.scribe.printNewLine();\r\n				constructorDeclaration.constructorCall.traverse(this, constructorDeclaration.scope);\r\n				this.scribe.printNextToken(ITerminalSymbols.TokenNameSEMICOLON, this.preferences.insert_space_before_semicolon);\r\n				this.scribe.printTrailingComment();\r\n			}\r\n			final Statement[] statements = constructorDeclaration.statements;\r\n			if (statements != null) {\r\n				this.scribe.printNewLine();\r\n				formatStatements(constructorDeclaration.scope, statements);\r\n			} else if (this.preferences.insert_new_line_in_empty_method_body) {\r\n				this.scribe.printNewLine();\r\n			}\r\n			this.scribe.printComment();\r\n			this.scribe.unIndent();\r\n			this.scribe.printNextToken(ITerminalSymbols.TokenNameRBRACE);\r\n			this.scribe.printTrailingComment();\r\n			if (method_declaration_brace.equals(FormattingPreferences.NEXT_LINE_SHIFTED)) {\r\n				this.scribe.unIndent();\r\n			}\r\n		} else {\r\n			// no method body\r\n			this.scribe.printNextToken(ITerminalSymbols.TokenNameSEMICOLON, this.preferences.insert_space_before_semicolon);\r\n			this.scribe.printTrailingComment();\r\n		}\r\n		return false;\r\n	}\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.Continue, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(ContinueStatement continueStatement, BlockScope scope) {\r\n\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNamecontinue);\r\n		if (continueStatement.label != null) {\r\n			this.scribe.printNextToken(ITerminalSymbols.TokenNameIdentifier, true);\r\n		}\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameSEMICOLON, this.preferences.insert_space_before_semicolon);\r\n		return false;\r\n	}\r\n\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.DoStatement, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(DoStatement doStatement, BlockScope scope) {\r\n\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNamedo);\r\n		\r\n		final Statement action = doStatement.action;\r\n		if (action != null) {\r\n			if (action instanceof Block) {\r\n				action.traverse(this, scope);\r\n			} else {\r\n				this.scribe.printNewLine();\r\n				this.scribe.indent();\r\n				action.traverse(this, scope);\r\n				this.scribe.unIndent();\r\n			}\r\n			if (action instanceof Expression) {\r\n				this.scribe.printNextToken(ITerminalSymbols.TokenNameSEMICOLON, this.preferences.insert_space_before_semicolon);\r\n				this.scribe.printTrailingComment();\r\n			} else if (action instanceof Block && this.preferences.insert_new_line_in_control_statements) {\r\n				this.scribe.printTrailingComment();\r\n			}\r\n		} else {\r\n			this.scribe.indent();\r\n			/*\r\n			 * This is an empty statement\r\n			 */\r\n			formatEmptyStatement(); \r\n			this.scribe.unIndent();\r\n		}\r\n		\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNamewhile, this.preferences.insert_space_after_block_close_brace);\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameLPAREN, this.preferences.insert_space_before_while_condition);\r\n		\r\n		if (this.preferences.insert_space_in_while_condition) {\r\n			this.scribe.space();\r\n		}\r\n		\r\n		doStatement.condition.traverse(this, scope);\r\n		\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameRPAREN, this.preferences.insert_space_in_while_condition);\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameSEMICOLON, this.preferences.insert_space_before_semicolon);\r\n		return false;\r\n	}\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.DoubleLiteral, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(DoubleLiteral doubleLiteral, BlockScope scope) {\r\n\r\n		final int numberOfParens = (doubleLiteral.bits & AstNode.ParenthesizedMASK) >> AstNode.ParenthesizedSHIFT;\r\n		if (numberOfParens > 0) {\r\n			manageOpeningParenthesizedExpression(doubleLiteral, numberOfParens);\r\n		}\r\n		Constant constant = doubleLiteral.constant;\r\n		if (constant != null && constant.doubleValue() < 0) {\r\n			this.scribe.printNextToken(ITerminalSymbols.TokenNameMINUS);			\r\n		}\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameDoubleLiteral);\r\n\r\n		if (numberOfParens > 0) {\r\n			manageClosingParenthesizedExpression(doubleLiteral, numberOfParens);\r\n		}\r\n		return false;\r\n	}\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.EmptyStatement, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(EmptyStatement statement, BlockScope scope) {\r\n\r\n		formatEmptyStatement();\r\n		return false;	\r\n	}\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.EqualExpression, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(EqualExpression equalExpression, BlockScope scope) {\r\n\r\n		if ((equalExpression.bits & AstNode.OperatorMASK) >> AstNode.OperatorSHIFT == OperatorIds.EQUAL_EQUAL) {\r\n			return dumpBinaryExpression(equalExpression, ITerminalSymbols.TokenNameEQUAL_EQUAL, scope);\r\n		} else {\r\n			return dumpBinaryExpression(equalExpression, ITerminalSymbols.TokenNameNOT_EQUAL, scope);\r\n		}			\r\n	}\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.ExplicitConstructorCall, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(\r\n		ExplicitConstructorCall explicitConstructor,\r\n		BlockScope scope) {\r\n\r\n		if (explicitConstructor.isImplicitSuper()) {\r\n			return false;\r\n		}\r\n		final Expression qualification = explicitConstructor.qualification;\r\n		if (qualification != null) {\r\n			qualification.traverse(this, scope);\r\n		}\r\n\r\n		if (explicitConstructor.isSuperAccess()) {\r\n			this.scribe.printNextToken(ITerminalSymbols.TokenNamesuper);\r\n		} else {\r\n			this.scribe.printNextToken(ITerminalSymbols.TokenNamethis);\r\n		}\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameLPAREN, this.preferences.insert_space_before_message_send);\r\n		\r\n		final Expression[] arguments = explicitConstructor.arguments;\r\n		if (arguments != null) {\r\n			int argumentLength = arguments.length;\r\n			Alignment argumentsAlignment =this.scribe.createAlignment(\r\n					\"explicit_constructor_call\",//$NON-NLS-1$\r\n					this.preferences.explicit_constructor_arguments_alignment,\r\n					argumentLength,\r\n					this.scribe.scanner.currentPosition);\r\n			this.scribe.enterAlignment(argumentsAlignment);\r\n			boolean ok = false;\r\n			do {\r\n				try {\r\n					if (this.preferences.insert_space_within_message_send) {\r\n						this.scribe.space();\r\n					}\r\n					for (int i = 0; i < argumentLength; i++) {\r\n						if (i > 0) {\r\n							this.scribe.printNextToken(ITerminalSymbols.TokenNameCOMMA, this.preferences.insert_space_before_comma_in_explicitconstructorcall_arguments);\r\n						}\r\n						this.scribe.alignFragment(argumentsAlignment, i);\r\n						if (i > 0 && this.preferences.insert_space_after_comma_in_explicitconstructorcall_arguments) {\r\n							this.scribe.space();\r\n						}\r\n						arguments[i].traverse(this, scope);\r\n					}\r\n					ok = true;\r\n				} catch (AlignmentException e) {\r\n					this.scribe.redoAlignment(e);\r\n				}\r\n			} while (!ok);\r\n			this.scribe.exitAlignment(argumentsAlignment, true);\r\n			this.scribe.printNextToken(ITerminalSymbols.TokenNameRPAREN, this.preferences.insert_space_within_message_send); \r\n		} else {\r\n			this.scribe.printNextToken(ITerminalSymbols.TokenNameRPAREN, this.preferences.insert_space_between_empty_arguments); \r\n		}\r\n		return false;\r\n	}\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.FalseLiteral, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(FalseLiteral falseLiteral, BlockScope scope) {\r\n\r\n		final int numberOfParens = (falseLiteral.bits & AstNode.ParenthesizedMASK) >> AstNode.ParenthesizedSHIFT;\r\n		if (numberOfParens > 0) {\r\n			manageOpeningParenthesizedExpression(falseLiteral, numberOfParens);\r\n		}\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNamefalse);\r\n\r\n		if (numberOfParens > 0) {\r\n			manageClosingParenthesizedExpression(falseLiteral, numberOfParens);\r\n		}\r\n		return false;\r\n	}\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.FieldReference, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(FieldReference fieldReference, BlockScope scope) {\r\n\r\n		final int numberOfParens = (fieldReference.bits & AstNode.ParenthesizedMASK) >> AstNode.ParenthesizedSHIFT;\r\n		if (numberOfParens > 0) {\r\n			manageOpeningParenthesizedExpression(fieldReference, numberOfParens);\r\n		}\r\n		fieldReference.receiver.traverse(this, scope);\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameDOT);\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameIdentifier);\r\n		\r\n		if (numberOfParens > 0) {\r\n			manageClosingParenthesizedExpression(fieldReference, numberOfParens);\r\n		}\r\n		return false;\r\n	}\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.FloatLiteral, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(FloatLiteral floatLiteral, BlockScope scope) {\r\n\r\n		final int numberOfParens = (floatLiteral.bits & AstNode.ParenthesizedMASK) >> AstNode.ParenthesizedSHIFT;\r\n		if (numberOfParens > 0) {\r\n			manageOpeningParenthesizedExpression(floatLiteral, numberOfParens);\r\n		}\r\n		Constant constant = floatLiteral.constant;\r\n		if (constant != null && floatLiteral.constant.floatValue() < 0) {\r\n			this.scribe.printNextToken(ITerminalSymbols.TokenNameMINUS);			\r\n		}\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameFloatingPointLiteral);\r\n\r\n		if (numberOfParens > 0) {\r\n			manageClosingParenthesizedExpression(floatLiteral, numberOfParens);\r\n		}\r\n		return false;\r\n	}\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.ForStatement, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(ForStatement forStatement, BlockScope scope) {\r\n	\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNamefor);\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameLPAREN, this.preferences.insert_space_before_for_paren);\r\n		\r\n		if (this.preferences.insert_space_in_for_parens) {\r\n			this.scribe.space();\r\n		}\r\n		final Statement[] initializations = forStatement.initializations;\r\n		if (initializations != null) {\r\n			int length = initializations.length;\r\n			for (int i = 0; i < length; i++) {\r\n				initializations[i].traverse(this, scope);\r\n				if (i >= 0 && (i < length - 1) && !(initializations[i] instanceof LocalDeclaration)) {\r\n					this.scribe.printNextToken(ITerminalSymbols.TokenNameCOMMA, this.preferences.insert_space_before_comma_in_for_inits);\r\n					if (this.preferences.insert_space_after_comma_in_for_inits) {\r\n						this.scribe.space();\r\n					}\r\n				}				\r\n			}\r\n		}\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameSEMICOLON, this.preferences.insert_space_before_semicolon);\r\n		if (this.preferences.insert_space_after_semicolon_in_for) {\r\n			this.scribe.space();\r\n		}\r\n		final Expression condition = forStatement.condition;\r\n		if (condition != null) {\r\n			condition.traverse(this, scope);\r\n		}\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameSEMICOLON, this.preferences.insert_space_before_semicolon);\r\n		if (this.preferences.insert_space_after_semicolon_in_for) {\r\n			this.scribe.space();\r\n		}\r\n		final Statement[] increments = forStatement.increments;\r\n		if (increments != null) {\r\n			for (int i = 0, length = increments.length; i < length; i++) {\r\n				increments[i].traverse(this, scope);\r\n				if (i != length - 1) {\r\n					this.scribe.printNextToken(ITerminalSymbols.TokenNameCOMMA, this.preferences.insert_space_before_comma_in_for_increments);\r\n					if (this.preferences.insert_space_after_comma_in_for_increments) {\r\n						this.scribe.space();\r\n					}\r\n				}\r\n			}\r\n		}\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameRPAREN, this.preferences.insert_space_in_for_parens);\r\n		\r\n		final Statement action = forStatement.action;\r\n		if (action != null) {\r\n			if (action instanceof Block) {\r\n				action.traverse(this, scope);\r\n			} else {\r\n				this.scribe.indent();\r\n				this.scribe.printNewLine();\r\n				action.traverse(this, scope);\r\n				this.scribe.unIndent();\r\n			}\r\n			if (action instanceof Expression) {\r\n				this.scribe.printNextToken(ITerminalSymbols.TokenNameSEMICOLON, this.preferences.insert_space_before_semicolon);\r\n				this.scribe.printTrailingComment();\r\n				this.scribe.printNewLine();\r\n			} else if (action instanceof Block && this.preferences.insert_new_line_in_control_statements) {\r\n				this.scribe.printTrailingComment();\r\n				this.scribe.printNewLine();\r\n			}\r\n		} else {\r\n			this.scribe.indent();\r\n			/*\r\n			 * This is an empty statement\r\n			 */\r\n			formatEmptyStatement(); \r\n			this.scribe.unIndent();\r\n		}\r\n		return false;\r\n	}\r\n\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.IfStatement, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(IfStatement ifStatement, BlockScope scope) {\r\n\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameif);\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameLPAREN, this.preferences.insert_space_before_if_condition);\r\n		if (this.preferences.insert_space_in_if_condition) {\r\n			this.scribe.space();\r\n		}\r\n		ifStatement.condition.traverse(this, scope);\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameRPAREN, this.preferences.insert_space_in_if_condition);\r\n\r\n		final Statement thenStatement = ifStatement.thenStatement;\r\n		final Statement elseStatement = ifStatement.elseStatement;\r\n\r\n		if (thenStatement != null) {\r\n			if (thenStatement instanceof Block) {\r\n				if (isGuardClause((Block)thenStatement) && elseStatement == null && this.preferences.format_guardian_clause_on_one_line) {\r\n					/* \r\n					 * Need a specific formatting for guard clauses\r\n					 * guard clauses are block with a single return or throw\r\n					 * statement\r\n					 */\r\n					 formatGuardClauseBlock((Block) thenStatement, scope);\r\n				} else {\r\n					if (thenStatement instanceof Block) {\r\n						thenStatement.traverse(this, scope);\r\n					} else {\r\n						this.scribe.printNewLine();\r\n						this.scribe.indent();\r\n						thenStatement.traverse(this, scope);\r\n						this.scribe.unIndent();\r\n					}\r\n					if (elseStatement == null || this.preferences.insert_new_line_in_control_statements) {\r\n						this.scribe.printTrailingComment();\r\n					}\r\n				}\r\n			} else if (elseStatement == null && this.preferences.keep_simple_if_on_one_line) {\r\n				Alignment compactIfAlignment = this.scribe.createAlignment(\r\n					\"compactIf\", //$NON-NLS-1$\r\n					this.preferences.compact_if_alignment,\r\n					Alignment.R_OUTERMOST,\r\n					1, \r\n					this.scribe.scanner.currentPosition);\r\n				this.scribe.enterAlignment(compactIfAlignment);\r\n				boolean ok = false;\r\n				do {\r\n					try {\r\n						this.scribe.alignFragment(compactIfAlignment, 0);\r\n						this.scribe.space();\r\n						thenStatement.traverse(this, scope);\r\n						if (thenStatement instanceof Expression) {\r\n							this.scribe.printNextToken(ITerminalSymbols.TokenNameSEMICOLON, this.preferences.insert_space_before_semicolon);\r\n						}\r\n						ok = true;\r\n					} catch (AlignmentException e) {\r\n						this.scribe.redoAlignment(e);\r\n					}\r\n				} while (!ok);\r\n				this.scribe.exitAlignment(compactIfAlignment, true);				\r\n			} else if (this.preferences.keep_then_statement_on_same_line) {\r\n				this.scribe.space();\r\n				thenStatement.traverse(this, scope);\r\n				if (thenStatement instanceof Expression) {\r\n					this.scribe.printNextToken(ITerminalSymbols.TokenNameSEMICOLON, this.preferences.insert_space_before_semicolon);\r\n				}\r\n				this.scribe.printTrailingComment();\r\n				this.scribe.printNewLine();\r\n			} else {\r\n				this.scribe.printTrailingComment();\r\n				this.scribe.printNewLine();\r\n				this.scribe.indent();\r\n				thenStatement.traverse(this, scope);\r\n				if (thenStatement instanceof Expression) {\r\n					this.scribe.printNextToken(ITerminalSymbols.TokenNameSEMICOLON, this.preferences.insert_space_before_semicolon);\r\n				}\r\n				this.scribe.printTrailingComment();\r\n				this.scribe.printNewLine();\r\n				this.scribe.unIndent();\r\n			}\r\n		}\r\n		\r\n		if (elseStatement != null) {\r\n			this.scribe.printNextToken(ITerminalSymbols.TokenNameelse, true);\r\n			if (elseStatement instanceof Block) {\r\n				elseStatement.traverse(this, scope);\r\n			} else if (elseStatement instanceof IfStatement) {\r\n				if (!this.preferences.compact_else_if) {\r\n					this.scribe.printTrailingComment();\r\n					this.scribe.indent();\r\n				}\r\n				this.scribe.space();				\r\n				elseStatement.traverse(this, scope);\r\n				if (!this.preferences.compact_else_if) {\r\n					this.scribe.printTrailingComment();\r\n					this.scribe.unIndent();\r\n				}\r\n			} else if (this.preferences.keep_else_statement_on_same_line) {\r\n				this.scribe.space();\r\n				elseStatement.traverse(this, scope);\r\n				if (elseStatement instanceof Expression) {\r\n					this.scribe.printNextToken(ITerminalSymbols.TokenNameSEMICOLON, this.preferences.insert_space_before_semicolon);\r\n				}\r\n				this.scribe.printTrailingComment();\r\n				this.scribe.printNewLine();\r\n			} else {\r\n				this.scribe.printTrailingComment();\r\n				this.scribe.indent();\r\n				elseStatement.traverse(this, scope);\r\n				if (elseStatement instanceof Expression) {\r\n					this.scribe.printNextToken(ITerminalSymbols.TokenNameSEMICOLON, this.preferences.insert_space_before_semicolon);\r\n				}\r\n				this.scribe.printTrailingComment();\r\n				this.scribe.printNewLine();\r\n				this.scribe.unIndent();\r\n			}\r\n		}\r\n		return false;\r\n	}\r\n	\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.ImportReference, org.eclipse.jdt.internal.compiler.lookup.CompilationUnitScope)\r\n	 */\r\n	public boolean visit(\r\n		ImportReference importRef,\r\n		CompilationUnitScope scope) {\r\n		\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameimport);\r\n		this.scribe.space();\r\n		if (importRef.onDemand) {\r\n			this.scribe.printQualifiedReference(importRef.sourceEnd);\r\n			this.scribe.printNextToken(ITerminalSymbols.TokenNameDOT);\r\n			this.scribe.printNextToken(ITerminalSymbols.TokenNameMULTIPLY);			\r\n			this.scribe.printNextToken(ITerminalSymbols.TokenNameSEMICOLON, this.preferences.insert_space_before_semicolon);\r\n		} else {\r\n			this.scribe.printQualifiedReference(importRef.sourceEnd);\r\n			this.scribe.printNextToken(ITerminalSymbols.TokenNameSEMICOLON, this.preferences.insert_space_before_semicolon);\r\n		}\r\n		this.scribe.printTrailingComment();\r\n		this.scribe.printNewLine();\r\n		return false;\r\n	}\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.Initializer, org.eclipse.jdt.internal.compiler.lookup.MethodScope)\r\n	 */\r\n	public boolean visit(Initializer initializer, MethodScope scope) {\r\n\r\n		if (initializer.isStatic()) {\r\n			this.scribe.printNextToken(ITerminalSymbols.TokenNamestatic);\r\n		}\r\n		initializer.block.traverse(this, scope);\r\n		return false;\r\n	}\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.InstanceOfExpression, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(\r\n		InstanceOfExpression instanceOfExpression,\r\n		BlockScope scope) {\r\n\r\n		final int numberOfParens = (instanceOfExpression.bits & AstNode.ParenthesizedMASK) >> AstNode.ParenthesizedSHIFT;\r\n		if (numberOfParens > 0) {\r\n			manageOpeningParenthesizedExpression(instanceOfExpression, numberOfParens);\r\n		}\r\n		instanceOfExpression.expression.traverse(this, scope);\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameinstanceof, true);\r\n		this.scribe.space();\r\n		instanceOfExpression.type.traverse(this, scope);\r\n		\r\n		if (numberOfParens > 0) {\r\n			manageClosingParenthesizedExpression(instanceOfExpression, numberOfParens);\r\n		}\r\n		return false;\r\n	}\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.AbstractSyntaxTreeVisitorAdapter#visit(org.eclipse.jdt.internal.compiler.ast.IntLiteral, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(IntLiteral intLiteral, BlockScope scope) {\r\n\r\n		final int numberOfParens = (intLiteral.bits & AstNode.ParenthesizedMASK) >> AstNode.ParenthesizedSHIFT;\r\n		if (numberOfParens > 0) {\r\n			manageOpeningParenthesizedExpression(intLiteral, numberOfParens);\r\n		}\r\n		Constant constant = intLiteral.constant;\r\n		if (constant != null && constant.intValue() < 0) {\r\n			this.scribe.printNextToken(ITerminalSymbols.TokenNameMINUS);			\r\n		}\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameIntegerLiteral);\r\n\r\n		if (numberOfParens > 0) {\r\n			manageClosingParenthesizedExpression(intLiteral, numberOfParens);\r\n		}\r\n		return false;\r\n	}\r\n\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.LabeledStatement, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(LabeledStatement labeledStatement, BlockScope scope) {\r\n\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameIdentifier);\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameCOLON, this.preferences.insert_space_before_colon_in_labeled_statement);\r\n		if (this.preferences.insert_space_after_colon_in_labeled_statement) {\r\n			this.scribe.space();\r\n		}\r\n		labeledStatement.statement.traverse(this, scope);\r\n		return false;\r\n	}\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.LocalDeclaration, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(LocalDeclaration localDeclaration, BlockScope scope) {\r\n\r\n		if (!isMultipleLocalDeclaration(localDeclaration)) {\r\n			if (localDeclaration.modifiers != NO_MODIFIERS) {\r\n				this.scribe.printModifiers();\r\n				this.scribe.space();\r\n			}\r\n	\r\n			/*\r\n			 * Argument type \r\n			 */		\r\n			if (localDeclaration.type != null) {\r\n				localDeclaration.type.traverse(this, scope);\r\n			}\r\n		}\r\n		/*\r\n		 * Print the argument name\r\n		 */	\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameIdentifier, true); \r\n		/*\r\n		 * Check for extra dimensions\r\n		 */\r\n		int extraDimensions = getExtraDimension();\r\n		if (extraDimensions != 0) {\r\n			 for (int index = 0; index < extraDimensions; index++) {\r\n			 	this.scribe.printNextToken(ITerminalSymbols.TokenNameLBRACKET);\r\n			 	this.scribe.printNextToken(ITerminalSymbols.TokenNameRBRACKET);\r\n			 }\r\n		}\r\n	\r\n		if (localDeclaration.initialization != null) {\r\n			/*\r\n			 * Print the method name\r\n			 */	\r\n			this.scribe.printNextToken(ITerminalSymbols.TokenNameEQUAL, this.preferences.insert_space_before_assignment_operators);\r\n			if (this.preferences.insert_space_after_assignment_operators) {\r\n				this.scribe.space();\r\n			}			 \r\n			localDeclaration.initialization.traverse(this, scope);\r\n		}\r\n\r\n		if (isPartOfMultipleLocalDeclaration()) {\r\n			this.scribe.printNextToken(ITerminalSymbols.TokenNameCOMMA, this.preferences.insert_space_before_comma_in_multiple_local_declarations); \r\n			if (this.preferences.insert_space_after_comma_in_multiple_local_declarations) {\r\n				this.scribe.space();\r\n			}\r\n		}\r\n		return false;\r\n	}\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.LocalTypeDeclaration, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(\r\n		LocalTypeDeclaration localTypeDeclaration,\r\n		BlockScope scope) {\r\n\r\n			format(localTypeDeclaration);\r\n			return false;\r\n	}\r\n	\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.LongLiteral, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(LongLiteral longLiteral, BlockScope scope) {\r\n\r\n		final int numberOfParens = (longLiteral.bits & AstNode.ParenthesizedMASK) >> AstNode.ParenthesizedSHIFT;\r\n		if (numberOfParens > 0) {\r\n			manageOpeningParenthesizedExpression(longLiteral, numberOfParens);\r\n		}\r\n		Constant constant = longLiteral.constant;\r\n		if (constant != null && constant.longValue() < 0) {\r\n			this.scribe.printNextToken(ITerminalSymbols.TokenNameMINUS);			\r\n		}\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameLongLiteral);\r\n\r\n		if (numberOfParens > 0) {\r\n			manageClosingParenthesizedExpression(longLiteral, numberOfParens);\r\n		}\r\n		return false;\r\n	}\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.AbstractSyntaxTreeVisitorAdapter#visit(org.eclipse.jdt.internal.compiler.ast.MemberTypeDeclaration, org.eclipse.jdt.internal.compiler.lookup.ClassScope)\r\n	 */\r\n	public boolean visit(MemberTypeDeclaration memberTypeDeclaration, ClassScope scope) {\r\n		Alignment memberTypeAlignment = this.scribe.getAlignment(\"typeMembers\");		//$NON-NLS-1$\r\n		format(memberTypeDeclaration);\r\n		this.scribe.exitAlignment(memberTypeAlignment, false);		\r\n		return false;\r\n	}\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.MessageSend, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(MessageSend messageSend, BlockScope scope) {\r\n\r\n		final int numberOfParens = (messageSend.bits & AstNode.ParenthesizedMASK) >> AstNode.ParenthesizedSHIFT;\r\n		if (numberOfParens > 0) {\r\n			manageOpeningParenthesizedExpression(messageSend, numberOfParens);\r\n		}\r\n		Alignment messageAlignment = null;\r\n		if (!messageSend.receiver.isImplicitThis()) {\r\n			messageSend.receiver.traverse(this, scope);\r\n			messageAlignment = this.scribe.createAlignment(\r\n					\"messageAlignment\", //$NON-NLS-1$\r\n					this.preferences.message_send_selector_alignment,\r\n					1,\r\n					this.scribe.scanner.currentPosition);\r\n			this.scribe.enterAlignment(messageAlignment);\r\n			boolean ok = false;\r\n			do {\r\n				try {\r\n					formatMessageSend(messageSend, scope, messageAlignment);\r\n					ok = true;\r\n				} catch (AlignmentException e) {\r\n					this.scribe.redoAlignment(e);\r\n				}\r\n			} while (!ok);\r\n			this.scribe.exitAlignment(messageAlignment, true);\r\n		} else {\r\n			formatMessageSend(messageSend, scope, null);			\r\n		}\r\n		if (numberOfParens > 0) {\r\n			manageClosingParenthesizedExpression(messageSend, numberOfParens);\r\n		}\r\n		return false;\r\n	}\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.MethodDeclaration, org.eclipse.jdt.internal.compiler.lookup.ClassScope)\r\n	 */\r\n	public boolean visit(\r\n		MethodDeclaration methodDeclaration,\r\n		ClassScope scope) {\r\n\r\n		if (methodDeclaration.modifiers != NO_MODIFIERS) {\r\n			this.scribe.printModifiers();\r\n			this.scribe.space();\r\n		}\r\n		\r\n		/*\r\n		 * Print the method return type\r\n		 */	\r\n		final TypeReference returnType = methodDeclaration.returnType;\r\n		final MethodScope methodDeclarationScope = methodDeclaration.scope;\r\n		\r\n		if (returnType != null) {\r\n			returnType.traverse(this, methodDeclarationScope);\r\n		}\r\n		/*\r\n		 * Print the method name\r\n		 */\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameIdentifier, true); \r\n\r\n		/*\r\n		 * Check for extra dimensions\r\n		 */\r\n		int extraDimensions = getExtraDimension();\r\n		if (extraDimensions != 0) {\r\n			 for (int i = 0; i < extraDimensions; i++) {\r\n			 	this.scribe.printNextToken(ITerminalSymbols.TokenNameLBRACKET);\r\n			 	this.scribe.printNextToken(ITerminalSymbols.TokenNameRBRACKET);\r\n			 }\r\n		}\r\n\r\n		formatMethodArguments(\r\n			methodDeclaration, \r\n			this.preferences.insert_space_before_method_declaration_open_paren,\r\n			this.preferences.insert_space_between_empty_arguments,\r\n			this.preferences.insert_space_before_closing_paren,\r\n			this.preferences.insert_space_before_first_argument,\r\n			this.preferences.insert_space_before_comma_in_method_arguments,\r\n			this.preferences.insert_space_after_comma_in_method_arguments);\r\n\r\n		formatThrowsClause(\r\n			methodDeclaration,\r\n			this.preferences.insert_space_before_comma_in_method_throws,\r\n			this.preferences.insert_space_after_comma_in_method_throws);\r\n\r\n		if (!methodDeclaration.isNative() && !methodDeclaration.isAbstract() && ((methodDeclaration.modifiers & CompilerModifiers.AccSemicolonBody) == 0)) {\r\n			/*\r\n			 * Method body\r\n			 */\r\n			String method_declaration_brace = this.preferences.method_declaration_brace_position;\r\n			formatOpeningBrace(method_declaration_brace, this.preferences.insert_space_before_method_open_brace);\r\n			this.scribe.indent();			\r\n			final int numberOfBlankLinesAtBeginningOfMethodBody = this.preferences.number_of_blank_lines_to_insert_at_beginning_of_method_body;\r\n			if (numberOfBlankLinesAtBeginningOfMethodBody > 0) {\r\n				this.scribe.printNewLines(numberOfBlankLinesAtBeginningOfMethodBody);\r\n			}\r\n			final Statement[] statements = methodDeclaration.statements;\r\n			if (statements != null) {\r\n				this.scribe.printNewLine();\r\n				formatStatements(methodDeclarationScope, statements);\r\n			} else if (this.preferences.insert_new_line_in_empty_method_body) {\r\n				this.scribe.printNewLine();\r\n			}\r\n			this.scribe.printComment();\r\n			this.scribe.unIndent();\r\n			this.scribe.printNextToken(ITerminalSymbols.TokenNameRBRACE);\r\n			this.scribe.printTrailingComment();\r\n			this.scribe.printNewLine();\r\n			if (method_declaration_brace.equals(FormattingPreferences.NEXT_LINE_SHIFTED)) {\r\n				this.scribe.unIndent();\r\n			}\r\n		} else {\r\n			// no method body\r\n			this.scribe.printNextToken(ITerminalSymbols.TokenNameSEMICOLON, this.preferences.insert_space_before_semicolon);\r\n			this.scribe.printTrailingComment();\r\n			this.scribe.printNewLine();\r\n		}\r\n		return false;\r\n	}\r\n	\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.NullLiteral, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(NullLiteral nullLiteral, BlockScope scope) {\r\n\r\n		final int numberOfParens = (nullLiteral.bits & AstNode.ParenthesizedMASK) >> AstNode.ParenthesizedSHIFT;\r\n		if (numberOfParens > 0) {\r\n			manageOpeningParenthesizedExpression(nullLiteral, numberOfParens);\r\n		}\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNamenull);\r\n\r\n		if (numberOfParens > 0) {\r\n			manageClosingParenthesizedExpression(nullLiteral, numberOfParens);\r\n		}\r\n		return false;\r\n	}\r\n\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.OR_OR_Expression, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(OR_OR_Expression or_or_Expression, BlockScope scope) {\r\n\r\n		return dumpBinaryExpression(or_or_Expression, ITerminalSymbols.TokenNameOR_OR, scope);\r\n	}\r\n	\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.PostfixExpression, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(\r\n		PostfixExpression postfixExpression,\r\n		BlockScope scope) {\r\n\r\n		final int numberOfParens = (postfixExpression.bits & AstNode.ParenthesizedMASK) >> AstNode.ParenthesizedSHIFT;\r\n		if (numberOfParens > 0) {\r\n			manageOpeningParenthesizedExpression(postfixExpression, numberOfParens);\r\n		}\r\n		postfixExpression.lhs.traverse(this, scope);\r\n		int operator = postfixExpression.operator == OperatorIds.PLUS \r\n			? ITerminalSymbols.TokenNamePLUS_PLUS : ITerminalSymbols.TokenNameMINUS_MINUS;\r\n		this.scribe.printNextToken(operator, this.preferences.insert_space_before_postfix_operator);\r\n		if (this.preferences.insert_space_after_postfix_operator) {\r\n			this.scribe.space();\r\n		}\r\n		if (numberOfParens > 0) {\r\n			manageClosingParenthesizedExpression(postfixExpression, numberOfParens);\r\n		}\r\n		return false;\r\n	}\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.PrefixExpression, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(PrefixExpression prefixExpression, BlockScope scope) {\r\n\r\n		final int numberOfParens = (prefixExpression.bits & AstNode.ParenthesizedMASK) >> AstNode.ParenthesizedSHIFT;\r\n		if (numberOfParens > 0) {\r\n			manageOpeningParenthesizedExpression(prefixExpression, numberOfParens);\r\n		}\r\n		int operator = prefixExpression.operator == OperatorIds.PLUS \r\n			? ITerminalSymbols.TokenNamePLUS_PLUS : ITerminalSymbols.TokenNameMINUS_MINUS;\r\n		this.scribe.printNextToken(operator, this.preferences.insert_space_before_prefix_operator);\r\n		prefixExpression.lhs.traverse(this, scope);\r\n		if (this.preferences.insert_space_after_prefix_operator) {\r\n			this.scribe.space();\r\n		}\r\n		if (numberOfParens > 0) {\r\n			manageClosingParenthesizedExpression(prefixExpression, numberOfParens);\r\n		}\r\n		return false;\r\n	}\r\n	\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.QualifiedAllocationExpression, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(\r\n		QualifiedAllocationExpression qualifiedAllocationExpression,\r\n		BlockScope scope) {\r\n			\r\n		final int numberOfParens = (qualifiedAllocationExpression.bits & AstNode.ParenthesizedMASK) >> AstNode.ParenthesizedSHIFT;\r\n		if (numberOfParens > 0) {\r\n			manageOpeningParenthesizedExpression(qualifiedAllocationExpression, numberOfParens);\r\n		}\r\n		final Expression enclosingInstance = qualifiedAllocationExpression.enclosingInstance;\r\n		if (enclosingInstance != null) {\r\n			enclosingInstance.traverse(this, scope);\r\n			this.scribe.printNextToken(ITerminalSymbols.TokenNameDOT);\r\n		}\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNamenew);\r\n		this.scribe.space();\r\n		qualifiedAllocationExpression.type.traverse(this, scope);\r\n		\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameLPAREN, this.preferences.insert_space_before_message_send);\r\n\r\n		final Expression[] arguments = qualifiedAllocationExpression.arguments;\r\n		if (arguments != null) {\r\n			int argumentLength = arguments.length;\r\n			Alignment argumentsAlignment =this.scribe.createAlignment(\r\n					\"allocation\",//$NON-NLS-1$\r\n					this.preferences.qualified_allocation_expression_arguments_alignment,\r\n					argumentLength,\r\n					this.scribe.scanner.currentPosition);\r\n			this.scribe.enterAlignment(argumentsAlignment);\r\n			boolean ok = false;\r\n			do {\r\n				try {\r\n					if (this.preferences.insert_space_within_message_send) {\r\n						this.scribe.space();\r\n					}\r\n					for (int i = 0; i < argumentLength; i++) {\r\n						if (i > 0) {\r\n							this.scribe.printNextToken(ITerminalSymbols.TokenNameCOMMA, this.preferences.insert_space_before_comma_in_allocation_expression);\r\n						}\r\n						this.scribe.alignFragment(argumentsAlignment, i);\r\n						if (i > 0 && this.preferences.insert_space_after_comma_in_allocation_expression) {\r\n							this.scribe.space();\r\n						}\r\n						arguments[i].traverse(this, scope);\r\n					}\r\n					ok = true;\r\n				} catch (AlignmentException e) {\r\n					this.scribe.redoAlignment(e);\r\n				}\r\n			} while (!ok);\r\n			this.scribe.exitAlignment(argumentsAlignment, true);\r\n			this.scribe.printNextToken(ITerminalSymbols.TokenNameRPAREN, this.preferences.insert_space_within_message_send); \r\n		} else {\r\n			this.scribe.printNextToken(ITerminalSymbols.TokenNameRPAREN, this.preferences.insert_space_between_empty_arguments); \r\n		}\r\n		final AnonymousLocalTypeDeclaration anonymousType = qualifiedAllocationExpression.anonymousType;\r\n		if (anonymousType != null) {\r\n			anonymousType.traverse(this, scope);\r\n		}\r\n		if (numberOfParens > 0) {\r\n			manageClosingParenthesizedExpression(qualifiedAllocationExpression, numberOfParens);\r\n		}\r\n		return false;\r\n	}\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.QualifiedNameReference, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(\r\n		QualifiedNameReference qualifiedNameReference,\r\n		BlockScope scope) {\r\n\r\n		final int numberOfParens = (qualifiedNameReference.bits & AstNode.ParenthesizedMASK) >> AstNode.ParenthesizedSHIFT;\r\n		if (numberOfParens > 0) {\r\n			manageOpeningParenthesizedExpression(qualifiedNameReference, numberOfParens);\r\n		}\r\n		this.scribe.printQualifiedReference(qualifiedNameReference.sourceEnd);\r\n\r\n		if (numberOfParens > 0) {\r\n			manageClosingParenthesizedExpression(qualifiedNameReference, numberOfParens);\r\n		}\r\n		return false;\r\n	}\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.QualifiedSuperReference, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(\r\n		QualifiedSuperReference qualifiedSuperReference,\r\n		BlockScope scope) {\r\n\r\n		final int numberOfParens = (qualifiedSuperReference.bits & AstNode.ParenthesizedMASK) >> AstNode.ParenthesizedSHIFT;\r\n		if (numberOfParens > 0) {\r\n			manageOpeningParenthesizedExpression(qualifiedSuperReference, numberOfParens);\r\n		}\r\n		qualifiedSuperReference.qualification.traverse(this, scope);\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameDOT);\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNamesuper);\r\n		\r\n		if (numberOfParens > 0) {\r\n			manageClosingParenthesizedExpression(qualifiedSuperReference, numberOfParens);\r\n		}\r\n		return false;\r\n	}\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.QualifiedThisReference, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(\r\n		QualifiedThisReference qualifiedThisReference,\r\n		BlockScope scope) {\r\n\r\n		final int numberOfParens = (qualifiedThisReference.bits & AstNode.ParenthesizedMASK) >> AstNode.ParenthesizedSHIFT;\r\n		if (numberOfParens > 0) {\r\n			manageOpeningParenthesizedExpression(qualifiedThisReference, numberOfParens);\r\n		}\r\n		qualifiedThisReference.qualification.traverse(this, scope);\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameDOT);\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNamethis);\r\n		\r\n		if (numberOfParens > 0) {\r\n			manageClosingParenthesizedExpression(qualifiedThisReference, numberOfParens);\r\n		}\r\n		return false;\r\n	}\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.QualifiedTypeReference, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(\r\n		QualifiedTypeReference qualifiedTypeReference,\r\n		BlockScope scope) {\r\n\r\n		final int numberOfParens = (qualifiedTypeReference.bits & AstNode.ParenthesizedMASK) >> AstNode.ParenthesizedSHIFT;\r\n		if (numberOfParens > 0) {\r\n			manageOpeningParenthesizedExpression(qualifiedTypeReference, numberOfParens);\r\n		}\r\n		this.scribe.printQualifiedReference(qualifiedTypeReference.sourceEnd + 1);\r\n		\r\n		if (numberOfParens > 0) {\r\n			manageClosingParenthesizedExpression(qualifiedTypeReference, numberOfParens);\r\n		}\r\n		return false;\r\n	}\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.QualifiedTypeReference, org.eclipse.jdt.internal.compiler.lookup.ClassScope)\r\n	 */\r\n	public boolean visit(\r\n		QualifiedTypeReference qualifiedTypeReference,\r\n		ClassScope scope) {\r\n\r\n			final int numberOfParens = (qualifiedTypeReference.bits & AstNode.ParenthesizedMASK) >> AstNode.ParenthesizedSHIFT;\r\n			if (numberOfParens > 0) {\r\n				manageOpeningParenthesizedExpression(qualifiedTypeReference, numberOfParens);\r\n			}\r\n			this.scribe.printQualifiedReference(qualifiedTypeReference.sourceEnd + 1);\r\n			\r\n			if (numberOfParens > 0) {\r\n				manageClosingParenthesizedExpression(qualifiedTypeReference, numberOfParens);\r\n			}\r\n			return false;\r\n	}\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.ReturnStatement, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(ReturnStatement returnStatement, BlockScope scope) {\r\n		\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNamereturn);\r\n		final Expression expression = returnStatement.expression;\r\n		if (expression != null) {\r\n			this.scribe.space();\r\n			expression.traverse(this, scope);\r\n		}\r\n		/*\r\n		 * Print the semi-colon\r\n		 */	\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameSEMICOLON, this.preferences.insert_space_before_semicolon);\r\n		return false;\r\n	}\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.AbstractSyntaxTreeVisitorAdapter#visit(org.eclipse.jdt.internal.compiler.ast.SingleNameReference, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(SingleNameReference singleNameReference, BlockScope scope) {\r\n\r\n		final int numberOfParens = (singleNameReference.bits & AstNode.ParenthesizedMASK) >> AstNode.ParenthesizedSHIFT;\r\n		if (numberOfParens > 0) {\r\n			manageOpeningParenthesizedExpression(singleNameReference, numberOfParens);\r\n		}\r\n		this.scribe.printNextToken(SINGLETYPEREFERENCE_EXPECTEDTOKENS, false, true);\r\n		\r\n		if (numberOfParens > 0) {\r\n			manageClosingParenthesizedExpression(singleNameReference, numberOfParens);\r\n		}\r\n		return false;\r\n	}\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.SingleTypeReference, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(\r\n		SingleTypeReference singleTypeReference,\r\n		BlockScope scope) {\r\n\r\n		final int numberOfParens = (singleTypeReference.bits & AstNode.ParenthesizedMASK) >> AstNode.ParenthesizedSHIFT;\r\n		if (numberOfParens > 0) {\r\n			manageOpeningParenthesizedExpression(singleTypeReference, numberOfParens);\r\n		}\r\n		this.scribe.printNextToken(SINGLETYPEREFERENCE_EXPECTEDTOKENS, false, true);\r\n\r\n		if (numberOfParens > 0) {\r\n			manageClosingParenthesizedExpression(singleTypeReference, numberOfParens);\r\n		}\r\n		return false;\r\n	}\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.SingleTypeReference, org.eclipse.jdt.internal.compiler.lookup.ClassScope)\r\n	 */\r\n	public boolean visit(\r\n		SingleTypeReference singleTypeReference,\r\n		ClassScope scope) {\r\n\r\n		final int numberOfParens = (singleTypeReference.bits & AstNode.ParenthesizedMASK) >> AstNode.ParenthesizedSHIFT;\r\n		if (numberOfParens > 0) {\r\n			manageOpeningParenthesizedExpression(singleTypeReference, numberOfParens);\r\n		}\r\n		this.scribe.printNextToken(SINGLETYPEREFERENCE_EXPECTEDTOKENS, false, true);\r\n\r\n		if (numberOfParens > 0) {\r\n			manageClosingParenthesizedExpression(singleTypeReference, numberOfParens);\r\n		}\r\n		return false;\r\n	}\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.StringLiteral, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(StringLiteral stringLiteral, BlockScope scope) {\r\n\r\n		final int numberOfParens = (stringLiteral.bits & AstNode.ParenthesizedMASK) >> AstNode.ParenthesizedSHIFT;\r\n		if (numberOfParens > 0) {\r\n			manageOpeningParenthesizedExpression(stringLiteral, numberOfParens);\r\n		}\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameStringLiteral);\r\n		\r\n		if (numberOfParens > 0) {\r\n			manageClosingParenthesizedExpression(stringLiteral, numberOfParens);\r\n		}\r\n		return false;\r\n	}\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.SuperReference, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(SuperReference superReference, BlockScope scope) {\r\n\r\n		final int numberOfParens = (superReference.bits & AstNode.ParenthesizedMASK) >> AstNode.ParenthesizedSHIFT;\r\n		if (numberOfParens > 0) {\r\n			manageOpeningParenthesizedExpression(superReference, numberOfParens);\r\n		}\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNamesuper);\r\n\r\n		if (numberOfParens > 0) {\r\n			manageClosingParenthesizedExpression(superReference, numberOfParens);\r\n		}\r\n		return false;\r\n	}\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.SwitchStatement, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(SwitchStatement switchStatement, BlockScope scope) {\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameswitch);\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameLPAREN, this.preferences.insert_space_before_switch_condition);\r\n		\r\n		if (this.preferences.insert_space_in_switch_condition) {\r\n			this.scribe.space();\r\n		}\r\n		\r\n		switchStatement.testExpression.traverse(this, scope);\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameRPAREN, this.preferences.insert_space_in_switch_condition);\r\n		/*\r\n		 * Type body\r\n		 */\r\n		String switch_brace = this.preferences.switch_brace_position;\r\n		formatOpeningBrace(switch_brace, this.preferences.insert_space_before_switch_open_brace);\r\n		this.scribe.printNewLine();\r\n\r\n		if (preferences.indent_switchstatements_compare_to_switch) {\r\n			this.scribe.indent();\r\n		}\r\n		final Statement[] statements = switchStatement.statements;\r\n		if (statements != null) {\r\n			int statementsLength = statements.length;\r\n			boolean wasABreak = false;\r\n			for (int i = 0; i < statementsLength; i++) {\r\n				final Statement statement = statements[i];\r\n				if (i == 0) {\r\n					// this is a case or a default statement\r\n					statement.traverse(this, scope);\r\n					if (this.preferences.indent_switchstatements_compare_to_cases) {\r\n						this.scribe.indent();\r\n					}\r\n				} else if (statement instanceof CaseStatement) {\r\n					if (wasABreak) {\r\n						if (this.preferences.indent_breaks_compare_to_cases) {\r\n							this.scribe.unIndent();\r\n						}\r\n					} else if (this.preferences.indent_switchstatements_compare_to_cases) {\r\n						this.scribe.unIndent();\r\n					}\r\n					statement.traverse(this, scope);\r\n					wasABreak = false;\r\n					if (this.preferences.indent_switchstatements_compare_to_cases) {\r\n						this.scribe.indent();\r\n					}\r\n				} else if (statement instanceof BreakStatement) {\r\n					wasABreak = true;\r\n					if (this.preferences.indent_switchstatements_compare_to_cases) {\r\n						if (!this.preferences.indent_breaks_compare_to_cases) {\r\n							this.scribe.unIndent();\r\n						}\r\n					} else if (this.preferences.indent_breaks_compare_to_cases) {\r\n						this.scribe.indent();\r\n					}\r\n					statement.traverse(this, scope);\r\n					if (i == statementsLength - 1 && this.preferences.indent_breaks_compare_to_cases) {\r\n						this.scribe.unIndent();\r\n					}\r\n				} else {\r\n					wasABreak = false;\r\n					statement.traverse(this, scope);\r\n					if (i == statementsLength - 1 && this.preferences.indent_switchstatements_compare_to_cases) {\r\n						this.scribe.unIndent();\r\n					}\r\n				}\r\n				if (statement instanceof Expression) {\r\n					/*\r\n					 * Print the semi-colon\r\n					 */	\r\n					this.scribe.printNextToken(ITerminalSymbols.TokenNameSEMICOLON, this.preferences.insert_space_before_semicolon);\r\n					this.scribe.printTrailingComment();\r\n				} else if (statement instanceof LocalDeclaration) {\r\n					LocalDeclaration currentLocal = (LocalDeclaration) statement;\r\n					if (i < (statementsLength - 1)) {\r\n						/* \r\n						 * We need to check that the next statement is a local declaration\r\n						 */\r\n						if (statements[i + 1] instanceof LocalDeclaration) {\r\n							LocalDeclaration nextLocal = (LocalDeclaration) statements[i + 1];\r\n							if (currentLocal.declarationSourceStart != nextLocal.declarationSourceStart) {\r\n								/*\r\n								 * Print the semi-colon\r\n								 */	\r\n								this.scribe.printNextToken(ITerminalSymbols.TokenNameSEMICOLON, this.preferences.insert_space_before_semicolon);\r\n								this.scribe.printTrailingComment();\r\n							}\r\n						} else {\r\n							/*\r\n							 * Print the semi-colon\r\n							 */	\r\n							this.scribe.printNextToken(ITerminalSymbols.TokenNameSEMICOLON, this.preferences.insert_space_before_semicolon);\r\n							this.scribe.printTrailingComment();\r\n						}\r\n					} else {\r\n						/*\r\n						 * Print the semi-colon\r\n						 */	\r\n						this.scribe.printNextToken(ITerminalSymbols.TokenNameSEMICOLON, this.preferences.insert_space_before_semicolon);\r\n						this.scribe.printTrailingComment();\r\n					}\r\n				} else {\r\n					this.scribe.printTrailingComment();\r\n				}\r\n				this.scribe.printNewLine();\r\n			}\r\n		}		\r\n		\r\n		if (preferences.indent_switchstatements_compare_to_switch) {\r\n			this.scribe.unIndent();\r\n		}\r\n		this.scribe.printNewLine();\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameRBRACE);\r\n		this.scribe.printTrailingComment();\r\n		if (switch_brace.equals(FormattingPreferences.NEXT_LINE_SHIFTED)) {\r\n			this.scribe.unIndent();\r\n		}		\r\n		return false;\r\n	}\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.SynchronizedStatement, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(\r\n		SynchronizedStatement synchronizedStatement,\r\n		BlockScope scope) {\r\n		\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNamesynchronized);\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameLPAREN, this.preferences.insert_space_before_synchronized_condition);\r\n		\r\n		if (this.preferences.insert_space_in_synchronized_condition) {\r\n			this.scribe.space();\r\n		}\r\n		synchronizedStatement.expression.traverse(this, scope);\r\n	\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameRPAREN, this.preferences.insert_space_in_synchronized_condition);\r\n		\r\n		synchronizedStatement.block.traverse(this, scope);\r\n		this.scribe.printTrailingComment();\r\n		return false;\r\n	}\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.ThisReference, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(ThisReference thisReference, BlockScope scope) {\r\n		\r\n		if (!thisReference.isImplicitThis()) {\r\n			final int numberOfParens = (thisReference.bits & AstNode.ParenthesizedMASK) >> AstNode.ParenthesizedSHIFT;\r\n			if (numberOfParens > 0) {\r\n				manageOpeningParenthesizedExpression(thisReference, numberOfParens);\r\n			}\r\n			this.scribe.printNextToken(ITerminalSymbols.TokenNamethis);\r\n			\r\n			if (numberOfParens > 0) {\r\n				manageClosingParenthesizedExpression(thisReference, numberOfParens);\r\n			}\r\n		}\r\n		return false;\r\n	}\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.ThrowStatement, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(ThrowStatement throwStatement, BlockScope scope) {\r\n\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNamethrow);\r\n		this.scribe.space();\r\n		throwStatement.exception.traverse(this, scope);\r\n		/*\r\n		 * Print the semi-colon\r\n		 */	\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameSEMICOLON, this.preferences.insert_space_before_semicolon);\r\n		return false;\r\n	}\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.TrueLiteral, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(TrueLiteral trueLiteral, BlockScope scope) {\r\n\r\n		final int numberOfParens = (trueLiteral.bits & AstNode.ParenthesizedMASK) >> AstNode.ParenthesizedSHIFT;\r\n		if (numberOfParens > 0) {\r\n			manageOpeningParenthesizedExpression(trueLiteral, numberOfParens);\r\n		}\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNametrue);\r\n\r\n		if (numberOfParens > 0) {\r\n			manageClosingParenthesizedExpression(trueLiteral, numberOfParens);\r\n		}\r\n		return false;\r\n	}\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.TryStatement, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(TryStatement tryStatement, BlockScope scope) {\r\n\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNametry);\r\n		tryStatement.tryBlock.traverse(this, scope);\r\n		if (this.preferences.insert_new_line_in_control_statements) {\r\n			this.scribe.printTrailingComment();\r\n		}	\r\n		if (tryStatement.catchArguments != null) {\r\n			for (int i = 0, max = tryStatement.catchBlocks.length; i < max; i++) {\r\n				this.scribe.printNextToken(ITerminalSymbols.TokenNamecatch, this.preferences.insert_space_after_block_close_brace);\r\n				this.scribe.printNextToken(ITerminalSymbols.TokenNameLPAREN, this.preferences.insert_space_before_catch_expression);\r\n				\r\n				if (this.preferences.insert_space_in_catch_expression) {\r\n					this.scribe.space();\r\n				}\r\n				\r\n				tryStatement.catchArguments[i].traverse(this, scope);\r\n			\r\n				this.scribe.printNextToken(ITerminalSymbols.TokenNameRPAREN, this.preferences.insert_space_in_catch_expression);\r\n				\r\n				tryStatement.catchBlocks[i].traverse(this, scope);\r\n				if (this.preferences.insert_new_line_in_control_statements) {\r\n					this.scribe.printTrailingComment();\r\n				}	\r\n			}\r\n		}\r\n		if (tryStatement.finallyBlock != null) {\r\n			this.scribe.printNextToken(ITerminalSymbols.TokenNamefinally, this.preferences.insert_space_after_block_close_brace);\r\n			tryStatement.finallyBlock.traverse(this, scope);\r\n			if (this.preferences.insert_new_line_in_control_statements) {\r\n				this.scribe.printTrailingComment();\r\n			}	\r\n		}\r\n		return false;\r\n	}\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.TypeDeclaration, org.eclipse.jdt.internal.compiler.lookup.CompilationUnitScope)\r\n	 */\r\n	public boolean visit(\r\n		TypeDeclaration typeDeclaration,\r\n		CompilationUnitScope scope) {\r\n\r\n		format(typeDeclaration);\r\n		return false;\r\n	}\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.UnaryExpression, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(UnaryExpression unaryExpression, BlockScope scope) {\r\n\r\n		final int numberOfParens = (unaryExpression.bits & AstNode.ParenthesizedMASK) >> AstNode.ParenthesizedSHIFT;\r\n		if (numberOfParens > 0) {\r\n			manageOpeningParenthesizedExpression(unaryExpression, numberOfParens);\r\n		}\r\n\r\n		/*\r\n		 * Print the operator\r\n		 */\r\n		int operator;\r\n		switch((unaryExpression.bits & AstNode.OperatorMASK) >> AstNode.OperatorSHIFT) {\r\n			case OperatorIds.PLUS:\r\n				operator = ITerminalSymbols.TokenNamePLUS;\r\n				break;\r\n			case OperatorIds.MINUS:\r\n				operator = ITerminalSymbols.TokenNameMINUS;\r\n				break;\r\n			case OperatorIds.TWIDDLE:\r\n				operator = ITerminalSymbols.TokenNameTWIDDLE;\r\n				break;\r\n			default:\r\n				operator = ITerminalSymbols.TokenNameNOT;\r\n		}\r\n\r\n		if (operator == ITerminalSymbols.TokenNameMINUS) {\r\n			this.scribe.printNextToken(operator, true);\r\n		} else {\r\n			this.scribe.printNextToken(operator, this.preferences.insert_space_before_unary_operator);\r\n		}\r\n		if (this.preferences.insert_space_after_unary_operator) {\r\n			this.scribe.space();\r\n		}\r\n		unaryExpression.expression.traverse(this, scope);\r\n\r\n		if (numberOfParens > 0) {\r\n			manageClosingParenthesizedExpression(unaryExpression, numberOfParens);\r\n		}\r\n		return false;\r\n	}\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.WhileStatement, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(WhileStatement whileStatement, BlockScope scope) {\r\n\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNamewhile);\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameLPAREN, this.preferences.insert_space_before_while_condition);\r\n		\r\n		if (this.preferences.insert_space_in_while_condition) {\r\n			this.scribe.space();\r\n		}\r\n		whileStatement.condition.traverse(this, scope);\r\n		\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameRPAREN, this.preferences.insert_space_in_while_condition);\r\n		\r\n		final Statement action = whileStatement.action;\r\n		if (action != null) {\r\n			if (action instanceof Block) {\r\n				action.traverse(this, scope);\r\n			} else {\r\n				this.scribe.printNewLine();\r\n				this.scribe.indent();\r\n				action.traverse(this, scope);\r\n				this.scribe.unIndent();\r\n			}\r\n			if (action instanceof Expression) {\r\n				this.scribe.printNextToken(ITerminalSymbols.TokenNameSEMICOLON, this.preferences.insert_space_before_semicolon);\r\n				this.scribe.printTrailingComment();\r\n			} else if (action instanceof Block) {\r\n				this.scribe.printTrailingComment();\r\n			}		\r\n		} else {\r\n			this.scribe.indent();\r\n			/*\r\n			 * This is an empty statement\r\n			 */\r\n			formatEmptyStatement(); \r\n			this.scribe.unIndent();\r\n		}\r\n\r\n		return false;\r\n	}\r\n}','/*******************************************************************************\r\n * Copyright (c) 2002, 2003 International Business Machines Corp. and others.\r\n * All rights reserved. This program and the accompanying materials \r\n * are made available under the terms of the Common Public License v1.0 \r\n * which accompanies this distribution, and is available at\r\n * http://www.eclipse.org/legal/cpl-v10.html\r\n * \r\n * Contributors:\r\n *     IBM Corporation - initial API and implementation\r\n ******************************************************************************/\r\npackage org.eclipse.jdt.internal.formatter;\r\n\r\nimport java.util.Map;\r\n\r\nimport org.eclipse.jdt.core.JavaCore;\r\nimport org.eclipse.jdt.core.ToolFactory;\r\nimport org.eclipse.jdt.core.compiler.IProblem;\r\nimport org.eclipse.jdt.core.compiler.IScanner;\r\nimport org.eclipse.jdt.core.compiler.ITerminalSymbols;\r\nimport org.eclipse.jdt.core.compiler.InvalidInputException;\r\nimport org.eclipse.jdt.internal.compiler.AbstractSyntaxTreeVisitorAdapter;\r\nimport org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor;\r\nimport org.eclipse.jdt.internal.compiler.ast.AND_AND_Expression;\r\nimport org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration;\r\nimport org.eclipse.jdt.internal.compiler.ast.AllocationExpression;\r\nimport org.eclipse.jdt.internal.compiler.ast.AnonymousLocalTypeDeclaration;\r\nimport org.eclipse.jdt.internal.compiler.ast.Argument;\r\nimport org.eclipse.jdt.internal.compiler.ast.ArrayAllocationExpression;\r\nimport org.eclipse.jdt.internal.compiler.ast.ArrayInitializer;\r\nimport org.eclipse.jdt.internal.compiler.ast.ArrayQualifiedTypeReference;\r\nimport org.eclipse.jdt.internal.compiler.ast.ArrayReference;\r\nimport org.eclipse.jdt.internal.compiler.ast.ArrayTypeReference;\r\nimport org.eclipse.jdt.internal.compiler.ast.AssertStatement;\r\nimport org.eclipse.jdt.internal.compiler.ast.Assignment;\r\nimport org.eclipse.jdt.internal.compiler.ast.AstNode;\r\nimport org.eclipse.jdt.internal.compiler.ast.BinaryExpression;\r\nimport org.eclipse.jdt.internal.compiler.ast.Block;\r\nimport org.eclipse.jdt.internal.compiler.ast.BreakStatement;\r\nimport org.eclipse.jdt.internal.compiler.ast.CaseStatement;\r\nimport org.eclipse.jdt.internal.compiler.ast.CastExpression;\r\nimport org.eclipse.jdt.internal.compiler.ast.CharLiteral;\r\nimport org.eclipse.jdt.internal.compiler.ast.ClassLiteralAccess;\r\nimport org.eclipse.jdt.internal.compiler.ast.Clinit;\r\nimport org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration;\r\nimport org.eclipse.jdt.internal.compiler.ast.CompoundAssignment;\r\nimport org.eclipse.jdt.internal.compiler.ast.ConditionalExpression;\r\nimport org.eclipse.jdt.internal.compiler.ast.ConstructorDeclaration;\r\nimport org.eclipse.jdt.internal.compiler.ast.ContinueStatement;\r\nimport org.eclipse.jdt.internal.compiler.ast.DoStatement;\r\nimport org.eclipse.jdt.internal.compiler.ast.DoubleLiteral;\r\nimport org.eclipse.jdt.internal.compiler.ast.EmptyStatement;\r\nimport org.eclipse.jdt.internal.compiler.ast.EqualExpression;\r\nimport org.eclipse.jdt.internal.compiler.ast.ExplicitConstructorCall;\r\nimport org.eclipse.jdt.internal.compiler.ast.Expression;\r\nimport org.eclipse.jdt.internal.compiler.ast.FalseLiteral;\r\nimport org.eclipse.jdt.internal.compiler.ast.FieldDeclaration;\r\nimport org.eclipse.jdt.internal.compiler.ast.FieldReference;\r\nimport org.eclipse.jdt.internal.compiler.ast.FloatLiteral;\r\nimport org.eclipse.jdt.internal.compiler.ast.ForStatement;\r\nimport org.eclipse.jdt.internal.compiler.ast.IfStatement;\r\nimport org.eclipse.jdt.internal.compiler.ast.ImportReference;\r\nimport org.eclipse.jdt.internal.compiler.ast.Initializer;\r\nimport org.eclipse.jdt.internal.compiler.ast.InstanceOfExpression;\r\nimport org.eclipse.jdt.internal.compiler.ast.IntLiteral;\r\nimport org.eclipse.jdt.internal.compiler.ast.LabeledStatement;\r\nimport org.eclipse.jdt.internal.compiler.ast.LocalDeclaration;\r\nimport org.eclipse.jdt.internal.compiler.ast.LocalTypeDeclaration;\r\nimport org.eclipse.jdt.internal.compiler.ast.LongLiteral;\r\nimport org.eclipse.jdt.internal.compiler.ast.MemberTypeDeclaration;\r\nimport org.eclipse.jdt.internal.compiler.ast.MessageSend;\r\nimport org.eclipse.jdt.internal.compiler.ast.MethodDeclaration;\r\nimport org.eclipse.jdt.internal.compiler.ast.NullLiteral;\r\nimport org.eclipse.jdt.internal.compiler.ast.OR_OR_Expression;\r\nimport org.eclipse.jdt.internal.compiler.ast.OperatorIds;\r\nimport org.eclipse.jdt.internal.compiler.ast.PostfixExpression;\r\nimport org.eclipse.jdt.internal.compiler.ast.PrefixExpression;\r\nimport org.eclipse.jdt.internal.compiler.ast.QualifiedAllocationExpression;\r\nimport org.eclipse.jdt.internal.compiler.ast.QualifiedNameReference;\r\nimport org.eclipse.jdt.internal.compiler.ast.QualifiedSuperReference;\r\nimport org.eclipse.jdt.internal.compiler.ast.QualifiedThisReference;\r\nimport org.eclipse.jdt.internal.compiler.ast.QualifiedTypeReference;\r\nimport org.eclipse.jdt.internal.compiler.ast.ReturnStatement;\r\nimport org.eclipse.jdt.internal.compiler.ast.SingleNameReference;\r\nimport org.eclipse.jdt.internal.compiler.ast.SingleTypeReference;\r\nimport org.eclipse.jdt.internal.compiler.ast.Statement;\r\nimport org.eclipse.jdt.internal.compiler.ast.StringLiteral;\r\nimport org.eclipse.jdt.internal.compiler.ast.SuperReference;\r\nimport org.eclipse.jdt.internal.compiler.ast.SwitchStatement;\r\nimport org.eclipse.jdt.internal.compiler.ast.SynchronizedStatement;\r\nimport org.eclipse.jdt.internal.compiler.ast.ThisReference;\r\nimport org.eclipse.jdt.internal.compiler.ast.ThrowStatement;\r\nimport org.eclipse.jdt.internal.compiler.ast.TrueLiteral;\r\nimport org.eclipse.jdt.internal.compiler.ast.TryStatement;\r\nimport org.eclipse.jdt.internal.compiler.ast.TypeDeclaration;\r\nimport org.eclipse.jdt.internal.compiler.ast.TypeReference;\r\nimport org.eclipse.jdt.internal.compiler.ast.UnaryExpression;\r\nimport org.eclipse.jdt.internal.compiler.ast.WhileStatement;\r\nimport org.eclipse.jdt.internal.compiler.impl.Constant;\r\nimport org.eclipse.jdt.internal.compiler.lookup.BlockScope;\r\nimport org.eclipse.jdt.internal.compiler.lookup.ClassScope;\r\nimport org.eclipse.jdt.internal.compiler.lookup.CompilationUnitScope;\r\nimport org.eclipse.jdt.internal.compiler.lookup.CompilerModifiers;\r\nimport org.eclipse.jdt.internal.compiler.lookup.MethodScope;\r\nimport org.eclipse.jdt.internal.formatter.align.Alignment;\r\nimport org.eclipse.jdt.internal.formatter.align.AlignmentException;\r\n\r\n/**\r\n * This class is responsible for formatting a valid java source code.\r\n * @since 2.1\r\n */\r\n// TODO add line splitting for all remaining expression and statements\r\n// TODO find a way to handle complex boolean expression\r\n// TODO Add the ICodeFormatter extension point once the UI has fixed their code\r\n/*\r\n   <extension\r\n         id=\"org.eclipse.jdt.core.newformatter.codeformatter\"\r\n         name=\"org.eclipse.jdt.core.newformatter.codeformatter\"\r\n         point=\"org.eclipse.jdt.core.codeFormatter\">\r\n      <codeFormatter\r\n            class=\"org.eclipse.jdt.internal.formatter.CodeFormatterVisitor\">\r\n      </codeFormatter>\r\n   </extension>\r\n*/\r\npublic class CodeFormatterVisitor extends AbstractSyntaxTreeVisitorAdapter {\r\n\r\n	public static class MultiFieldDeclaration extends FieldDeclaration {\r\n		\r\n		FieldDeclaration[] declarations;\r\n		\r\n		MultiFieldDeclaration(FieldDeclaration[] declarations){\r\n			this.declarations = declarations;\r\n			this.modifiers = declarations[0].modifiers; \r\n		}\r\n	}\r\n	\r\n	public static boolean DEBUG = false;\r\n	private static final int NO_MODIFIERS = 0;\r\n	/*\r\n	 * Set of expected tokens type for a single type reference.\r\n	 * This array needs to be SORTED.\r\n	 */\r\n	private static final int[] SINGLETYPEREFERENCE_EXPECTEDTOKENS = new int[] {\r\n		ITerminalSymbols.TokenNameIdentifier,\r\n		ITerminalSymbols.TokenNameboolean,\r\n		ITerminalSymbols.TokenNamebyte,\r\n		ITerminalSymbols.TokenNamechar,\r\n		ITerminalSymbols.TokenNamedouble,\r\n		ITerminalSymbols.TokenNamefloat,\r\n		ITerminalSymbols.TokenNameint,\r\n		ITerminalSymbols.TokenNamelong,\r\n		ITerminalSymbols.TokenNameshort,\r\n		ITerminalSymbols.TokenNamevoid\r\n	};\r\n	private int chunkKind;\r\n	public int lastLocalDeclarationSourceStart;\r\n	private IScanner localScanner;\r\n	public FormattingPreferences preferences;\r\n	public Scribe scribe;\r\n	\r\n	/*\r\n	 * TODO: See how to choose the formatter\'s options. The extension point is calling\r\n	 * this constructor, but then there is no way to initialize the option used by the formatter.\r\n	 */ \r\n	public CodeFormatterVisitor() {\r\n		this(FormattingPreferences.getSunSetttings(), JavaCore.getOptions());\r\n	}\r\n\r\n	public CodeFormatterVisitor(FormattingPreferences preferences, Map settings) {\r\n		if (settings != null) {\r\n			String compiler_source = (String) settings.get(JavaCore.COMPILER_SOURCE);\r\n			if (compiler_source == null) {\r\n				this.localScanner = ToolFactory.createScanner(false, false, false, false);\r\n			} else {\r\n				this.localScanner = ToolFactory.createScanner(false, false, false, compiler_source);\r\n			}\r\n		} else {\r\n			this.localScanner = ToolFactory.createScanner(false, false, false, false);\r\n		}\r\n		// TODO set the java core options when common preferences are changed\r\n//		convertOldOptionsToPreferences(settings, preferences);\r\n		this.preferences = preferences;\r\n		this.scribe = new Scribe(this, settings);\r\n	}\r\n	\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#acceptProblem(org.eclipse.jdt.core.compiler.IProblem)\r\n	 */\r\n	public void acceptProblem(IProblem problem) {\r\n		super.acceptProblem(problem);\r\n	}\r\n\r\n	private BinaryExpressionFragmentBuilder buildFragments(BinaryExpression binaryExpression, BlockScope scope) {\r\n		BinaryExpressionFragmentBuilder builder = new BinaryExpressionFragmentBuilder();\r\n		\r\n		switch((binaryExpression.bits & AstNode.OperatorMASK) >> AstNode.OperatorSHIFT) {\r\n			case OperatorIds.AND_AND :\r\n				binaryExpression.left.traverse(builder, scope);\r\n				builder.operatorsList.add(new Integer(ITerminalSymbols.TokenNameAND_AND));\r\n				binaryExpression.right.traverse(builder, scope);\r\n				break;\r\n			case OperatorIds.OR_OR :\r\n				binaryExpression.left.traverse(builder, scope);\r\n				builder.operatorsList.add(new Integer(ITerminalSymbols.TokenNameOR_OR));\r\n				binaryExpression.right.traverse(builder, scope);\r\n				break;\r\n		}\r\n\r\n		return builder;\r\n	}\r\n\r\n	public boolean checkChunkStart(int kind) {\r\n		if (this.chunkKind != kind) {\r\n			this.chunkKind = kind;\r\n			return true;\r\n		}\r\n		return false;\r\n	}\r\n	\r\n	private AstNode[] computeMergedMemberDeclarations(TypeDeclaration typeDeclaration){\r\n		\r\n		int fieldIndex = 0, fieldCount = (typeDeclaration.fields == null) ? 0 : typeDeclaration.fields.length;\r\n		FieldDeclaration field = fieldCount == 0 ? null : typeDeclaration.fields[fieldIndex];\r\n		int fieldStart = field == null ? Integer.MAX_VALUE : field.declarationSourceStart;\r\n\r\n		int methodIndex = 0, methodCount = (typeDeclaration.methods == null) ? 0 : typeDeclaration.methods.length;\r\n		AbstractMethodDeclaration method = methodCount == 0 ? null : typeDeclaration.methods[methodIndex];\r\n		int methodStart = method == null ? Integer.MAX_VALUE : method.declarationSourceStart;\r\n\r\n		int typeIndex = 0, typeCount = (typeDeclaration.memberTypes == null) ? 0 : typeDeclaration.memberTypes.length;\r\n		MemberTypeDeclaration type = typeCount == 0 ? null : typeDeclaration.memberTypes[typeIndex];\r\n		int typeStart = type == null ? Integer.MAX_VALUE : type.declarationSourceStart;\r\n	\r\n		final int memberLength = fieldCount+methodCount+typeCount;\r\n		AstNode[] members = new AstNode[memberLength];\r\n		if (memberLength != 0) {\r\n			int index = 0;\r\n			int previousFieldStart = -1;\r\n			do {\r\n				if (fieldStart < methodStart && fieldStart < typeStart) {\r\n					// next member is a field\r\n					if (fieldStart == previousFieldStart){ \r\n						AstNode previousMember = members[index - 1];\r\n						if (previousMember instanceof MultiFieldDeclaration) {\r\n							MultiFieldDeclaration multiField = (MultiFieldDeclaration) previousMember;\r\n							int length = multiField.declarations.length;\r\n							System.arraycopy(multiField.declarations, 0, multiField.declarations=new FieldDeclaration[length+1], 0, length);\r\n							multiField.declarations[length] = (FieldDeclaration) field;\r\n						} else {\r\n							members[index - 1] = new MultiFieldDeclaration(new FieldDeclaration[]{ (FieldDeclaration)previousMember, field});\r\n						}\r\n					} else {\r\n						members[index++] = field;					\r\n					}\r\n					previousFieldStart = fieldStart;\r\n					if (++fieldIndex < fieldCount) { // find next field if any\r\n						fieldStart = (field = typeDeclaration.fields[fieldIndex]).declarationSourceStart;\r\n					} else {\r\n						fieldStart = Integer.MAX_VALUE;\r\n					}\r\n				} else if (methodStart < fieldStart && methodStart < typeStart) {\r\n					// next member is a method\r\n					if (!method.isDefaultConstructor() && !method.isClinit()) {\r\n						members[index++] = method;					\r\n					}\r\n					if (++methodIndex < methodCount) { // find next method if any\r\n						methodStart = (method = typeDeclaration.methods[methodIndex]).declarationSourceStart;\r\n					} else {\r\n						methodStart = Integer.MAX_VALUE;\r\n					}\r\n				} else {\r\n					// next member is a type\r\n					members[index++] = type;\r\n					if (++typeIndex < typeCount) { // find next type if any\r\n						typeStart = (type = typeDeclaration.memberTypes[typeIndex]).declarationSourceStart;\r\n					} else {\r\n						typeStart = Integer.MAX_VALUE;\r\n					}\r\n				}\r\n			} while ((fieldIndex < fieldCount) || (typeIndex < typeCount) || (methodIndex < methodCount));\r\n			\r\n			if (members.length != index) {\r\n				System.arraycopy(members, 0, members=new AstNode[index], 0, index);\r\n			}\r\n		}\r\n		return members;\r\n	}\r\n\r\n	void convertOldOptionsToPreferences(Map oldOptions, FormattingPreferences formattingPreferences) {\r\n		if (oldOptions == null) {\r\n			return;\r\n		}\r\n		Object[] entries = oldOptions.entrySet().toArray();\r\n		\r\n		for (int i = 0, max = entries.length; i < max; i++){\r\n			Map.Entry entry = (Map.Entry)entries[i];\r\n			if (!(entry.getKey() instanceof String)) continue;\r\n			if (!(entry.getValue() instanceof String)) continue;\r\n			String optionID = (String) entry.getKey();\r\n			String optionValue = (String) entry.getValue();\r\n			\r\n			if(optionID.equals(JavaCore.FORMATTER_NEWLINE_OPENING_BRACE)){\r\n				if (optionValue.equals(JavaCore.INSERT)){\r\n					formattingPreferences.anonymous_type_declaration_brace_position = FormattingPreferences.NEXT_LINE;\r\n					formattingPreferences.type_declaration_brace_position = FormattingPreferences.NEXT_LINE;\r\n					formattingPreferences.method_declaration_brace_position = FormattingPreferences.NEXT_LINE;\r\n					formattingPreferences.block_brace_position = FormattingPreferences.NEXT_LINE;\r\n					formattingPreferences.switch_brace_position = FormattingPreferences.NEXT_LINE;\r\n				} else if (optionValue.equals(JavaCore.DO_NOT_INSERT)){\r\n					formattingPreferences.anonymous_type_declaration_brace_position = FormattingPreferences.END_OF_LINE;\r\n					formattingPreferences.type_declaration_brace_position = FormattingPreferences.END_OF_LINE;\r\n					formattingPreferences.method_declaration_brace_position = FormattingPreferences.END_OF_LINE;\r\n					formattingPreferences.block_brace_position = FormattingPreferences.END_OF_LINE;\r\n					formattingPreferences.switch_brace_position = FormattingPreferences.END_OF_LINE;\r\n				}\r\n				continue;\r\n			}\r\n			if(optionID.equals(JavaCore.FORMATTER_NEWLINE_CONTROL)) {\r\n				if (optionValue.equals(JavaCore.INSERT)){\r\n					formattingPreferences.insert_new_line_in_control_statements = true;\r\n				} else if (optionValue.equals(JavaCore.DO_NOT_INSERT)){\r\n					formattingPreferences.insert_new_line_in_control_statements = false;\r\n				}\r\n				continue;\r\n			}\r\n			if(optionID.equals(JavaCore.FORMATTER_CLEAR_BLANK_LINES)) {\r\n				if (optionValue.equals(JavaCore.CLEAR_ALL)){\r\n					formattingPreferences.number_of_empty_lines_to_preserve = 0;\r\n				} else if (optionValue.equals(JavaCore.PRESERVE_ONE)){\r\n					formattingPreferences.number_of_empty_lines_to_preserve = 1;\r\n				}\r\n				continue;\r\n			}\r\n			if(optionID.equals(JavaCore.FORMATTER_NEWLINE_ELSE_IF)){\r\n				if (optionValue.equals(JavaCore.INSERT)){\r\n					formattingPreferences.compact_else_if = false;\r\n				} else if (optionValue.equals(JavaCore.DO_NOT_INSERT)){\r\n					formattingPreferences.compact_else_if = true;\r\n				}\r\n				continue;\r\n			}\r\n			if(optionID.equals(JavaCore.FORMATTER_NEWLINE_EMPTY_BLOCK)){\r\n				if (optionValue.equals(JavaCore.INSERT)){\r\n					formattingPreferences.insert_new_line_in_empty_anonymous_type_declaration = true;\r\n					formattingPreferences.insert_new_line_in_empty_type_declaration = true;\r\n					formattingPreferences.insert_new_line_in_empty_method_body = true;\r\n					formattingPreferences.insert_new_line_in_empty_block = true;\r\n				} else if (optionValue.equals(JavaCore.DO_NOT_INSERT)){\r\n					formattingPreferences.insert_new_line_in_empty_anonymous_type_declaration = false;\r\n					formattingPreferences.insert_new_line_in_empty_type_declaration = false;\r\n					formattingPreferences.insert_new_line_in_empty_method_body = false;\r\n					formattingPreferences.insert_new_line_in_empty_block = false;\r\n				}\r\n				continue;\r\n			}\r\n			if(optionID.equals(JavaCore.FORMATTER_LINE_SPLIT)){\r\n				try {\r\n					int val = Integer.parseInt(optionValue);\r\n					if (val >= 0) {\r\n						formattingPreferences.page_width = val;\r\n					}\r\n				} catch(NumberFormatException e){\r\n				}\r\n			}\r\n			if(optionID.equals(JavaCore.FORMATTER_COMPACT_ASSIGNMENT)){\r\n				if (optionValue.equals(JavaCore.COMPACT)){\r\n					formattingPreferences.insert_space_before_assignment_operators = false;\r\n				} else if (optionValue.equals(JavaCore.NORMAL)){\r\n					formattingPreferences.insert_space_before_assignment_operators = true;\r\n				}\r\n				continue;\r\n			}\r\n			if(optionID.equals(JavaCore.FORMATTER_TAB_CHAR)){\r\n				if (optionValue.equals(JavaCore.TAB)){\r\n					formattingPreferences.use_tab = true;\r\n				} else if (optionValue.equals(JavaCore.SPACE)){\r\n					formattingPreferences.use_tab = false;\r\n				}\r\n				continue;\r\n			}\r\n			if(optionID.equals(JavaCore.FORMATTER_TAB_SIZE)){\r\n				try {\r\n					int val = Integer.parseInt(optionValue);\r\n					if (val > 0) {\r\n						formattingPreferences.tab_size = val;\r\n					}\r\n				} catch(NumberFormatException e){\r\n				}\r\n			}\r\n			if(optionID.equals(JavaCore.FORMATTER_SPACE_CASTEXPRESSION)){\r\n				if (optionValue.equals(JavaCore.INSERT)){\r\n					formattingPreferences.insert_space_after_closing_paren_in_cast = true;\r\n				} else if (optionValue.equals(JavaCore.DO_NOT_INSERT)){\r\n					formattingPreferences.insert_space_after_closing_paren_in_cast = false;\r\n				}\r\n				continue;\r\n			}		\r\n		}		\r\n	}\r\n\r\n	private boolean dumpBinaryExpression(\r\n		BinaryExpression binaryExpression,\r\n		int operator,\r\n		BlockScope scope) {\r\n\r\n		final int numberOfParens = (binaryExpression.bits & AstNode.ParenthesizedMASK) >> AstNode.ParenthesizedSHIFT;\r\n\r\n		if (numberOfParens > 0) {\r\n			manageOpeningParenthesizedExpression(binaryExpression, numberOfParens);\r\n		}	\r\n		BinaryExpressionFragmentBuilder builder = buildFragments(binaryExpression, scope);\r\n		final int fragmentsSize = builder.size();\r\n		\r\n		if (fragmentsSize > 1) {\r\n			Alignment binaryExpressionAlignment = this.scribe.createAlignment(\"binaryExpressionAlignment\", this.preferences.binary_expression_alignment, fragmentsSize, this.scribe.scanner.currentPosition); //$NON-NLS-1$\r\n			this.scribe.enterAlignment(binaryExpressionAlignment);\r\n			boolean ok = false;\r\n			AstNode[] fragments = builder.fragments();\r\n			int[] operators = builder.operators();\r\n			do {\r\n				try {\r\n					for (int i = 0; i < fragmentsSize - 1; i++) {\r\n						AstNode fragment = fragments[i];\r\n						fragment.traverse(this, scope);\r\n						this.scribe.alignFragment(binaryExpressionAlignment, i);\r\n						this.scribe.printNextToken(operators[i], this.preferences.insert_space_before_binary_operator);\r\n						if (this.preferences.insert_space_after_binary_operator) {\r\n							this.scribe.space();\r\n						}						\r\n					}\r\n					fragments[fragmentsSize - 1].traverse(this, scope);\r\n					ok = true;\r\n				} catch(AlignmentException e){\r\n					this.scribe.redoAlignment(e);\r\n				}\r\n			} while (!ok);		\r\n			this.scribe.exitAlignment(binaryExpressionAlignment, true);\r\n		} else {\r\n			binaryExpression.left.traverse(this, scope);\r\n			this.scribe.printNextToken(operator, this.preferences.insert_space_before_binary_operator);\r\n			if (this.preferences.insert_space_after_binary_operator) {\r\n				this.scribe.space();\r\n			}\r\n			binaryExpression.right.traverse(this, scope);\r\n		}	\r\n		if (numberOfParens > 0) {\r\n			manageClosingParenthesizedExpression(binaryExpression, numberOfParens);\r\n		}\r\n		return false;\r\n	}\r\n\r\n	private String failedToFormat(final char[] compilationUnitSource) {\r\n		StringBuffer buffer = new StringBuffer(this.scribe.formattedSource());\r\n		buffer.append(compilationUnitSource, this.scribe.scanner.getCurrentTokenEndPosition(), this.scribe.scannerEndPosition - this.scribe.scanner.getCurrentTokenEndPosition());\r\n		System.out.println(\"COULD NOT FORMAT \\n\" + this.scribe.scanner); //$NON-NLS-1$\r\n		if (DEBUG) {\r\n			System.out.println(this.scribe);\r\n		}\r\n		return buffer.toString();\r\n	}\r\n\r\n	private void format(\r\n		AbstractMethodDeclaration methodDeclaration,\r\n		ClassScope scope,\r\n		boolean isChunkStart) {\r\n\r\n		final int newLineBeforeChunk = isChunkStart ? this.preferences.blank_lines_before_new_chunk : 0;\r\n		if (newLineBeforeChunk > 0) {\r\n			this.scribe.printNewLines(newLineBeforeChunk);\r\n		}\r\n		final int newLinesBeforeMethod = this.preferences.blank_lines_before_method;\r\n		if (newLinesBeforeMethod > 0) {\r\n			this.scribe.printNewLines(newLinesBeforeMethod);\r\n		}\r\n		methodDeclaration.traverse(this, scope);\r\n	}\r\n	\r\n	private void format(FieldDeclaration fieldDeclaration, IAbstractSyntaxTreeVisitor visitor, MethodScope scope, boolean isChunkStart) {\r\n		\r\n		int newLineBeforeChunk = isChunkStart ? this.preferences.blank_lines_before_new_chunk : 0;\r\n		if (newLineBeforeChunk > 0) {\r\n			this.scribe.printNewLines(newLineBeforeChunk);\r\n		}\r\n		final int newLinesBeforeField = this.preferences.blank_lines_before_field;\r\n		if (newLinesBeforeField > 0) {\r\n			this.scribe.printNewLines(newLinesBeforeField);\r\n		}\r\n		Alignment fieldAlignment = this.scribe.getAlignment(\"typeMembers\");	//$NON-NLS-1$\r\n\r\n		if (fieldDeclaration.modifiers != NO_MODIFIERS) {\r\n			this.scribe.printModifiers();\r\n		}\r\n		/*\r\n		 * Field type\r\n		 */\r\n		this.scribe.alignFragment(fieldAlignment, 0);\r\n\r\n		fieldDeclaration.type.traverse(this, scope);\r\n		\r\n		/*\r\n		 * Field name\r\n		 */\r\n		this.scribe.alignFragment(fieldAlignment, 1);\r\n\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameIdentifier, true);\r\n\r\n		/*\r\n		 * Check for extra dimensions\r\n		 */\r\n		int extraDimensions = getExtraDimension();\r\n		if (extraDimensions != 0) {\r\n			 for (int i = 0; i < extraDimensions; i++) {\r\n			 	this.scribe.printNextToken(ITerminalSymbols.TokenNameLBRACKET);\r\n			 	this.scribe.printNextToken(ITerminalSymbols.TokenNameRBRACKET);\r\n			 }\r\n		}\r\n	\r\n		/*\r\n		 * Field initialization\r\n		 */\r\n		if (fieldDeclaration.initialization != null) {\r\n			this.scribe.alignFragment(fieldAlignment, 2);\r\n			this.scribe.printNextToken(ITerminalSymbols.TokenNameEQUAL, this.preferences.insert_space_before_assignment_operators);\r\n			if (this.preferences.insert_space_after_assignment_operators) {\r\n				this.scribe.space();\r\n			}\r\n			fieldDeclaration.initialization.traverse(this, scope);\r\n		}\r\n		\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameSEMICOLON, this.preferences.insert_space_before_semicolon);\r\n\r\n		if (fieldDeclaration.initialization == null) {\r\n			this.scribe.alignFragment(fieldAlignment, 2);\r\n		}\r\n\r\n		if (fieldAlignment != null) {\r\n			this.scribe.alignFragment(fieldAlignment, 3);\r\n			this.scribe.printTrailingComment();\r\n			this.scribe.printNewLine();\r\n			this.scribe.exitAlignment(fieldAlignment, false);\r\n		} else {\r\n			this.scribe.space();\r\n			this.scribe.printTrailingComment();\r\n			this.scribe.printNewLine();\r\n		}\r\n	}\r\n\r\n	private void format(\r\n		MemberTypeDeclaration memberTypeDeclaration,\r\n		ClassScope scope,\r\n		boolean isChunkStart) {\r\n\r\n		int newLineBeforeChunk = isChunkStart ? this.preferences.blank_lines_before_new_chunk : 0;\r\n		if (newLineBeforeChunk > 0) {\r\n			this.scribe.printNewLines(newLineBeforeChunk);\r\n		}\r\n		final int newLinesBeforeMember = this.preferences.blank_lines_before_member_type;\r\n		if (newLinesBeforeMember > 0) {\r\n			this.scribe.printNewLines(newLinesBeforeMember);\r\n		}\r\n		memberTypeDeclaration.traverse(this, scope);\r\n	}\r\n	\r\n	private void format(MultiFieldDeclaration multiFieldDeclaration, IAbstractSyntaxTreeVisitor visitor, MethodScope scope, boolean isChunkStart) {\r\n\r\n		int newLineBeforeChunk = isChunkStart ? this.preferences.blank_lines_before_new_chunk : 0;\r\n		if (newLineBeforeChunk > 0) {\r\n			this.scribe.printNewLines(newLineBeforeChunk);\r\n		}\r\n		final int newLinesBeforeField = this.preferences.blank_lines_before_field;\r\n		if (newLinesBeforeField > 0) {\r\n			this.scribe.printNewLines(newLinesBeforeField);\r\n		}\r\n		Alignment fieldAlignment = this.scribe.getAlignment(\"typeMembers\");	//$NON-NLS-1$\r\n\r\n		if (multiFieldDeclaration.declarations[0].modifiers != NO_MODIFIERS) {\r\n			this.scribe.printModifiers();\r\n		}\r\n		this.scribe.alignFragment(fieldAlignment, 0);\r\n\r\n		multiFieldDeclaration.declarations[0].type.traverse(this, scope);\r\n\r\n		for (int i = 0, length = multiFieldDeclaration.declarations.length; i < length; i++) {\r\n			FieldDeclaration fieldDeclaration = multiFieldDeclaration.declarations[i];\r\n			/*\r\n			 * Field name\r\n			 */\r\n			if (i == 0) {\r\n				this.scribe.alignFragment(fieldAlignment, 1);\r\n			}\r\n			this.scribe.printNextToken(ITerminalSymbols.TokenNameIdentifier, true);\r\n	\r\n			/*\r\n			 * Check for extra dimensions\r\n			 */\r\n			int extraDimensions = getExtraDimension();\r\n			if (extraDimensions != 0) {\r\n				 for (int index = 0; index < extraDimensions; index++) {\r\n				 	this.scribe.printNextToken(ITerminalSymbols.TokenNameLBRACKET);\r\n				 	this.scribe.printNextToken(ITerminalSymbols.TokenNameRBRACKET);\r\n				 }\r\n			}\r\n		\r\n			/*\r\n			 * Field initialization\r\n			 */\r\n			if (fieldDeclaration.initialization != null) {\r\n				if (i == 0) {\r\n					this.scribe.alignFragment(fieldAlignment, 2);\r\n				}\r\n				this.scribe.printNextToken(ITerminalSymbols.TokenNameEQUAL, this.preferences.insert_space_before_assignment_operators);\r\n				if (this.preferences.insert_space_after_assignment_operators) {\r\n					this.scribe.space();\r\n				}\r\n				fieldDeclaration.initialization.traverse(this, scope);\r\n			}\r\n			\r\n			if (i != length - 1) {\r\n				if (i == 0 && fieldDeclaration.initialization == null) {\r\n					this.scribe.alignFragment(fieldAlignment, 2);\r\n				}				\r\n				this.scribe.printNextToken(ITerminalSymbols.TokenNameCOMMA, this.preferences.insert_space_before_comma_in_multiple_field_declarations);\r\n				if (this.preferences.insert_space_after_comma_in_multiple_field_declarations) {\r\n					this.scribe.space();\r\n				}\r\n			} else {\r\n				this.scribe.printNextToken(ITerminalSymbols.TokenNameSEMICOLON, this.preferences.insert_space_before_semicolon);\r\n				\r\n				this.scribe.alignFragment(fieldAlignment, 3);\r\n				this.scribe.printTrailingComment();\r\n				this.scribe.printNewLine();\r\n			}\r\n		}\r\n		if (fieldAlignment != null) {\r\n			this.scribe.exitAlignment(fieldAlignment, false);\r\n		}\r\n	}\r\n	\r\n	/**\r\n	 * @see org.eclipse.jdt.core.ICodeFormatter#format(java.lang.String, int, int, java.lang.String)\r\n	 */\r\n	public String format(String string, int[] positions, AstNode[] nodes) {\r\n		// reset the scribe\r\n		this.scribe.reset(positions);\r\n		\r\n		long startTime = System.currentTimeMillis();\r\n\r\n		final char[] compilationUnitSource = string.toCharArray();\r\n		\r\n		this.scribe.scanner.setSource(compilationUnitSource);\r\n		this.localScanner.setSource(compilationUnitSource);\r\n		this.scribe.scannerEndPosition = compilationUnitSource.length;\r\n		this.scribe.scanner.resetTo(0, this.scribe.scannerEndPosition);\r\n		if (nodes == null) {\r\n			return string;\r\n		}\r\n\r\n		this.lastLocalDeclarationSourceStart = 0;\r\n		try {\r\n			if (nodes != null) {\r\n				formatClassBodyDeclarations(nodes);\r\n			}\r\n		} catch(AbortFormatting e){\r\n			return failedToFormat(compilationUnitSource);\r\n		}\r\n		if (DEBUG){\r\n			System.out.println(\"Formatting time: \" + (System.currentTimeMillis() - startTime));  //$NON-NLS-1$\r\n		}\r\n		return this.scribe.toString();\r\n	}\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.core.ICodeFormatter#format(java.lang.String, int, int, java.lang.String)\r\n	 */\r\n	public String format(String string, int[] positions, CompilationUnitDeclaration compilationUnitDeclaration) {\r\n		// reset the scribe\r\n		this.scribe.reset(positions);\r\n		\r\n		long startTime = System.currentTimeMillis();\r\n\r\n		final char[] compilationUnitSource = string.toCharArray();\r\n		\r\n		this.scribe.scanner.setSource(compilationUnitSource);\r\n		this.localScanner.setSource(compilationUnitSource);\r\n		this.scribe.scannerEndPosition = compilationUnitSource.length;\r\n		this.scribe.scanner.resetTo(0, this.scribe.scannerEndPosition);\r\n		if (compilationUnitDeclaration == null || compilationUnitDeclaration.ignoreFurtherInvestigation) {\r\n			return string;\r\n		}\r\n\r\n		this.lastLocalDeclarationSourceStart = 0;\r\n		try {\r\n			compilationUnitDeclaration.traverse(this, compilationUnitDeclaration.scope);\r\n		} catch(AbortFormatting e){\r\n			return failedToFormat(compilationUnitSource);\r\n		}\r\n		if (DEBUG){\r\n			System.out.println(\"Formatting time: \" + (System.currentTimeMillis() - startTime));  //$NON-NLS-1$\r\n		}\r\n		return this.scribe.toString();\r\n	}\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.core.ICodeFormatter#format(java.lang.String, int, int, java.lang.String)\r\n	 */\r\n	public String format(String string, int[] positions, ConstructorDeclaration constructorDeclaration) {\r\n		// reset the scribe\r\n		this.scribe.reset(positions);\r\n		\r\n		long startTime = System.currentTimeMillis();\r\n\r\n		final char[] compilationUnitSource = string.toCharArray();\r\n		\r\n		this.scribe.scanner.setSource(compilationUnitSource);\r\n		this.localScanner.setSource(compilationUnitSource);\r\n		this.scribe.scannerEndPosition = compilationUnitSource.length;\r\n		this.scribe.scanner.resetTo(0, this.scribe.scannerEndPosition);\r\n		if (constructorDeclaration == null) {\r\n			return string;\r\n		}\r\n\r\n		this.lastLocalDeclarationSourceStart = 0;\r\n		try {\r\n			ExplicitConstructorCall explicitConstructorCall = constructorDeclaration.constructorCall;\r\n			if (explicitConstructorCall != SuperReference.implicitSuperConstructorCall()) {\r\n				explicitConstructorCall.traverse(this, null);\r\n			}\r\n			Statement[] statements = constructorDeclaration.statements;\r\n			if (statements != null) {\r\n				formatStatements(null, statements);\r\n			}\r\n			this.scribe.printComment();\r\n		} catch(AbortFormatting e){\r\n			return failedToFormat(compilationUnitSource);\r\n		}\r\n		if (DEBUG){\r\n			System.out.println(\"Formatting time: \" + (System.currentTimeMillis() - startTime));  //$NON-NLS-1$\r\n		}\r\n		return this.scribe.toString();\r\n	}\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.core.ICodeFormatter#format(java.lang.String, int, int, java.lang.String)\r\n	 */\r\n	public String format(String string, int[] positions, Expression expression) {\r\n		// reset the scribe\r\n		this.scribe.reset(positions);\r\n		\r\n		long startTime = System.currentTimeMillis();\r\n\r\n		final char[] compilationUnitSource = string.toCharArray();\r\n		\r\n		this.scribe.scanner.setSource(compilationUnitSource);\r\n		this.localScanner.setSource(compilationUnitSource);\r\n		this.scribe.scannerEndPosition = compilationUnitSource.length;\r\n		this.scribe.scanner.resetTo(0, this.scribe.scannerEndPosition);\r\n		if (expression == null) {\r\n			return string;\r\n		}\r\n\r\n		this.lastLocalDeclarationSourceStart = 0;\r\n		try {\r\n			expression.traverse(this, null);\r\n			this.scribe.printComment();\r\n		} catch(AbortFormatting e){\r\n			return failedToFormat(compilationUnitSource);\r\n		}\r\n		if (DEBUG){\r\n			System.out.println(\"Formatting time: \" + (System.currentTimeMillis() - startTime));  //$NON-NLS-1$\r\n		}\r\n		return this.scribe.toString();\r\n	}\r\n	\r\n	private void format(TypeDeclaration typeDeclaration){\r\n\r\n		if (typeDeclaration.modifiers != NO_MODIFIERS) {\r\n			this.scribe.printModifiers();\r\n		} else {\r\n			this.scribe.printComment();\r\n		}\r\n		/*\r\n		 * Type name\r\n		 */\r\n		if (typeDeclaration.isInterface()) {\r\n			this.scribe.printNextToken(ITerminalSymbols.TokenNameinterface, true); \r\n		} else {\r\n			this.scribe.printNextToken(ITerminalSymbols.TokenNameclass, true); \r\n		}\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameIdentifier, true); \r\n\r\n		/* \r\n		 * Superclass \r\n		 */\r\n		final TypeReference superclass = typeDeclaration.superclass;\r\n		if (superclass != null) {\r\n			Alignment superclassAlignment =this.scribe.createAlignment(\r\n					\"superclass\", //$NON-NLS-1$\r\n					this.preferences.type_declaration_superclass_alignment,\r\n					2,\r\n					this.scribe.scanner.currentPosition);\r\n			this.scribe.enterAlignment(superclassAlignment);\r\n			boolean ok = false;\r\n			do {\r\n				try {\r\n					this.scribe.alignFragment(superclassAlignment, 0);\r\n					this.scribe.printNextToken(ITerminalSymbols.TokenNameextends, true);\r\n					this.scribe.alignFragment(superclassAlignment, 1);\r\n					this.scribe.space();\r\n					superclass.traverse(this, typeDeclaration.scope);\r\n					ok = true;\r\n				} catch (AlignmentException e) {\r\n					this.scribe.redoAlignment(e);\r\n				}\r\n			} while (!ok);\r\n			this.scribe.exitAlignment(superclassAlignment, true); \r\n		}\r\n\r\n		/* \r\n		 * Super Interfaces \r\n		 */\r\n		final TypeReference[] superInterfaces = typeDeclaration.superInterfaces;\r\n		if (superInterfaces != null) {\r\n			\r\n			int superInterfaceLength = superInterfaces.length;\r\n			Alignment interfaceAlignment =this.scribe.createAlignment(\r\n					\"superInterfaces\",//$NON-NLS-1$\r\n					this.preferences.type_declaration_superinterfaces_alignment,\r\n					superInterfaceLength+1,  // implements token is first fragment\r\n					this.scribe.scanner.currentPosition);\r\n			this.scribe.enterAlignment(interfaceAlignment);\r\n			boolean ok = false;\r\n			do {\r\n				try {\r\n					this.scribe.alignFragment(interfaceAlignment, 0);\r\n					if (typeDeclaration.isInterface()) {\r\n						this.scribe.printNextToken(ITerminalSymbols.TokenNameextends, true);\r\n					} else  {\r\n						this.scribe.printNextToken(ITerminalSymbols.TokenNameimplements, true);\r\n					}\r\n					for (int i = 0; i < superInterfaceLength; i++) {\r\n						if (i > 0) {\r\n							this.scribe.printNextToken(ITerminalSymbols.TokenNameCOMMA, this.preferences.insert_space_before_comma_in_superinterfaces);\r\n							this.scribe.alignFragment(interfaceAlignment, i+1);\r\n							if (this.preferences.insert_space_after_comma_in_superinterfaces) {\r\n								this.scribe.space();\r\n							}\r\n							superInterfaces[i].traverse(this, typeDeclaration.scope);\r\n						} else {\r\n							this.scribe.alignFragment(interfaceAlignment, i+1);\r\n							this.scribe.space();\r\n							superInterfaces[i].traverse(this, typeDeclaration.scope);\r\n						}\r\n					}\r\n					ok = true;\r\n				} catch (AlignmentException e) {\r\n					this.scribe.redoAlignment(e);\r\n				}\r\n			} while (!ok);\r\n			this.scribe.exitAlignment(interfaceAlignment, true);\r\n		}\r\n\r\n		/*\r\n		 * Type body\r\n		 */\r\n		String class_declaration_brace = this.preferences.type_declaration_brace_position;\r\n\r\n		formatTypeOpeningBrace(class_declaration_brace, this.preferences.insert_space_before_type_open_brace, typeDeclaration);\r\n		\r\n		if (this.preferences.indent_body_declarations_compare_to_type_header) {\r\n			this.scribe.indent();\r\n		}\r\n\r\n		formatTypeMembers(typeDeclaration);\r\n\r\n		this.scribe.printComment();\r\n		\r\n		if (this.preferences.indent_body_declarations_compare_to_type_header) {\r\n			this.scribe.unIndent();\r\n		}\r\n		\r\n		if (this.preferences.insert_new_line_in_empty_type_declaration) {\r\n			this.scribe.printNewLine();\r\n		}\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameRBRACE);\r\n		this.scribe.printTrailingComment();\r\n		if (class_declaration_brace.equals(FormattingPreferences.NEXT_LINE_SHIFTED)) {\r\n			this.scribe.unIndent();\r\n		}\r\n	}\r\n\r\n	/*\r\n	 * Merged traversal of member (types, fields, methods)\r\n	 */\r\n	private void formatClassBodyDeclarations(AstNode[] nodes) {\r\n		final int FIELD = 1, METHOD = 2, TYPE = 3;\r\n		\r\n		Alignment memberAlignment = this.scribe.createAlignment(\"typeMembers\", this.preferences.type_member_alignment, 4, this.scribe.scanner.currentPosition); //$NON-NLS-1$\r\n		this.scribe.enterAlignment(memberAlignment);\r\n		boolean isChunkStart = false;\r\n		boolean ok = false;\r\n		int startIndex = 0;\r\n		do {\r\n			try {\r\n				for (int i = startIndex, max = nodes.length; i < max; i++) {\r\n					AstNode member = nodes[i];\r\n					if (member instanceof FieldDeclaration) {\r\n						isChunkStart = memberAlignment.checkChunkStart(FIELD, i, this.scribe.scanner.currentPosition);\r\n						if (member instanceof MultiFieldDeclaration){\r\n							MultiFieldDeclaration multiField = (MultiFieldDeclaration) member;\r\n							\r\n							if (multiField.isStatic()) {\r\n								format(multiField, this, null, isChunkStart);\r\n							} else {\r\n								format(multiField, this, null, isChunkStart);\r\n							}					\r\n						} else if (member instanceof Initializer) {\r\n							Initializer initializer = (Initializer) member;\r\n							if (initializer.isStatic()) {\r\n								initializer.traverse(this, null);\r\n							} else {\r\n								initializer.traverse(this, null);\r\n							}					\r\n						} else {\r\n							FieldDeclaration field = (FieldDeclaration) member;\r\n							if (field.isStatic()) {\r\n								format(field, this, null, isChunkStart);\r\n							} else {\r\n								format(field, this, null, isChunkStart);\r\n							}					\r\n						}\r\n					} else if (member instanceof AbstractMethodDeclaration) {\r\n						isChunkStart = memberAlignment.checkChunkStart(METHOD, i, this.scribe.scanner.currentPosition);\r\n						format((AbstractMethodDeclaration) member, null, isChunkStart);\r\n					} else {\r\n						isChunkStart = memberAlignment.checkChunkStart(TYPE, i, this.scribe.scanner.currentPosition);\r\n						format((MemberTypeDeclaration)member, null, isChunkStart);\r\n					}\r\n					if (isSemiColon()) {\r\n						this.scribe.printNextToken(ITerminalSymbols.TokenNameSEMICOLON, this.preferences.insert_space_before_semicolon);\r\n						this.scribe.printTrailingComment();\r\n					}\r\n				}\r\n				ok = true;\r\n			} catch(AlignmentException e){\r\n				startIndex = memberAlignment.chunkStartIndex;\r\n				this.scribe.redoAlignment(e);\r\n			}\r\n		} while (!ok);		\r\n		this.scribe.exitAlignment(memberAlignment, true);\r\n		this.scribe.printComment();\r\n	}\r\n	\r\n	private void formatEmptyStatement() {\r\n\r\n		if (this.preferences.put_empty_statement_on_new_line) {\r\n			this.scribe.printNewLine();\r\n		}\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameSEMICOLON, this.preferences.insert_space_before_semicolon);\r\n		this.scribe.printTrailingComment();\r\n		this.scribe.printNewLine();\r\n	}\r\n\r\n	private void formatGuardClauseBlock(Block block, BlockScope scope) {\r\n\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameLBRACE, this.preferences.insert_space_before_block_open_brace);\r\n		this.scribe.space();\r\n\r\n		final Statement[] statements = block.statements;\r\n		statements[0].traverse(this, scope);\r\n		this.scribe.space();\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameRBRACE, false, true);\r\n		this.scribe.printTrailingComment();\r\n	}	\r\n\r\n	public void formatMessageSend(\r\n		MessageSend messageSend,\r\n		BlockScope scope,\r\n		Alignment messageAlignment) {\r\n\r\n		if (messageAlignment != null) {\r\n			this.scribe.alignFragment(messageAlignment, 0);\r\n			this.scribe.printNextToken(ITerminalSymbols.TokenNameDOT);\r\n		}\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameIdentifier); // selector\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameLPAREN, this.preferences.insert_space_before_message_send);\r\n\r\n		final Expression[] arguments = messageSend.arguments;\r\n		if (arguments != null) {\r\n			int argumentLength = arguments.length;\r\n			Alignment argumentsAlignment = this.scribe.createAlignment(\r\n					\"messageArguments\", //$NON-NLS-1$\r\n					this.preferences.message_send_arguments_alignment,\r\n					argumentLength,\r\n					this.scribe.scanner.currentPosition);\r\n			this.scribe.enterAlignment(argumentsAlignment);\r\n			boolean ok = false;\r\n			do {\r\n				try {\r\n					if (this.preferences.insert_space_within_message_send) {\r\n						this.scribe.space();\r\n					}\r\n					for (int i = 0; i < argumentLength; i++) {\r\n						if (i > 0) {\r\n							this.scribe.printNextToken(ITerminalSymbols.TokenNameCOMMA, this.preferences.insert_space_before_comma_in_messagesend_arguments);\r\n						}\r\n						this.scribe.alignFragment(argumentsAlignment, i);\r\n						if (i > 0 && this.preferences.insert_space_after_comma_in_messagesend_arguments) {\r\n							this.scribe.space();\r\n						}\r\n						arguments[i].traverse(this, scope);\r\n					}\r\n					this.scribe.printNextToken(ITerminalSymbols.TokenNameRPAREN, this.preferences.insert_space_within_message_send);\r\n					ok = true;\r\n				} catch (AlignmentException e) {\r\n					this.scribe.redoAlignment(e);\r\n				}\r\n			} while (!ok);\r\n			this.scribe.exitAlignment(argumentsAlignment, true);\r\n		} else {\r\n			this.scribe.printNextToken(ITerminalSymbols.TokenNameRPAREN, this.preferences.insert_space_between_empty_arguments);\r\n		}\r\n	}\r\n\r\n	public void formatMethodArguments(\r\n			AbstractMethodDeclaration methodDeclaration, \r\n			boolean spaceBeforeOpenParen, \r\n			boolean spaceBetweenEmptyArgument,\r\n			boolean spaceBeforeClosingParen, \r\n			boolean spaceBeforeFirstArgument, \r\n			boolean spaceBeforeComma, \r\n			boolean spaceAfterComma) {\r\n				\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameLPAREN, spaceBeforeOpenParen); \r\n		\r\n		final Argument[] arguments = methodDeclaration.arguments;\r\n		if (arguments != null) {\r\n			int argumentLength = arguments.length;\r\n			Alignment argumentsAlignment = this.scribe.createAlignment(\r\n					\"methodArguments\",//$NON-NLS-1$\r\n					this.preferences.method_declaration_arguments_alignment,\r\n					argumentLength,\r\n					this.scribe.scanner.currentPosition);\r\n			this.scribe.enterAlignment(argumentsAlignment);\r\n			boolean ok = false;\r\n			do {\r\n				try {\r\n					if (spaceBeforeFirstArgument) {\r\n						this.scribe.space();\r\n					}\r\n					for (int i = 0; i < argumentLength; i++) {\r\n						if (i > 0) {\r\n							this.scribe.printNextToken(ITerminalSymbols.TokenNameCOMMA, spaceBeforeComma);\r\n						}\r\n						this.scribe.alignFragment(argumentsAlignment, i);\r\n						if (i > 0 && spaceAfterComma) {\r\n							this.scribe.space();\r\n						}\r\n						arguments[i].traverse(this, methodDeclaration.scope);\r\n					}\r\n					ok = true;\r\n				} catch (AlignmentException e) {\r\n					this.scribe.redoAlignment(e);\r\n				}\r\n			} while (!ok);\r\n			this.scribe.exitAlignment(argumentsAlignment, true);\r\n		\r\n			this.scribe.printNextToken(ITerminalSymbols.TokenNameRPAREN, spaceBeforeClosingParen); \r\n		} else {\r\n			this.scribe.printNextToken(ITerminalSymbols.TokenNameRPAREN, spaceBetweenEmptyArgument); \r\n		}\r\n	}\r\n\r\n	private void formatOpeningBrace(String bracePosition, boolean insertSpaceBeforeBrace) {\r\n	\r\n		if (bracePosition.equals(FormattingPreferences.NEXT_LINE)) {\r\n			this.scribe.printNewLine();\r\n		} else if (bracePosition.equals(FormattingPreferences.NEXT_LINE_SHIFTED)) {\r\n			this.scribe.printNewLine();\r\n			this.scribe.indent();\r\n		}\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameLBRACE, insertSpaceBeforeBrace);\r\n\r\n		this.scribe.printTrailingComment();\r\n		this.scribe.printNewLine();\r\n	}\r\n\r\n	public void formatStatements(BlockScope scope, final Statement[] statements) {\r\n		int statementsLength = statements.length;\r\n		for (int i = 0; i < statementsLength; i++) {\r\n			final Statement statement = statements[i];\r\n			statement.traverse(this, scope);\r\n			if (statement instanceof Expression) {\r\n				this.scribe.printNextToken(ITerminalSymbols.TokenNameSEMICOLON, this.preferences.insert_space_before_semicolon);\r\n				this.scribe.printTrailingComment();\r\n			} else if (statement instanceof LocalDeclaration) {\r\n				LocalDeclaration currentLocal = (LocalDeclaration) statement;\r\n				if (i < (statementsLength - 1)) {\r\n					/* \r\n					 * We need to check that the next statement is a local declaration\r\n					 */\r\n					if (statements[i + 1] instanceof LocalDeclaration) {\r\n						LocalDeclaration nextLocal = (LocalDeclaration) statements[i + 1];\r\n						if (currentLocal.declarationSourceStart != nextLocal.declarationSourceStart) {\r\n							this.scribe.printNextToken(ITerminalSymbols.TokenNameSEMICOLON, this.preferences.insert_space_before_semicolon);\r\n							this.scribe.printTrailingComment();\r\n						}\r\n					} else {\r\n						this.scribe.printNextToken(ITerminalSymbols.TokenNameSEMICOLON, this.preferences.insert_space_before_semicolon);\r\n						this.scribe.printTrailingComment();\r\n					}\r\n				} else {\r\n					this.scribe.printNextToken(ITerminalSymbols.TokenNameSEMICOLON, this.preferences.insert_space_before_semicolon);\r\n					this.scribe.printTrailingComment();\r\n				}\r\n			} else {\r\n				this.scribe.printTrailingComment();\r\n			}\r\n			this.scribe.printNewLine();\r\n		}\r\n	}\r\n	\r\n	private void formatThrowsClause(\r\n		AbstractMethodDeclaration methodDeclaration,\r\n		boolean spaceBeforeComma,\r\n		boolean spaceAfterComma) {\r\n			\r\n		final TypeReference[] thrownExceptions = methodDeclaration.thrownExceptions;\r\n		if (thrownExceptions != null) {\r\n			int thrownExceptionsLength = thrownExceptions.length;\r\n			Alignment throwsAlignment = this.scribe.createAlignment(\r\n					\"throws\",//$NON-NLS-1$\r\n					this.preferences.method_throws_clause_alignment,\r\n					thrownExceptionsLength + 1, // throws is the first token\r\n					this.scribe.scanner.currentPosition);\r\n		\r\n			this.scribe.enterAlignment(throwsAlignment);\r\n			boolean ok = false;\r\n			do {\r\n				try {\r\n					this.scribe.alignFragment(throwsAlignment, 0);\r\n					this.scribe.printNextToken(ITerminalSymbols.TokenNamethrows, true); \r\n					this.scribe.space();\r\n		\r\n					for (int i = 0; i < thrownExceptionsLength; i++) {\r\n						if (i > 0) {\r\n							this.scribe.printNextToken(ITerminalSymbols.TokenNameCOMMA, spaceBeforeComma);\r\n							if (spaceAfterComma) {\r\n								this.scribe.space();\r\n							}\r\n						}\r\n						this.scribe.alignFragment(throwsAlignment, i + 1);\r\n						thrownExceptions[i].traverse(this, methodDeclaration.scope);\r\n					}\r\n					ok = true;\r\n				} catch (AlignmentException e) {\r\n					this.scribe.redoAlignment(e);\r\n				}\r\n			} while (!ok);\r\n			this.scribe.exitAlignment(throwsAlignment, true);\r\n		}\r\n	}\r\n\r\n	/*\r\n	 * Merged traversal of member (types, fields, methods)\r\n	 */\r\n	private void formatTypeMembers(TypeDeclaration typeDeclaration) {\r\n		final int FIELD = 1, METHOD = 2, TYPE = 3;\r\n		\r\n		Alignment memberAlignment = this.scribe.createAlignment(\"typeMembers\", this.preferences.type_member_alignment, 4, this.scribe.scanner.currentPosition); //$NON-NLS-1$\r\n		this.scribe.enterAlignment(memberAlignment);\r\n		AstNode[] members = computeMergedMemberDeclarations(typeDeclaration);\r\n		boolean isChunkStart = false;\r\n		boolean ok = false;\r\n		int startIndex = 0;\r\n		do {\r\n			try {\r\n				for (int i = startIndex, max = members.length; i < max; i++) {\r\n					AstNode member = members[i];\r\n					if (member instanceof FieldDeclaration) {\r\n						isChunkStart = memberAlignment.checkChunkStart(FIELD, i, this.scribe.scanner.currentPosition);\r\n						if (member instanceof MultiFieldDeclaration){\r\n							MultiFieldDeclaration multiField = (MultiFieldDeclaration) member;\r\n							\r\n							if (multiField.isStatic()) {\r\n								format(multiField, this, typeDeclaration.staticInitializerScope, isChunkStart);\r\n							} else {\r\n								format(multiField, this, typeDeclaration.initializerScope, isChunkStart);\r\n							}					\r\n						} else if (member instanceof Initializer) {\r\n							int newLineBeforeChunk = isChunkStart ? this.preferences.blank_lines_before_new_chunk : 0;\r\n							if (newLineBeforeChunk > 0) {\r\n								this.scribe.printNewLines(newLineBeforeChunk);\r\n							}\r\n							Initializer initializer = (Initializer) member;\r\n							if (initializer.isStatic()) {\r\n								initializer.traverse(this, typeDeclaration.staticInitializerScope);\r\n							} else {\r\n								initializer.traverse(this, typeDeclaration.initializerScope);\r\n							}					\r\n						} else {\r\n							FieldDeclaration field = (FieldDeclaration) member;\r\n							if (field.isStatic()) {\r\n								format(field, this, typeDeclaration.staticInitializerScope, isChunkStart);\r\n							} else {\r\n								format(field, this, typeDeclaration.initializerScope, isChunkStart);\r\n							}					\r\n						}\r\n					} else if (member instanceof AbstractMethodDeclaration) {\r\n						isChunkStart = memberAlignment.checkChunkStart(METHOD, i, this.scribe.scanner.currentPosition);\r\n						format((AbstractMethodDeclaration) member, typeDeclaration.scope, isChunkStart);\r\n					} else {\r\n						isChunkStart = memberAlignment.checkChunkStart(TYPE, i, this.scribe.scanner.currentPosition);\r\n						format((MemberTypeDeclaration)member, typeDeclaration.scope, isChunkStart);\r\n					}\r\n					if (isSemiColon()) {\r\n						this.scribe.printNextToken(ITerminalSymbols.TokenNameSEMICOLON, this.preferences.insert_space_before_semicolon);\r\n						this.scribe.printTrailingComment();\r\n						this.scribe.printNewLine();\r\n					}\r\n				}\r\n				ok = true;\r\n			} catch(AlignmentException e){\r\n				startIndex = memberAlignment.chunkStartIndex;\r\n				this.scribe.redoAlignment(e);\r\n			}\r\n		} while (!ok);		\r\n		this.scribe.exitAlignment(memberAlignment, true);\r\n	}\r\n\r\n	private void formatTypeOpeningBrace(String bracePosition, boolean insertSpaceBeforeBrace, TypeDeclaration typeDeclaration) {\r\n		int fieldCount = (typeDeclaration.fields == null) ? 0 : typeDeclaration.fields.length;\r\n		int methodCount = (typeDeclaration.methods == null) ? 0 : typeDeclaration.methods.length;\r\n		int typeCount = (typeDeclaration.memberTypes == null) ? 0 : typeDeclaration.memberTypes.length;\r\n	\r\n		if (methodCount == 1 && typeDeclaration.methods[0].isDefaultConstructor()) {\r\n			methodCount = 0;\r\n		}\r\n		final int memberLength = fieldCount+methodCount+typeCount;\r\n\r\n		boolean insertNewLine = memberLength > 0;\r\n		\r\n		if (!insertNewLine) {\r\n			if (typeDeclaration instanceof AnonymousLocalTypeDeclaration) {\r\n				insertNewLine = this.preferences.insert_new_line_in_empty_anonymous_type_declaration;\r\n			} else {\r\n				insertNewLine = this.preferences.insert_new_line_in_empty_type_declaration;\r\n			}\r\n		}\r\n	\r\n		formatOpeningBrace(bracePosition, insertSpaceBeforeBrace);\r\n		\r\n		if (insertNewLine) {\r\n			this.scribe.printNewLine();\r\n		}\r\n	}\r\n\r\n	private int getExtraDimension() {\r\n\r\n		this.localScanner.resetTo(this.scribe.scanner.currentPosition, this.scribe.scannerEndPosition - 1);\r\n		int dimensions = 0;\r\n		try {\r\n			int token;\r\n			while ((token = this.localScanner.getNextToken()) != ITerminalSymbols.TokenNameEOF) {\r\n				switch(token) {\r\n					case ITerminalSymbols.TokenNameRBRACKET://166 \r\n						dimensions++;\r\n						break;\r\n					case ITerminalSymbols.TokenNameIdentifier ://90						\r\n					case ITerminalSymbols.TokenNameLBRACE ://90						\r\n					case ITerminalSymbols.TokenNameLPAREN :\r\n					case ITerminalSymbols.TokenNameCOMMA ://90\r\n					case ITerminalSymbols.TokenNameEQUAL ://167\r\n					case ITerminalSymbols.TokenNameSEMICOLON ://64\r\n					case ITerminalSymbols.TokenNameRPAREN : //86\r\n						return dimensions;\r\n				}\r\n			}\r\n		} catch(InvalidInputException e) {\r\n		}\r\n		return dimensions;\r\n	}\r\n\r\n	private boolean isComma() {\r\n\r\n		this.localScanner.resetTo(this.scribe.scanner.currentPosition, this.scribe.scannerEndPosition - 1);\r\n		try {\r\n			return this.localScanner.getNextToken() == ITerminalSymbols.TokenNameCOMMA;\r\n		} catch(InvalidInputException e) {\r\n		}\r\n		return false;\r\n	}\r\n\r\n	private boolean isGuardClause(Block block) {\r\n		return block.statements != null \r\n				&& block.statements.length == 1\r\n				&& (block.statements[0] instanceof ReturnStatement\r\n					|| block.statements[0] instanceof ThrowStatement);\r\n	}	\r\n\r\n	private boolean isMultipleLocalDeclaration(LocalDeclaration localDeclaration) {\r\n\r\n		if (localDeclaration.declarationSourceStart == this.lastLocalDeclarationSourceStart) return true;\r\n		this.lastLocalDeclarationSourceStart = localDeclaration.declarationSourceStart;\r\n		return false;\r\n	}\r\n\r\n	private boolean isPartOfMultipleLocalDeclaration() {\r\n		this.localScanner.resetTo(this.scribe.scanner.currentPosition, this.scribe.scannerEndPosition - 1);\r\n		try {\r\n			int token;\r\n			while ((token = this.localScanner.getNextToken()) != ITerminalSymbols.TokenNameEOF) {\r\n				switch(token) {\r\n					case ITerminalSymbols.TokenNameCOMMA ://90\r\n						return true;\r\n					default:\r\n						return false;\r\n				}\r\n			}\r\n		} catch(InvalidInputException e) {\r\n		}\r\n		return false;\r\n	}\r\n\r\n	private boolean isSemiColon() {\r\n\r\n		this.localScanner.resetTo(this.scribe.scanner.currentPosition, this.scribe.scannerEndPosition - 1);\r\n		try {\r\n			return this.localScanner.getNextToken() == ITerminalSymbols.TokenNameSEMICOLON;\r\n		} catch(InvalidInputException e) {\r\n		}\r\n		return false;\r\n	}\r\n	\r\n	private void manageClosingParenthesizedExpression(Expression expression, int numberOfParens) {\r\n		for (int i = 0; i < numberOfParens; i++) {\r\n			this.scribe.printNextToken(ITerminalSymbols.TokenNameRPAREN, this.preferences.insert_space_before_closing_paren_in_parenthesized_expression);\r\n		}\r\n	}\r\n\r\n	private void manageOpeningParenthesizedExpression(Expression expression, int numberOfParens) {\r\n		for (int i = 0; i < numberOfParens; i++) {\r\n			this.scribe.printNextToken(ITerminalSymbols.TokenNameLPAREN, this.preferences.insert_space_before_open_paren_in_parenthesized_expression);\r\n			if (this.preferences.insert_space_after_open_paren_in_parenthesized_expression) {\r\n				this.scribe.space();\r\n			}\r\n		}\r\n	}\r\n			\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.AllocationExpression, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(\r\n		AllocationExpression allocationExpression,\r\n		BlockScope scope) {\r\n		// \'new\' ClassType \'(\' ArgumentListopt \')\' ClassBodyopt\r\n\r\n		final int numberOfParens = (allocationExpression.bits & AstNode.ParenthesizedMASK) >> AstNode.ParenthesizedSHIFT;\r\n		if (numberOfParens > 0) {\r\n			manageOpeningParenthesizedExpression(allocationExpression, numberOfParens);\r\n		}\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNamenew);\r\n		this.scribe.space();\r\n		allocationExpression.type.traverse(this, scope);\r\n		\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameLPAREN, this.preferences.insert_space_before_message_send);\r\n\r\n		final Expression[] arguments = allocationExpression.arguments;\r\n		if (arguments != null) {\r\n			int argumentLength = arguments.length;\r\n			Alignment argumentsAlignment =this.scribe.createAlignment(\r\n					\"allocation\",//$NON-NLS-1$\r\n					this.preferences.allocation_expression_arguments_alignment,\r\n					argumentLength,\r\n					this.scribe.scanner.currentPosition);\r\n			this.scribe.enterAlignment(argumentsAlignment);\r\n			boolean ok = false;\r\n			do {\r\n				try {\r\n					if (this.preferences.insert_space_within_message_send) {\r\n						this.scribe.space();\r\n					}\r\n					for (int i = 0; i < argumentLength; i++) {\r\n						if (i > 0) {\r\n							this.scribe.printNextToken(ITerminalSymbols.TokenNameCOMMA, this.preferences.insert_space_before_comma_in_allocation_expression);\r\n						}\r\n						this.scribe.alignFragment(argumentsAlignment, i);\r\n						if (i > 0 && this.preferences.insert_space_after_comma_in_allocation_expression) {\r\n							this.scribe.space();\r\n						}\r\n						arguments[i].traverse(this, scope);\r\n					}\r\n					ok = true;\r\n				} catch (AlignmentException e) {\r\n					this.scribe.redoAlignment(e);\r\n				}\r\n			} while (!ok);\r\n			this.scribe.exitAlignment(argumentsAlignment, true);\r\n			this.scribe.printNextToken(ITerminalSymbols.TokenNameRPAREN, this.preferences.insert_space_within_message_send); \r\n		} else {\r\n			this.scribe.printNextToken(ITerminalSymbols.TokenNameRPAREN, this.preferences.insert_space_between_empty_arguments); \r\n		}\r\n		\r\n		if (numberOfParens > 0) {\r\n			manageClosingParenthesizedExpression(allocationExpression, numberOfParens);\r\n		}\r\n		return false;\r\n	}\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.AND_AND_Expression, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(\r\n		AND_AND_Expression and_and_Expression,\r\n		BlockScope scope) {\r\n			\r\n		return dumpBinaryExpression(and_and_Expression, ITerminalSymbols.TokenNameAND_AND, scope);\r\n	}\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.AnonymousLocalTypeDeclaration, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(\r\n		AnonymousLocalTypeDeclaration anonymousTypeDeclaration,\r\n		BlockScope scope) {\r\n			\r\n		/*\r\n		 * Type body\r\n		 */\r\n		String anonymous_type_declaration_brace_position = this.preferences.anonymous_type_declaration_brace_position;\r\n		formatTypeOpeningBrace(anonymous_type_declaration_brace_position, this.preferences.insert_space_before_anonymous_type_open_brace, anonymousTypeDeclaration);\r\n		\r\n		this.scribe.indent();\r\n\r\n		formatTypeMembers(anonymousTypeDeclaration);\r\n		\r\n		this.scribe.printComment();\r\n		this.scribe.unIndent();\r\n		if (this.preferences.insert_new_line_in_empty_anonymous_type_declaration) {\r\n			this.scribe.printNewLine();\r\n		}\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameRBRACE);\r\n		if (anonymous_type_declaration_brace_position.equals(FormattingPreferences.NEXT_LINE_SHIFTED)) {\r\n			this.scribe.unIndent();\r\n		}\r\n		return false;\r\n	}\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.Argument, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(Argument argument, BlockScope scope) {\r\n\r\n		if (argument.modifiers != NO_MODIFIERS) {\r\n			this.scribe.printModifiers();\r\n			this.scribe.space();\r\n		}\r\n\r\n		/*\r\n		 * Argument type \r\n		 */		\r\n		if (argument.type != null) {\r\n			argument.type.traverse(this, scope);\r\n		}\r\n		\r\n		/*\r\n		 * Print the argument name\r\n		 */	\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameIdentifier, true);\r\n\r\n\r\n		/*\r\n		 * Check for extra dimensions\r\n		 */\r\n		int extraDimensions = getExtraDimension();\r\n		if (extraDimensions != 0) {\r\n			 for (int i = 0; i < extraDimensions; i++) {\r\n			 	this.scribe.printNextToken(ITerminalSymbols.TokenNameLBRACKET);\r\n			 	this.scribe.printNextToken(ITerminalSymbols.TokenNameRBRACKET);\r\n			 }\r\n		}\r\n		\r\n		return false;\r\n	}\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.ArrayAllocationExpression, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(\r\n		ArrayAllocationExpression arrayAllocationExpression,\r\n		BlockScope scope) {\r\n\r\n			final int numberOfParens = (arrayAllocationExpression.bits & AstNode.ParenthesizedMASK) >> AstNode.ParenthesizedSHIFT;\r\n			if (numberOfParens > 0) {\r\n				manageOpeningParenthesizedExpression(arrayAllocationExpression, numberOfParens);\r\n			}\r\n			this.scribe.printNextToken(ITerminalSymbols.TokenNamenew);\r\n			this.scribe.space();\r\n			arrayAllocationExpression.type.traverse(this, scope);\r\n			\r\n			final Expression[] dimensions = arrayAllocationExpression.dimensions;\r\n			int dimensionsLength = dimensions.length;\r\n			for (int i = 0; i < dimensionsLength; i++) {\r\n				this.scribe.printNextToken(ITerminalSymbols.TokenNameLBRACKET);\r\n				if (dimensions[i] != null) {\r\n					dimensions[i].traverse(this, scope);\r\n				}\r\n				this.scribe.printNextToken(ITerminalSymbols.TokenNameRBRACKET);\r\n			}\r\n			final ArrayInitializer initializer = arrayAllocationExpression.initializer;\r\n			if (initializer != null) {\r\n				initializer.traverse(this, scope);\r\n			}\r\n\r\n			if (numberOfParens > 0) {\r\n				manageClosingParenthesizedExpression(arrayAllocationExpression, numberOfParens);\r\n			}\r\n			return false;\r\n	}\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.ArrayInitializer, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(ArrayInitializer arrayInitializer, BlockScope scope) {\r\n\r\n		final int numberOfParens = (arrayInitializer.bits & AstNode.ParenthesizedMASK) >> AstNode.ParenthesizedSHIFT;\r\n		if (numberOfParens > 0) {\r\n			manageOpeningParenthesizedExpression(arrayInitializer, numberOfParens);\r\n		}\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameLBRACE);\r\n		\r\n		final Expression[] expressions = arrayInitializer.expressions;\r\n		if (expressions != null) {\r\n			int expressionsLength = expressions.length;\r\n			if (expressionsLength > 1) {\r\n				Alignment expressionsAlignment =this.scribe.createAlignment(\r\n						\"expressions\",//$NON-NLS-1$\r\n						this.preferences.array_initializer_expressions_alignment,\r\n						expressionsLength - 1,\r\n						this.scribe.scanner.currentPosition);\r\n				this.scribe.enterAlignment(expressionsAlignment);\r\n				boolean ok = false;\r\n				do {\r\n					try {\r\n						if (this.preferences.insert_space_before_first_initializer) {\r\n							this.scribe.space();\r\n						}\r\n						expressions[0].traverse(this, scope);\r\n						for (int i = 1; i < expressionsLength; i++) {\r\n							this.scribe.printNextToken(ITerminalSymbols.TokenNameCOMMA, this.preferences.insert_space_before_comma_in_array_initializer);\r\n							if (this.preferences.insert_space_after_comma_in_array_initializer) {\r\n								this.scribe.space();\r\n							}\r\n							this.scribe.alignFragment(expressionsAlignment, i - 1);\r\n							expressions[i].traverse(this, scope);\r\n						}\r\n						ok = true;\r\n					} catch (AlignmentException e) {\r\n						this.scribe.redoAlignment(e);\r\n					}\r\n				} while (!ok);\r\n				this.scribe.exitAlignment(expressionsAlignment, true);\r\n			} else {\r\n				// we don\'t need to use an alignment\r\n				if (this.preferences.insert_space_before_first_initializer) {\r\n					this.scribe.space();\r\n				}\r\n				expressions[0].traverse(this, scope);\r\n				for (int i = 1; i < expressionsLength; i++) {\r\n					this.scribe.printNextToken(ITerminalSymbols.TokenNameCOMMA, this.preferences.insert_space_before_comma_in_array_initializer);\r\n					if (this.preferences.insert_space_after_comma_in_array_initializer) {\r\n						this.scribe.space();\r\n					}\r\n					expressions[i].traverse(this, scope);\r\n				}\r\n			}\r\n			if (isComma()) {\r\n				this.scribe.printNextToken(ITerminalSymbols.TokenNameCOMMA, this.preferences.insert_space_before_comma_in_array_initializer);\r\n			}\r\n			this.scribe.printNextToken(ITerminalSymbols.TokenNameRBRACE, this.preferences.insert_space_before_closing_brace_in_array_initializer, true); \r\n		} else {\r\n			this.scribe.printNextToken(ITerminalSymbols.TokenNameRBRACE, this.preferences.insert_space_between_empty_array_initializer, true);\r\n		}\r\n\r\n		if (numberOfParens > 0) {\r\n			manageClosingParenthesizedExpression(arrayInitializer, numberOfParens);\r\n		}\r\n		return false;\r\n	}\r\n	\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.ArrayQualifiedTypeReference, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(\r\n		ArrayQualifiedTypeReference arrayQualifiedTypeReference,\r\n		BlockScope scope) {\r\n\r\n			final int numberOfParens = (arrayQualifiedTypeReference.bits & AstNode.ParenthesizedMASK) >> AstNode.ParenthesizedSHIFT;\r\n			if (numberOfParens > 0) {\r\n				manageOpeningParenthesizedExpression(arrayQualifiedTypeReference, numberOfParens);\r\n			}\r\n			this.scribe.printQualifiedReference(arrayQualifiedTypeReference.sourceEnd - 1);\r\n			int dimensions = getExtraDimension();\r\n			if (dimensions != 0) {\r\n				for (int i = 0; i < dimensions; i++) {\r\n					this.scribe.printNextToken(ITerminalSymbols.TokenNameLBRACKET);\r\n					this.scribe.printNextToken(ITerminalSymbols.TokenNameRBRACKET);\r\n				}\r\n			}\r\n			if (numberOfParens > 0) {\r\n				manageClosingParenthesizedExpression(arrayQualifiedTypeReference, numberOfParens);\r\n			}\r\n			return false;\r\n	}\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.ArrayQualifiedTypeReference, org.eclipse.jdt.internal.compiler.lookup.ClassScope)\r\n	 */\r\n	public boolean visit(\r\n		ArrayQualifiedTypeReference arrayQualifiedTypeReference,\r\n		ClassScope scope) {\r\n\r\n			final int numberOfParens = (arrayQualifiedTypeReference.bits & AstNode.ParenthesizedMASK) >> AstNode.ParenthesizedSHIFT;\r\n			if (numberOfParens > 0) {\r\n				manageOpeningParenthesizedExpression(arrayQualifiedTypeReference, numberOfParens);\r\n			}\r\n			this.scribe.printQualifiedReference(arrayQualifiedTypeReference.sourceEnd - 1);\r\n			int dimensions = getExtraDimension();\r\n			if (dimensions != 0) {\r\n				for (int i = 0; i < dimensions; i++) {\r\n					this.scribe.printNextToken(ITerminalSymbols.TokenNameLBRACKET);\r\n					this.scribe.printNextToken(ITerminalSymbols.TokenNameRBRACKET);\r\n				}\r\n			}\r\n			if (numberOfParens > 0) {\r\n				manageClosingParenthesizedExpression(arrayQualifiedTypeReference, numberOfParens);\r\n			}\r\n			return false;\r\n	}\r\n\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.ArrayReference, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(ArrayReference arrayReference, BlockScope scope) {\r\n\r\n		final int numberOfParens = (arrayReference.bits & AstNode.ParenthesizedMASK) >> AstNode.ParenthesizedSHIFT;\r\n		if (numberOfParens > 0) {\r\n			manageOpeningParenthesizedExpression(arrayReference, numberOfParens);\r\n		}\r\n		arrayReference.receiver.traverse(this, scope);\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameLBRACKET);\r\n		arrayReference.position.traverse(this, scope);\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameRBRACKET);\r\n		\r\n		if (numberOfParens > 0) {\r\n			manageClosingParenthesizedExpression(arrayReference, numberOfParens);\r\n		}\r\n		return false;\r\n	}\r\n	\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.ArrayTypeReference, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(\r\n		ArrayTypeReference arrayTypeReference,\r\n		BlockScope scope) {\r\n\r\n		final int numberOfParens = (arrayTypeReference.bits & AstNode.ParenthesizedMASK) >> AstNode.ParenthesizedSHIFT;\r\n		if (numberOfParens > 0) {\r\n			manageOpeningParenthesizedExpression(arrayTypeReference, numberOfParens);\r\n		}\r\n		this.scribe.printNextToken(SINGLETYPEREFERENCE_EXPECTEDTOKENS, false, true);\r\n		\r\n		int dimensions = getExtraDimension();\r\n		if (dimensions != 0) {\r\n			if (this.preferences.insert_space_before_bracket_in_array_type_reference) {\r\n				this.scribe.space();\r\n			}\r\n			for (int i = 0; i < dimensions; i++) {\r\n				this.scribe.printNextToken(ITerminalSymbols.TokenNameLBRACKET);\r\n				if (this.preferences.insert_space_between_brackets_in_array_type_reference) {\r\n					this.scribe.space();\r\n				}\r\n				this.scribe.printNextToken(ITerminalSymbols.TokenNameRBRACKET);\r\n			}\r\n		}\r\n		if (numberOfParens > 0) {\r\n			manageClosingParenthesizedExpression(arrayTypeReference, numberOfParens);\r\n		}\r\n		return false;\r\n	}\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.ArrayTypeReference, org.eclipse.jdt.internal.compiler.lookup.ClassScope)\r\n	 */\r\n	public boolean visit(\r\n		ArrayTypeReference arrayTypeReference,\r\n		ClassScope scope) {\r\n\r\n		final int numberOfParens = (arrayTypeReference.bits & AstNode.ParenthesizedMASK) >> AstNode.ParenthesizedSHIFT;\r\n		if (numberOfParens > 0) { \r\n			manageOpeningParenthesizedExpression(arrayTypeReference, numberOfParens);\r\n		}\r\n		this.scribe.printNextToken(SINGLETYPEREFERENCE_EXPECTEDTOKENS, false, true);\r\n		int dimensions = getExtraDimension();\r\n		if (dimensions != 0) {\r\n			if (this.preferences.insert_space_before_bracket_in_array_type_reference) {\r\n				this.scribe.space();\r\n			}\r\n			for (int i = 0; i < dimensions; i++) {\r\n				this.scribe.printNextToken(ITerminalSymbols.TokenNameLBRACKET);\r\n				if (this.preferences.insert_space_between_brackets_in_array_type_reference) {\r\n					this.scribe.space();\r\n				}\r\n				this.scribe.printNextToken(ITerminalSymbols.TokenNameRBRACKET);\r\n			}\r\n		}\r\n		if (numberOfParens > 0) {\r\n			manageClosingParenthesizedExpression(arrayTypeReference, numberOfParens);\r\n		}\r\n		return false;\r\n	}\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.AssertStatement, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(AssertStatement assertStatement, BlockScope scope) {\r\n		\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameassert);\r\n		this.scribe.space();\r\n		assertStatement.assertExpression.traverse(this, scope);\r\n		\r\n		if (assertStatement.exceptionArgument != null) {\r\n			this.scribe.printNextToken(ITerminalSymbols.TokenNameCOLON, this.preferences.insert_space_before_colon_in_assert);\r\n			if (this.preferences.insert_space_after_colon_in_assert) {\r\n				this.scribe.space();\r\n			}\r\n			assertStatement.exceptionArgument.traverse(this, scope);\r\n		}\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameSEMICOLON, this.preferences.insert_space_before_semicolon);		\r\n		return false;\r\n	}\r\n	\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.Assignment, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(Assignment assignment, BlockScope scope) {\r\n\r\n		final int numberOfParens = (assignment.bits & AstNode.ParenthesizedMASK) >> AstNode.ParenthesizedSHIFT;\r\n		if (numberOfParens > 0) {\r\n			manageOpeningParenthesizedExpression(assignment, numberOfParens);\r\n		}\r\n		assignment.lhs.traverse(this, scope);\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameEQUAL, this.preferences.insert_space_before_assignment_operators);\r\n		if (this.preferences.insert_space_after_assignment_operators) {\r\n			this.scribe.space();\r\n		}\r\n		assignment.expression.traverse(this, scope);\r\n		\r\n		if (numberOfParens > 0) {\r\n			manageClosingParenthesizedExpression(assignment, numberOfParens);\r\n		}\r\n		return false;\r\n	}\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.BinaryExpression, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(BinaryExpression binaryExpression, BlockScope scope) {\r\n\r\n		switch((binaryExpression.bits & AstNode.OperatorMASK) >> AstNode.OperatorSHIFT) {\r\n			case OperatorIds.AND :\r\n				return dumpBinaryExpression(binaryExpression, ITerminalSymbols.TokenNameAND, scope);\r\n			case OperatorIds.DIVIDE :\r\n				return dumpBinaryExpression(binaryExpression, ITerminalSymbols.TokenNameDIVIDE, scope);\r\n			case OperatorIds.GREATER :\r\n				return dumpBinaryExpression(binaryExpression, ITerminalSymbols.TokenNameGREATER, scope);\r\n			case OperatorIds.GREATER_EQUAL :\r\n				return dumpBinaryExpression(binaryExpression, ITerminalSymbols.TokenNameGREATER_EQUAL, scope);\r\n			case OperatorIds.LEFT_SHIFT :\r\n				return dumpBinaryExpression(binaryExpression, ITerminalSymbols.TokenNameLEFT_SHIFT, scope);\r\n			case OperatorIds.LESS :\r\n				return dumpBinaryExpression(binaryExpression, ITerminalSymbols.TokenNameLESS, scope);\r\n			case OperatorIds.LESS_EQUAL :\r\n				return dumpBinaryExpression(binaryExpression, ITerminalSymbols.TokenNameLESS_EQUAL, scope);\r\n			case OperatorIds.MINUS :\r\n				return dumpBinaryExpression(binaryExpression, ITerminalSymbols.TokenNameMINUS, scope);\r\n			case OperatorIds.MULTIPLY :\r\n				return dumpBinaryExpression(binaryExpression, ITerminalSymbols.TokenNameMULTIPLY, scope);\r\n			case OperatorIds.OR :\r\n				return dumpBinaryExpression(binaryExpression, ITerminalSymbols.TokenNameOR, scope);\r\n			case OperatorIds.PLUS :\r\n				return dumpBinaryExpression(binaryExpression, ITerminalSymbols.TokenNamePLUS, scope);\r\n			case OperatorIds.REMAINDER :\r\n				return dumpBinaryExpression(binaryExpression, ITerminalSymbols.TokenNameREMAINDER, scope);\r\n			case OperatorIds.RIGHT_SHIFT :\r\n				return dumpBinaryExpression(binaryExpression, ITerminalSymbols.TokenNameRIGHT_SHIFT, scope);\r\n			case OperatorIds.UNSIGNED_RIGHT_SHIFT :\r\n				return dumpBinaryExpression(binaryExpression, ITerminalSymbols.TokenNameUNSIGNED_RIGHT_SHIFT, scope);\r\n			case OperatorIds.XOR :\r\n				return dumpBinaryExpression(binaryExpression, ITerminalSymbols.TokenNameXOR, scope);\r\n			default:\r\n				throw new IllegalStateException();\r\n		}\r\n	}\r\n	\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.Block, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(Block block, BlockScope scope) {\r\n	\r\n		String block_brace_position = this.preferences.block_brace_position;\r\n		formatOpeningBrace(block_brace_position, this.preferences.insert_space_before_block_open_brace);\r\n		this.scribe.indent();\r\n	\r\n		final Statement[] statements = block.statements;\r\n		if (statements != null) {\r\n			this.scribe.printTrailingComment();\r\n			this.scribe.printNewLine();\r\n			formatStatements(scope, statements);\r\n		} else if (this.preferences.insert_new_line_in_empty_block) {\r\n			this.scribe.printNewLine();\r\n		}\r\n		this.scribe.printComment();\r\n\r\n		this.scribe.unIndent();\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameRBRACE);\r\n		this.scribe.printTrailingComment();\r\n		this.scribe.printNewLine();\r\n	\r\n		if (block_brace_position.equals(FormattingPreferences.NEXT_LINE_SHIFTED)) {\r\n			this.scribe.unIndent();\r\n		}		\r\n		return false;	\r\n	}\r\n\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.Break, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(BreakStatement breakStatement, BlockScope scope) {\r\n		\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNamebreak);\r\n		if (breakStatement.label != null) {\r\n			this.scribe.printNextToken(ITerminalSymbols.TokenNameIdentifier, true);\r\n		}\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameSEMICOLON, this.preferences.insert_space_before_semicolon);\r\n		return false;\r\n	}\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.Case, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(CaseStatement caseStatement, BlockScope scope) {		\r\n		if (caseStatement.constantExpression == null) {\r\n			this.scribe.printNextToken(ITerminalSymbols.TokenNamedefault);\r\n			this.scribe.printNextToken(ITerminalSymbols.TokenNameCOLON, this.preferences.insert_space_before_colon_in_default);\r\n		} else {\r\n			this.scribe.printNextToken(ITerminalSymbols.TokenNamecase);\r\n			this.scribe.space();\r\n			caseStatement.constantExpression.traverse(this, scope);\r\n			this.scribe.printNextToken(ITerminalSymbols.TokenNameCOLON, this.preferences.insert_space_before_colon_in_case);\r\n		}\r\n		return false;\r\n	}\r\n\r\n\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.CastExpression, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(CastExpression castExpression, BlockScope scope) {\r\n\r\n		final int numberOfParens = (castExpression.bits & AstNode.ParenthesizedMASK) >> AstNode.ParenthesizedSHIFT;\r\n		if (numberOfParens > 0) {\r\n			manageOpeningParenthesizedExpression(castExpression, numberOfParens);\r\n		}\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameLPAREN);\r\n		if (this.preferences.insert_space_after_opening_paren_in_cast) {\r\n			this.scribe.space();\r\n		}\r\n		castExpression.type.traverse(this, scope);\r\n\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameRPAREN, this.preferences.insert_space_before_closing_paren_in_cast);\r\n		if (this.preferences.insert_space_after_closing_paren_in_cast) {\r\n			this.scribe.space();\r\n		}\r\n		castExpression.expression.traverse(this, scope);\r\n		\r\n		if (numberOfParens > 0) {\r\n			manageClosingParenthesizedExpression(castExpression, numberOfParens);\r\n		}\r\n		return false;\r\n	}\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.CharLiteral, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(CharLiteral charLiteral, BlockScope scope) {\r\n\r\n		final int numberOfParens = (charLiteral.bits & AstNode.ParenthesizedMASK) >> AstNode.ParenthesizedSHIFT;\r\n		if (numberOfParens > 0) {\r\n			manageOpeningParenthesizedExpression(charLiteral, numberOfParens);\r\n		}\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameCharacterLiteral);\r\n\r\n		if (numberOfParens > 0) {\r\n			manageClosingParenthesizedExpression(charLiteral, numberOfParens);\r\n		}\r\n		return false;\r\n	}\r\n\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.ClassLiteralAccess, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(ClassLiteralAccess classLiteral, BlockScope scope) {\r\n\r\n		final int numberOfParens = (classLiteral.bits & AstNode.ParenthesizedMASK) >> AstNode.ParenthesizedSHIFT;\r\n		if (numberOfParens > 0) {\r\n			manageOpeningParenthesizedExpression(classLiteral, numberOfParens);\r\n		}\r\n		classLiteral.type.traverse(this, scope);\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameDOT);\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameclass);\r\n		\r\n		if (numberOfParens > 0) {\r\n			manageClosingParenthesizedExpression(classLiteral, numberOfParens);\r\n		}\r\n		return false;\r\n	}\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.Clinit, org.eclipse.jdt.internal.compiler.lookup.ClassScope)\r\n	 */\r\n	public boolean visit(Clinit clinit, ClassScope scope) {\r\n\r\n		return false;\r\n	}\r\n	\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration, org.eclipse.jdt.internal.compiler.lookup.CompilationUnitScope)\r\n	 */\r\n	public boolean visit(\r\n		CompilationUnitDeclaration compilationUnitDeclaration,\r\n		CompilationUnitScope scope) {\r\n		\r\n		/* \r\n		 * Package declaration\r\n		 */\r\n		if (compilationUnitDeclaration.currentPackage != null) {\r\n			// OPTION\r\n			// dump the package keyword\r\n			int blankLinesBeforePackage = this.preferences.blank_lines_before_package;\r\n			if (blankLinesBeforePackage > 0) {\r\n				this.scribe.printNewLines(blankLinesBeforePackage - 1);\r\n			}\r\n			this.scribe.printComment();\r\n			this.scribe.printNextToken(ITerminalSymbols.TokenNamepackage);\r\n			this.scribe.space();\r\n			this.scribe.printQualifiedReference(compilationUnitDeclaration.currentPackage.sourceEnd);\r\n			this.scribe.printNextToken(ITerminalSymbols.TokenNameSEMICOLON, this.preferences.insert_space_before_semicolon);\r\n			this.scribe.printTrailingComment();\r\n			int blankLinesAfterPackage = this.preferences.blank_lines_after_package;\r\n			if (blankLinesAfterPackage > 0) {\r\n				this.scribe.printNewLines(blankLinesAfterPackage);\r\n			}				\r\n		} else {\r\n			this.scribe.printComment();\r\n		}\r\n		\r\n		/*\r\n		 * Import statements\r\n		 */\r\n		final ImportReference[] imports = compilationUnitDeclaration.imports;\r\n		if (imports != null) {\r\n			int blankLinesBeforeImports = this.preferences.blank_lines_before_imports;\r\n			if (blankLinesBeforeImports > 0) {\r\n				this.scribe.printNewLines(blankLinesBeforeImports);\r\n			}\r\n			int importLength = imports.length;\r\n			for (int i = 0; i < importLength; i++) {\r\n				imports[i].traverse(this, scope);\r\n			}			\r\n			\r\n			int blankLinesAfterImports = this.preferences.blank_lines_after_imports;\r\n			if (blankLinesAfterImports > 0) {\r\n				this.scribe.printNewLines(blankLinesAfterImports);\r\n			}\r\n		}\r\n\r\n		/*\r\n		 * Type declarations\r\n		 */\r\n		final TypeDeclaration[] types = compilationUnitDeclaration.types;\r\n		if (types != null) {\r\n			int typesLength = types.length;\r\n			for (int i = 0; i < typesLength; i++) {\r\n				types[i].traverse(this, scope);\r\n			}\r\n		}\r\n		this.scribe.printComment();\r\n		return false;\r\n	}\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.CompoundAssignment, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(\r\n		CompoundAssignment compoundAssignment,\r\n		BlockScope scope) {\r\n			\r\n		final int numberOfParens = (compoundAssignment.bits & AstNode.ParenthesizedMASK) >> AstNode.ParenthesizedSHIFT;\r\n		if (numberOfParens > 0) {\r\n			manageOpeningParenthesizedExpression(compoundAssignment, numberOfParens);\r\n		}\r\n		compoundAssignment.lhs.traverse(this, scope);\r\n		\r\n		/*\r\n		 * Print the operator\r\n		 */\r\n		int operator;\r\n		switch(compoundAssignment.operator) {\r\n			case OperatorIds.PLUS :\r\n				operator = ITerminalSymbols.TokenNamePLUS_EQUAL;\r\n				break;\r\n			case OperatorIds.MINUS :\r\n				operator = ITerminalSymbols.TokenNameMINUS_EQUAL;\r\n				break;\r\n			case OperatorIds.MULTIPLY :\r\n				operator = ITerminalSymbols.TokenNameMULTIPLY_EQUAL;\r\n				break;\r\n			case OperatorIds.DIVIDE :\r\n				operator = ITerminalSymbols.TokenNameDIVIDE_EQUAL;\r\n				break;\r\n			case OperatorIds.AND :\r\n				operator = ITerminalSymbols.TokenNameAND_EQUAL;\r\n				break;\r\n			case OperatorIds.OR :\r\n				operator = ITerminalSymbols.TokenNameOR_EQUAL;\r\n				break;\r\n			case OperatorIds.XOR :\r\n				operator = ITerminalSymbols.TokenNameXOR_EQUAL;\r\n				break;\r\n			case OperatorIds.REMAINDER :\r\n				operator = ITerminalSymbols.TokenNameREMAINDER_EQUAL;\r\n				break;\r\n			case OperatorIds.LEFT_SHIFT :\r\n				operator = ITerminalSymbols.TokenNameLEFT_SHIFT_EQUAL;\r\n				break;\r\n			case OperatorIds.RIGHT_SHIFT :\r\n				operator = ITerminalSymbols.TokenNameRIGHT_SHIFT_EQUAL;\r\n				break;\r\n			default: // OperatorIds.UNSIGNED_RIGHT_SHIFT :\r\n				operator = ITerminalSymbols.TokenNameUNSIGNED_RIGHT_SHIFT_EQUAL;\r\n		}\r\n		\r\n		this.scribe.printNextToken(operator, this.preferences.insert_space_before_assignment_operators);\r\n		if (this.preferences.insert_space_after_assignment_operators) {\r\n			this.scribe.space();\r\n		}\r\n		compoundAssignment.expression.traverse(this, scope);\r\n		\r\n		if (numberOfParens > 0) {\r\n			manageClosingParenthesizedExpression(compoundAssignment, numberOfParens);\r\n		}\r\n		return false;\r\n	}\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.ConditionalExpression, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(\r\n		ConditionalExpression conditionalExpression,\r\n		BlockScope scope) {\r\n\r\n		final int numberOfParens = (conditionalExpression.bits & AstNode.ParenthesizedMASK) >> AstNode.ParenthesizedSHIFT;\r\n		if (numberOfParens > 0) {\r\n			manageOpeningParenthesizedExpression(conditionalExpression, numberOfParens);\r\n		}\r\n		conditionalExpression.condition.traverse(this, scope);\r\n\r\n		Alignment conditionalExpressionAlignment =this.scribe.createAlignment(\r\n				\"conditionalExpression\", //$NON-NLS-1$\r\n				this.preferences.conditional_expression_alignment,\r\n				2,\r\n				this.scribe.scanner.currentPosition);\r\n\r\n		this.scribe.enterAlignment(conditionalExpressionAlignment);\r\n		boolean ok = false;\r\n		do {\r\n			try {\r\n				this.scribe.alignFragment(conditionalExpressionAlignment, 0);\r\n				this.scribe.printNextToken(ITerminalSymbols.TokenNameQUESTION, this.preferences.insert_space_before_question_in_conditional);\r\n\r\n				if (this.preferences.insert_space_after_question_in_conditional) {\r\n					this.scribe.space();\r\n				}\r\n				conditionalExpression.valueIfTrue.traverse(this, scope);\r\n\r\n				this.scribe.alignFragment(conditionalExpressionAlignment, 1);\r\n				this.scribe.printNextToken(ITerminalSymbols.TokenNameCOLON, this.preferences.insert_space_before_colon_in_conditional);\r\n\r\n				if (this.preferences.insert_space_after_colon_in_conditional) {\r\n					this.scribe.space();\r\n				}\r\n				conditionalExpression.valueIfFalse.traverse(this, scope);\r\n\r\n				ok = true;\r\n			} catch (AlignmentException e) {\r\n				this.scribe.redoAlignment(e);\r\n			}\r\n		} while (!ok);\r\n		this.scribe.exitAlignment(conditionalExpressionAlignment, true);\r\n			\r\n		if (numberOfParens > 0) {\r\n			manageClosingParenthesizedExpression(conditionalExpression, numberOfParens);\r\n		}\r\n		return false;	\r\n	}\r\n\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.ConstructorDeclaration, org.eclipse.jdt.internal.compiler.lookup.ClassScope)\r\n	 */\r\n	public boolean visit(\r\n		ConstructorDeclaration constructorDeclaration,\r\n		ClassScope scope) {\r\n			\r\n		if (constructorDeclaration.modifiers != NO_MODIFIERS) {\r\n			this.scribe.printModifiers();\r\n		} else {\r\n			this.scribe.printComment();\r\n		}			\r\n		/*\r\n		 * Print the method name\r\n		 */	\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameIdentifier, true); \r\n\r\n		formatMethodArguments(\r\n			constructorDeclaration, \r\n			this.preferences.insert_space_before_method_declaration_open_paren,\r\n			this.preferences.insert_space_between_empty_arguments,\r\n			this.preferences.insert_space_before_closing_paren,\r\n			this.preferences.insert_space_before_first_argument,\r\n			this.preferences.insert_space_before_comma_in_constructor_arguments,\r\n			this.preferences.insert_space_after_comma_in_constructor_arguments);\r\n\r\n		formatThrowsClause(\r\n				constructorDeclaration,\r\n				this.preferences.insert_space_before_comma_in_constructor_throws,\r\n				this.preferences.insert_space_after_comma_in_constructor_throws);\r\n\r\n		if (!constructorDeclaration.isNative() && !constructorDeclaration.isAbstract()) {\r\n			/*\r\n			 * Method body\r\n			 */\r\n			String method_declaration_brace = this.preferences.method_declaration_brace_position;\r\n			formatOpeningBrace(method_declaration_brace, this.preferences.insert_space_before_method_open_brace);\r\n			this.scribe.indent();			\r\n			final int numberOfBlankLinesAtBeginningOfMethodBody = this.preferences.number_of_blank_lines_to_insert_at_beginning_of_method_body;\r\n			if (numberOfBlankLinesAtBeginningOfMethodBody > 0) {\r\n				this.scribe.printNewLines(numberOfBlankLinesAtBeginningOfMethodBody);\r\n			}\r\n			if (constructorDeclaration.constructorCall != null && !constructorDeclaration.constructorCall.isImplicitSuper()) {\r\n				this.scribe.printNewLine();\r\n				constructorDeclaration.constructorCall.traverse(this, constructorDeclaration.scope);\r\n				this.scribe.printNextToken(ITerminalSymbols.TokenNameSEMICOLON, this.preferences.insert_space_before_semicolon);\r\n				this.scribe.printTrailingComment();\r\n			}\r\n			final Statement[] statements = constructorDeclaration.statements;\r\n			if (statements != null) {\r\n				this.scribe.printNewLine();\r\n				formatStatements(constructorDeclaration.scope, statements);\r\n			} else if (this.preferences.insert_new_line_in_empty_method_body) {\r\n				this.scribe.printNewLine();\r\n			}\r\n			this.scribe.printComment();\r\n			this.scribe.unIndent();\r\n			this.scribe.printNextToken(ITerminalSymbols.TokenNameRBRACE);\r\n			this.scribe.printTrailingComment();\r\n			if (method_declaration_brace.equals(FormattingPreferences.NEXT_LINE_SHIFTED)) {\r\n				this.scribe.unIndent();\r\n			}\r\n		} else {\r\n			// no method body\r\n			this.scribe.printNextToken(ITerminalSymbols.TokenNameSEMICOLON, this.preferences.insert_space_before_semicolon);\r\n			this.scribe.printTrailingComment();\r\n		}\r\n		return false;\r\n	}\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.Continue, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(ContinueStatement continueStatement, BlockScope scope) {\r\n\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNamecontinue);\r\n		if (continueStatement.label != null) {\r\n			this.scribe.printNextToken(ITerminalSymbols.TokenNameIdentifier, true);\r\n		}\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameSEMICOLON, this.preferences.insert_space_before_semicolon);\r\n		return false;\r\n	}\r\n\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.DoStatement, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(DoStatement doStatement, BlockScope scope) {\r\n\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNamedo);\r\n		\r\n		final Statement action = doStatement.action;\r\n		if (action != null) {\r\n			if (action instanceof Block) {\r\n				action.traverse(this, scope);\r\n			} else {\r\n				this.scribe.printNewLine();\r\n				this.scribe.indent();\r\n				action.traverse(this, scope);\r\n				this.scribe.unIndent();\r\n			}\r\n			if (action instanceof Expression) {\r\n				this.scribe.printNextToken(ITerminalSymbols.TokenNameSEMICOLON, this.preferences.insert_space_before_semicolon);\r\n				this.scribe.printTrailingComment();\r\n			} else if (action instanceof Block && this.preferences.insert_new_line_in_control_statements) {\r\n				this.scribe.printTrailingComment();\r\n			}\r\n		} else {\r\n			this.scribe.indent();\r\n			/*\r\n			 * This is an empty statement\r\n			 */\r\n			formatEmptyStatement(); \r\n			this.scribe.unIndent();\r\n		}\r\n		\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNamewhile, this.preferences.insert_space_after_block_close_brace);\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameLPAREN, this.preferences.insert_space_before_while_condition);\r\n		\r\n		if (this.preferences.insert_space_in_while_condition) {\r\n			this.scribe.space();\r\n		}\r\n		\r\n		doStatement.condition.traverse(this, scope);\r\n		\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameRPAREN, this.preferences.insert_space_in_while_condition);\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameSEMICOLON, this.preferences.insert_space_before_semicolon);\r\n		return false;\r\n	}\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.DoubleLiteral, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(DoubleLiteral doubleLiteral, BlockScope scope) {\r\n\r\n		final int numberOfParens = (doubleLiteral.bits & AstNode.ParenthesizedMASK) >> AstNode.ParenthesizedSHIFT;\r\n		if (numberOfParens > 0) {\r\n			manageOpeningParenthesizedExpression(doubleLiteral, numberOfParens);\r\n		}\r\n		Constant constant = doubleLiteral.constant;\r\n		if (constant != null && constant.doubleValue() < 0) {\r\n			this.scribe.printNextToken(ITerminalSymbols.TokenNameMINUS);			\r\n		}\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameDoubleLiteral);\r\n\r\n		if (numberOfParens > 0) {\r\n			manageClosingParenthesizedExpression(doubleLiteral, numberOfParens);\r\n		}\r\n		return false;\r\n	}\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.EmptyStatement, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(EmptyStatement statement, BlockScope scope) {\r\n\r\n		formatEmptyStatement();\r\n		return false;	\r\n	}\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.EqualExpression, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(EqualExpression equalExpression, BlockScope scope) {\r\n\r\n		if ((equalExpression.bits & AstNode.OperatorMASK) >> AstNode.OperatorSHIFT == OperatorIds.EQUAL_EQUAL) {\r\n			return dumpBinaryExpression(equalExpression, ITerminalSymbols.TokenNameEQUAL_EQUAL, scope);\r\n		} else {\r\n			return dumpBinaryExpression(equalExpression, ITerminalSymbols.TokenNameNOT_EQUAL, scope);\r\n		}			\r\n	}\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.ExplicitConstructorCall, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(\r\n		ExplicitConstructorCall explicitConstructor,\r\n		BlockScope scope) {\r\n\r\n		if (explicitConstructor.isImplicitSuper()) {\r\n			return false;\r\n		}\r\n		final Expression qualification = explicitConstructor.qualification;\r\n		if (qualification != null) {\r\n			qualification.traverse(this, scope);\r\n		}\r\n\r\n		if (explicitConstructor.isSuperAccess()) {\r\n			this.scribe.printNextToken(ITerminalSymbols.TokenNamesuper);\r\n		} else {\r\n			this.scribe.printNextToken(ITerminalSymbols.TokenNamethis);\r\n		}\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameLPAREN, this.preferences.insert_space_before_message_send);\r\n		\r\n		final Expression[] arguments = explicitConstructor.arguments;\r\n		if (arguments != null) {\r\n			int argumentLength = arguments.length;\r\n			Alignment argumentsAlignment =this.scribe.createAlignment(\r\n					\"explicit_constructor_call\",//$NON-NLS-1$\r\n					this.preferences.explicit_constructor_arguments_alignment,\r\n					argumentLength,\r\n					this.scribe.scanner.currentPosition);\r\n			this.scribe.enterAlignment(argumentsAlignment);\r\n			boolean ok = false;\r\n			do {\r\n				try {\r\n					if (this.preferences.insert_space_within_message_send) {\r\n						this.scribe.space();\r\n					}\r\n					for (int i = 0; i < argumentLength; i++) {\r\n						if (i > 0) {\r\n							this.scribe.printNextToken(ITerminalSymbols.TokenNameCOMMA, this.preferences.insert_space_before_comma_in_explicitconstructorcall_arguments);\r\n						}\r\n						this.scribe.alignFragment(argumentsAlignment, i);\r\n						if (i > 0 && this.preferences.insert_space_after_comma_in_explicitconstructorcall_arguments) {\r\n							this.scribe.space();\r\n						}\r\n						arguments[i].traverse(this, scope);\r\n					}\r\n					ok = true;\r\n				} catch (AlignmentException e) {\r\n					this.scribe.redoAlignment(e);\r\n				}\r\n			} while (!ok);\r\n			this.scribe.exitAlignment(argumentsAlignment, true);\r\n			this.scribe.printNextToken(ITerminalSymbols.TokenNameRPAREN, this.preferences.insert_space_within_message_send); \r\n		} else {\r\n			this.scribe.printNextToken(ITerminalSymbols.TokenNameRPAREN, this.preferences.insert_space_between_empty_arguments); \r\n		}\r\n		return false;\r\n	}\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.FalseLiteral, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(FalseLiteral falseLiteral, BlockScope scope) {\r\n\r\n		final int numberOfParens = (falseLiteral.bits & AstNode.ParenthesizedMASK) >> AstNode.ParenthesizedSHIFT;\r\n		if (numberOfParens > 0) {\r\n			manageOpeningParenthesizedExpression(falseLiteral, numberOfParens);\r\n		}\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNamefalse);\r\n\r\n		if (numberOfParens > 0) {\r\n			manageClosingParenthesizedExpression(falseLiteral, numberOfParens);\r\n		}\r\n		return false;\r\n	}\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.FieldReference, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(FieldReference fieldReference, BlockScope scope) {\r\n\r\n		final int numberOfParens = (fieldReference.bits & AstNode.ParenthesizedMASK) >> AstNode.ParenthesizedSHIFT;\r\n		if (numberOfParens > 0) {\r\n			manageOpeningParenthesizedExpression(fieldReference, numberOfParens);\r\n		}\r\n		fieldReference.receiver.traverse(this, scope);\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameDOT);\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameIdentifier);\r\n		\r\n		if (numberOfParens > 0) {\r\n			manageClosingParenthesizedExpression(fieldReference, numberOfParens);\r\n		}\r\n		return false;\r\n	}\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.FloatLiteral, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(FloatLiteral floatLiteral, BlockScope scope) {\r\n\r\n		final int numberOfParens = (floatLiteral.bits & AstNode.ParenthesizedMASK) >> AstNode.ParenthesizedSHIFT;\r\n		if (numberOfParens > 0) {\r\n			manageOpeningParenthesizedExpression(floatLiteral, numberOfParens);\r\n		}\r\n		Constant constant = floatLiteral.constant;\r\n		if (constant != null && floatLiteral.constant.floatValue() < 0) {\r\n			this.scribe.printNextToken(ITerminalSymbols.TokenNameMINUS);			\r\n		}\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameFloatingPointLiteral);\r\n\r\n		if (numberOfParens > 0) {\r\n			manageClosingParenthesizedExpression(floatLiteral, numberOfParens);\r\n		}\r\n		return false;\r\n	}\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.ForStatement, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(ForStatement forStatement, BlockScope scope) {\r\n	\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNamefor);\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameLPAREN, this.preferences.insert_space_before_for_paren);\r\n		\r\n		if (this.preferences.insert_space_in_for_parens) {\r\n			this.scribe.space();\r\n		}\r\n		final Statement[] initializations = forStatement.initializations;\r\n		if (initializations != null) {\r\n			int length = initializations.length;\r\n			for (int i = 0; i < length; i++) {\r\n				initializations[i].traverse(this, scope);\r\n				if (i >= 0 && (i < length - 1) && !(initializations[i] instanceof LocalDeclaration)) {\r\n					this.scribe.printNextToken(ITerminalSymbols.TokenNameCOMMA, this.preferences.insert_space_before_comma_in_for_inits);\r\n					if (this.preferences.insert_space_after_comma_in_for_inits) {\r\n						this.scribe.space();\r\n					}\r\n				}				\r\n			}\r\n		}\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameSEMICOLON, this.preferences.insert_space_before_semicolon);\r\n		if (this.preferences.insert_space_after_semicolon_in_for) {\r\n			this.scribe.space();\r\n		}\r\n		final Expression condition = forStatement.condition;\r\n		if (condition != null) {\r\n			condition.traverse(this, scope);\r\n		}\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameSEMICOLON, this.preferences.insert_space_before_semicolon);\r\n		if (this.preferences.insert_space_after_semicolon_in_for) {\r\n			this.scribe.space();\r\n		}\r\n		final Statement[] increments = forStatement.increments;\r\n		if (increments != null) {\r\n			for (int i = 0, length = increments.length; i < length; i++) {\r\n				increments[i].traverse(this, scope);\r\n				if (i != length - 1) {\r\n					this.scribe.printNextToken(ITerminalSymbols.TokenNameCOMMA, this.preferences.insert_space_before_comma_in_for_increments);\r\n					if (this.preferences.insert_space_after_comma_in_for_increments) {\r\n						this.scribe.space();\r\n					}\r\n				}\r\n			}\r\n		}\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameRPAREN, this.preferences.insert_space_in_for_parens);\r\n		\r\n		final Statement action = forStatement.action;\r\n		if (action != null) {\r\n			if (action instanceof Block) {\r\n				action.traverse(this, scope);\r\n			} else {\r\n				this.scribe.indent();\r\n				this.scribe.printNewLine();\r\n				action.traverse(this, scope);\r\n				this.scribe.unIndent();\r\n			}\r\n			if (action instanceof Expression) {\r\n				this.scribe.printNextToken(ITerminalSymbols.TokenNameSEMICOLON, this.preferences.insert_space_before_semicolon);\r\n				this.scribe.printTrailingComment();\r\n				this.scribe.printNewLine();\r\n			} else if (action instanceof Block && this.preferences.insert_new_line_in_control_statements) {\r\n				this.scribe.printTrailingComment();\r\n				this.scribe.printNewLine();\r\n			}\r\n		} else {\r\n			this.scribe.indent();\r\n			/*\r\n			 * This is an empty statement\r\n			 */\r\n			formatEmptyStatement(); \r\n			this.scribe.unIndent();\r\n		}\r\n		return false;\r\n	}\r\n\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.IfStatement, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(IfStatement ifStatement, BlockScope scope) {\r\n\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameif);\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameLPAREN, this.preferences.insert_space_before_if_condition);\r\n		if (this.preferences.insert_space_in_if_condition) {\r\n			this.scribe.space();\r\n		}\r\n		ifStatement.condition.traverse(this, scope);\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameRPAREN, this.preferences.insert_space_in_if_condition);\r\n\r\n		final Statement thenStatement = ifStatement.thenStatement;\r\n		final Statement elseStatement = ifStatement.elseStatement;\r\n\r\n		if (thenStatement != null) {\r\n			if (thenStatement instanceof Block) {\r\n				if (isGuardClause((Block)thenStatement) && elseStatement == null && this.preferences.format_guardian_clause_on_one_line) {\r\n					/* \r\n					 * Need a specific formatting for guard clauses\r\n					 * guard clauses are block with a single return or throw\r\n					 * statement\r\n					 */\r\n					 formatGuardClauseBlock((Block) thenStatement, scope);\r\n				} else {\r\n					if (thenStatement instanceof Block) {\r\n						thenStatement.traverse(this, scope);\r\n					} else {\r\n						this.scribe.printNewLine();\r\n						this.scribe.indent();\r\n						thenStatement.traverse(this, scope);\r\n						this.scribe.unIndent();\r\n					}\r\n					if (elseStatement == null || this.preferences.insert_new_line_in_control_statements) {\r\n						this.scribe.printTrailingComment();\r\n					}\r\n				}\r\n			} else if (elseStatement == null && this.preferences.keep_simple_if_on_one_line) {\r\n				Alignment compactIfAlignment = this.scribe.createAlignment(\r\n					\"compactIf\", //$NON-NLS-1$\r\n					this.preferences.compact_if_alignment,\r\n					Alignment.R_OUTERMOST,\r\n					1, \r\n					this.scribe.scanner.currentPosition);\r\n				this.scribe.enterAlignment(compactIfAlignment);\r\n				boolean ok = false;\r\n				do {\r\n					try {\r\n						this.scribe.alignFragment(compactIfAlignment, 0);\r\n						this.scribe.space();\r\n						thenStatement.traverse(this, scope);\r\n						if (thenStatement instanceof Expression) {\r\n							this.scribe.printNextToken(ITerminalSymbols.TokenNameSEMICOLON, this.preferences.insert_space_before_semicolon);\r\n						}\r\n						ok = true;\r\n					} catch (AlignmentException e) {\r\n						this.scribe.redoAlignment(e);\r\n					}\r\n				} while (!ok);\r\n				this.scribe.exitAlignment(compactIfAlignment, true);				\r\n			} else if (this.preferences.keep_then_statement_on_same_line) {\r\n				this.scribe.space();\r\n				thenStatement.traverse(this, scope);\r\n				if (thenStatement instanceof Expression) {\r\n					this.scribe.printNextToken(ITerminalSymbols.TokenNameSEMICOLON, this.preferences.insert_space_before_semicolon);\r\n				}\r\n				this.scribe.printTrailingComment();\r\n				this.scribe.printNewLine();\r\n			} else {\r\n				this.scribe.printTrailingComment();\r\n				this.scribe.printNewLine();\r\n				this.scribe.indent();\r\n				thenStatement.traverse(this, scope);\r\n				if (thenStatement instanceof Expression) {\r\n					this.scribe.printNextToken(ITerminalSymbols.TokenNameSEMICOLON, this.preferences.insert_space_before_semicolon);\r\n				}\r\n				this.scribe.printTrailingComment();\r\n				this.scribe.printNewLine();\r\n				this.scribe.unIndent();\r\n			}\r\n		}\r\n		\r\n		if (elseStatement != null) {\r\n			this.scribe.printNextToken(ITerminalSymbols.TokenNameelse, true);\r\n			if (elseStatement instanceof Block) {\r\n				elseStatement.traverse(this, scope);\r\n			} else if (elseStatement instanceof IfStatement) {\r\n				if (!this.preferences.compact_else_if) {\r\n					this.scribe.printTrailingComment();\r\n					this.scribe.indent();\r\n				}\r\n				this.scribe.space();				\r\n				elseStatement.traverse(this, scope);\r\n				if (!this.preferences.compact_else_if) {\r\n					this.scribe.printTrailingComment();\r\n					this.scribe.unIndent();\r\n				}\r\n			} else if (this.preferences.keep_else_statement_on_same_line) {\r\n				this.scribe.space();\r\n				elseStatement.traverse(this, scope);\r\n				if (elseStatement instanceof Expression) {\r\n					this.scribe.printNextToken(ITerminalSymbols.TokenNameSEMICOLON, this.preferences.insert_space_before_semicolon);\r\n				}\r\n				this.scribe.printTrailingComment();\r\n				this.scribe.printNewLine();\r\n			} else {\r\n				this.scribe.printTrailingComment();\r\n				this.scribe.indent();\r\n				elseStatement.traverse(this, scope);\r\n				if (elseStatement instanceof Expression) {\r\n					this.scribe.printNextToken(ITerminalSymbols.TokenNameSEMICOLON, this.preferences.insert_space_before_semicolon);\r\n				}\r\n				this.scribe.printTrailingComment();\r\n				this.scribe.printNewLine();\r\n				this.scribe.unIndent();\r\n			}\r\n		}\r\n		return false;\r\n	}\r\n	\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.ImportReference, org.eclipse.jdt.internal.compiler.lookup.CompilationUnitScope)\r\n	 */\r\n	public boolean visit(\r\n		ImportReference importRef,\r\n		CompilationUnitScope scope) {\r\n		\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameimport);\r\n		this.scribe.space();\r\n		if (importRef.onDemand) {\r\n			this.scribe.printQualifiedReference(importRef.sourceEnd);\r\n			this.scribe.printNextToken(ITerminalSymbols.TokenNameDOT);\r\n			this.scribe.printNextToken(ITerminalSymbols.TokenNameMULTIPLY);			\r\n			this.scribe.printNextToken(ITerminalSymbols.TokenNameSEMICOLON, this.preferences.insert_space_before_semicolon);\r\n		} else {\r\n			this.scribe.printQualifiedReference(importRef.sourceEnd);\r\n			this.scribe.printNextToken(ITerminalSymbols.TokenNameSEMICOLON, this.preferences.insert_space_before_semicolon);\r\n		}\r\n		this.scribe.printTrailingComment();\r\n		this.scribe.printNewLine();\r\n		return false;\r\n	}\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.Initializer, org.eclipse.jdt.internal.compiler.lookup.MethodScope)\r\n	 */\r\n	public boolean visit(Initializer initializer, MethodScope scope) {\r\n\r\n		if (initializer.isStatic()) {\r\n			this.scribe.printNextToken(ITerminalSymbols.TokenNamestatic);\r\n		}\r\n		initializer.block.traverse(this, scope);\r\n		return false;\r\n	}\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.InstanceOfExpression, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(\r\n		InstanceOfExpression instanceOfExpression,\r\n		BlockScope scope) {\r\n\r\n		final int numberOfParens = (instanceOfExpression.bits & AstNode.ParenthesizedMASK) >> AstNode.ParenthesizedSHIFT;\r\n		if (numberOfParens > 0) {\r\n			manageOpeningParenthesizedExpression(instanceOfExpression, numberOfParens);\r\n		}\r\n		instanceOfExpression.expression.traverse(this, scope);\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameinstanceof, true);\r\n		this.scribe.space();\r\n		instanceOfExpression.type.traverse(this, scope);\r\n		\r\n		if (numberOfParens > 0) {\r\n			manageClosingParenthesizedExpression(instanceOfExpression, numberOfParens);\r\n		}\r\n		return false;\r\n	}\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.AbstractSyntaxTreeVisitorAdapter#visit(org.eclipse.jdt.internal.compiler.ast.IntLiteral, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(IntLiteral intLiteral, BlockScope scope) {\r\n\r\n		final int numberOfParens = (intLiteral.bits & AstNode.ParenthesizedMASK) >> AstNode.ParenthesizedSHIFT;\r\n		if (numberOfParens > 0) {\r\n			manageOpeningParenthesizedExpression(intLiteral, numberOfParens);\r\n		}\r\n		Constant constant = intLiteral.constant;\r\n		if (constant != null && constant.intValue() < 0) {\r\n			this.scribe.printNextToken(ITerminalSymbols.TokenNameMINUS);			\r\n		}\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameIntegerLiteral);\r\n\r\n		if (numberOfParens > 0) {\r\n			manageClosingParenthesizedExpression(intLiteral, numberOfParens);\r\n		}\r\n		return false;\r\n	}\r\n\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.LabeledStatement, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(LabeledStatement labeledStatement, BlockScope scope) {\r\n\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameIdentifier);\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameCOLON, this.preferences.insert_space_before_colon_in_labeled_statement);\r\n		if (this.preferences.insert_space_after_colon_in_labeled_statement) {\r\n			this.scribe.space();\r\n		}\r\n		labeledStatement.statement.traverse(this, scope);\r\n		return false;\r\n	}\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.LocalDeclaration, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(LocalDeclaration localDeclaration, BlockScope scope) {\r\n\r\n		if (!isMultipleLocalDeclaration(localDeclaration)) {\r\n			if (localDeclaration.modifiers != NO_MODIFIERS) {\r\n				this.scribe.printModifiers();\r\n				this.scribe.space();\r\n			}\r\n	\r\n			/*\r\n			 * Argument type \r\n			 */		\r\n			if (localDeclaration.type != null) {\r\n				localDeclaration.type.traverse(this, scope);\r\n			}\r\n		}\r\n		/*\r\n		 * Print the argument name\r\n		 */	\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameIdentifier, true); \r\n		/*\r\n		 * Check for extra dimensions\r\n		 */\r\n		int extraDimensions = getExtraDimension();\r\n		if (extraDimensions != 0) {\r\n			 for (int index = 0; index < extraDimensions; index++) {\r\n			 	this.scribe.printNextToken(ITerminalSymbols.TokenNameLBRACKET);\r\n			 	this.scribe.printNextToken(ITerminalSymbols.TokenNameRBRACKET);\r\n			 }\r\n		}\r\n	\r\n		if (localDeclaration.initialization != null) {\r\n			/*\r\n			 * Print the method name\r\n			 */	\r\n			this.scribe.printNextToken(ITerminalSymbols.TokenNameEQUAL, this.preferences.insert_space_before_assignment_operators);\r\n			if (this.preferences.insert_space_after_assignment_operators) {\r\n				this.scribe.space();\r\n			}			 \r\n			localDeclaration.initialization.traverse(this, scope);\r\n		}\r\n\r\n		if (isPartOfMultipleLocalDeclaration()) {\r\n			this.scribe.printNextToken(ITerminalSymbols.TokenNameCOMMA, this.preferences.insert_space_before_comma_in_multiple_local_declarations); \r\n			if (this.preferences.insert_space_after_comma_in_multiple_local_declarations) {\r\n				this.scribe.space();\r\n			}\r\n		}\r\n		return false;\r\n	}\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.LocalTypeDeclaration, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(\r\n		LocalTypeDeclaration localTypeDeclaration,\r\n		BlockScope scope) {\r\n\r\n			format(localTypeDeclaration);\r\n			return false;\r\n	}\r\n	\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.LongLiteral, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(LongLiteral longLiteral, BlockScope scope) {\r\n\r\n		final int numberOfParens = (longLiteral.bits & AstNode.ParenthesizedMASK) >> AstNode.ParenthesizedSHIFT;\r\n		if (numberOfParens > 0) {\r\n			manageOpeningParenthesizedExpression(longLiteral, numberOfParens);\r\n		}\r\n		Constant constant = longLiteral.constant;\r\n		if (constant != null && constant.longValue() < 0) {\r\n			this.scribe.printNextToken(ITerminalSymbols.TokenNameMINUS);			\r\n		}\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameLongLiteral);\r\n\r\n		if (numberOfParens > 0) {\r\n			manageClosingParenthesizedExpression(longLiteral, numberOfParens);\r\n		}\r\n		return false;\r\n	}\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.AbstractSyntaxTreeVisitorAdapter#visit(org.eclipse.jdt.internal.compiler.ast.MemberTypeDeclaration, org.eclipse.jdt.internal.compiler.lookup.ClassScope)\r\n	 */\r\n	public boolean visit(MemberTypeDeclaration memberTypeDeclaration, ClassScope scope) {\r\n		Alignment memberTypeAlignment = this.scribe.getAlignment(\"typeMembers\");		//$NON-NLS-1$\r\n		format(memberTypeDeclaration);\r\n		this.scribe.exitAlignment(memberTypeAlignment, false);		\r\n		return false;\r\n	}\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.MessageSend, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(MessageSend messageSend, BlockScope scope) {\r\n\r\n		final int numberOfParens = (messageSend.bits & AstNode.ParenthesizedMASK) >> AstNode.ParenthesizedSHIFT;\r\n		if (numberOfParens > 0) {\r\n			manageOpeningParenthesizedExpression(messageSend, numberOfParens);\r\n		}\r\n		Alignment messageAlignment = null;\r\n		if (!messageSend.receiver.isImplicitThis()) {\r\n			messageSend.receiver.traverse(this, scope);\r\n			messageAlignment = this.scribe.createAlignment(\r\n					\"messageAlignment\", //$NON-NLS-1$\r\n					this.preferences.message_send_selector_alignment,\r\n					1,\r\n					this.scribe.scanner.currentPosition);\r\n			this.scribe.enterAlignment(messageAlignment);\r\n			boolean ok = false;\r\n			do {\r\n				try {\r\n					formatMessageSend(messageSend, scope, messageAlignment);\r\n					ok = true;\r\n				} catch (AlignmentException e) {\r\n					this.scribe.redoAlignment(e);\r\n				}\r\n			} while (!ok);\r\n			this.scribe.exitAlignment(messageAlignment, true);\r\n		} else {\r\n			formatMessageSend(messageSend, scope, null);			\r\n		}\r\n		if (numberOfParens > 0) {\r\n			manageClosingParenthesizedExpression(messageSend, numberOfParens);\r\n		}\r\n		return false;\r\n	}\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.MethodDeclaration, org.eclipse.jdt.internal.compiler.lookup.ClassScope)\r\n	 */\r\n	public boolean visit(\r\n		MethodDeclaration methodDeclaration,\r\n		ClassScope scope) {\r\n\r\n		if (methodDeclaration.modifiers != NO_MODIFIERS) {\r\n			this.scribe.printModifiers();\r\n			this.scribe.space();\r\n		}\r\n		\r\n		/*\r\n		 * Print the method return type\r\n		 */	\r\n		final TypeReference returnType = methodDeclaration.returnType;\r\n		final MethodScope methodDeclarationScope = methodDeclaration.scope;\r\n		\r\n		if (returnType != null) {\r\n			returnType.traverse(this, methodDeclarationScope);\r\n		}\r\n		/*\r\n		 * Print the method name\r\n		 */\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameIdentifier, true); \r\n\r\n		/*\r\n		 * Check for extra dimensions\r\n		 */\r\n		int extraDimensions = getExtraDimension();\r\n		if (extraDimensions != 0) {\r\n			 for (int i = 0; i < extraDimensions; i++) {\r\n			 	this.scribe.printNextToken(ITerminalSymbols.TokenNameLBRACKET);\r\n			 	this.scribe.printNextToken(ITerminalSymbols.TokenNameRBRACKET);\r\n			 }\r\n		}\r\n\r\n		formatMethodArguments(\r\n			methodDeclaration, \r\n			this.preferences.insert_space_before_method_declaration_open_paren,\r\n			this.preferences.insert_space_between_empty_arguments,\r\n			this.preferences.insert_space_before_closing_paren,\r\n			this.preferences.insert_space_before_first_argument,\r\n			this.preferences.insert_space_before_comma_in_method_arguments,\r\n			this.preferences.insert_space_after_comma_in_method_arguments);\r\n\r\n		formatThrowsClause(\r\n			methodDeclaration,\r\n			this.preferences.insert_space_before_comma_in_method_throws,\r\n			this.preferences.insert_space_after_comma_in_method_throws);\r\n\r\n		if (!methodDeclaration.isNative() && !methodDeclaration.isAbstract() && ((methodDeclaration.modifiers & CompilerModifiers.AccSemicolonBody) == 0)) {\r\n			/*\r\n			 * Method body\r\n			 */\r\n			String method_declaration_brace = this.preferences.method_declaration_brace_position;\r\n			formatOpeningBrace(method_declaration_brace, this.preferences.insert_space_before_method_open_brace);\r\n			this.scribe.indent();			\r\n			final int numberOfBlankLinesAtBeginningOfMethodBody = this.preferences.number_of_blank_lines_to_insert_at_beginning_of_method_body;\r\n			if (numberOfBlankLinesAtBeginningOfMethodBody > 0) {\r\n				this.scribe.printNewLines(numberOfBlankLinesAtBeginningOfMethodBody);\r\n			}\r\n			final Statement[] statements = methodDeclaration.statements;\r\n			if (statements != null) {\r\n				this.scribe.printNewLine();\r\n				formatStatements(methodDeclarationScope, statements);\r\n			} else if (this.preferences.insert_new_line_in_empty_method_body) {\r\n				this.scribe.printNewLine();\r\n			}\r\n			this.scribe.printComment();\r\n			this.scribe.unIndent();\r\n			this.scribe.printNextToken(ITerminalSymbols.TokenNameRBRACE);\r\n			this.scribe.printTrailingComment();\r\n			this.scribe.printNewLine();\r\n			if (method_declaration_brace.equals(FormattingPreferences.NEXT_LINE_SHIFTED)) {\r\n				this.scribe.unIndent();\r\n			}\r\n		} else {\r\n			// no method body\r\n			this.scribe.printNextToken(ITerminalSymbols.TokenNameSEMICOLON, this.preferences.insert_space_before_semicolon);\r\n			this.scribe.printTrailingComment();\r\n			this.scribe.printNewLine();\r\n		}\r\n		return false;\r\n	}\r\n	\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.NullLiteral, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(NullLiteral nullLiteral, BlockScope scope) {\r\n\r\n		final int numberOfParens = (nullLiteral.bits & AstNode.ParenthesizedMASK) >> AstNode.ParenthesizedSHIFT;\r\n		if (numberOfParens > 0) {\r\n			manageOpeningParenthesizedExpression(nullLiteral, numberOfParens);\r\n		}\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNamenull);\r\n\r\n		if (numberOfParens > 0) {\r\n			manageClosingParenthesizedExpression(nullLiteral, numberOfParens);\r\n		}\r\n		return false;\r\n	}\r\n\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.OR_OR_Expression, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(OR_OR_Expression or_or_Expression, BlockScope scope) {\r\n\r\n		return dumpBinaryExpression(or_or_Expression, ITerminalSymbols.TokenNameOR_OR, scope);\r\n	}\r\n	\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.PostfixExpression, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(\r\n		PostfixExpression postfixExpression,\r\n		BlockScope scope) {\r\n\r\n		final int numberOfParens = (postfixExpression.bits & AstNode.ParenthesizedMASK) >> AstNode.ParenthesizedSHIFT;\r\n		if (numberOfParens > 0) {\r\n			manageOpeningParenthesizedExpression(postfixExpression, numberOfParens);\r\n		}\r\n		postfixExpression.lhs.traverse(this, scope);\r\n		int operator = postfixExpression.operator == OperatorIds.PLUS \r\n			? ITerminalSymbols.TokenNamePLUS_PLUS : ITerminalSymbols.TokenNameMINUS_MINUS;\r\n		this.scribe.printNextToken(operator, this.preferences.insert_space_before_postfix_operator);\r\n		if (this.preferences.insert_space_after_postfix_operator) {\r\n			this.scribe.space();\r\n		}\r\n		if (numberOfParens > 0) {\r\n			manageClosingParenthesizedExpression(postfixExpression, numberOfParens);\r\n		}\r\n		return false;\r\n	}\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.PrefixExpression, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(PrefixExpression prefixExpression, BlockScope scope) {\r\n\r\n		final int numberOfParens = (prefixExpression.bits & AstNode.ParenthesizedMASK) >> AstNode.ParenthesizedSHIFT;\r\n		if (numberOfParens > 0) {\r\n			manageOpeningParenthesizedExpression(prefixExpression, numberOfParens);\r\n		}\r\n		int operator = prefixExpression.operator == OperatorIds.PLUS \r\n			? ITerminalSymbols.TokenNamePLUS_PLUS : ITerminalSymbols.TokenNameMINUS_MINUS;\r\n		this.scribe.printNextToken(operator, this.preferences.insert_space_before_prefix_operator);\r\n		prefixExpression.lhs.traverse(this, scope);\r\n		if (this.preferences.insert_space_after_prefix_operator) {\r\n			this.scribe.space();\r\n		}\r\n		if (numberOfParens > 0) {\r\n			manageClosingParenthesizedExpression(prefixExpression, numberOfParens);\r\n		}\r\n		return false;\r\n	}\r\n	\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.QualifiedAllocationExpression, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(\r\n		QualifiedAllocationExpression qualifiedAllocationExpression,\r\n		BlockScope scope) {\r\n			\r\n		final int numberOfParens = (qualifiedAllocationExpression.bits & AstNode.ParenthesizedMASK) >> AstNode.ParenthesizedSHIFT;\r\n		if (numberOfParens > 0) {\r\n			manageOpeningParenthesizedExpression(qualifiedAllocationExpression, numberOfParens);\r\n		}\r\n		final Expression enclosingInstance = qualifiedAllocationExpression.enclosingInstance;\r\n		if (enclosingInstance != null) {\r\n			enclosingInstance.traverse(this, scope);\r\n			this.scribe.printNextToken(ITerminalSymbols.TokenNameDOT);\r\n		}\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNamenew);\r\n		this.scribe.space();\r\n		qualifiedAllocationExpression.type.traverse(this, scope);\r\n		\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameLPAREN, this.preferences.insert_space_before_message_send);\r\n\r\n		final Expression[] arguments = qualifiedAllocationExpression.arguments;\r\n		if (arguments != null) {\r\n			int argumentLength = arguments.length;\r\n			Alignment argumentsAlignment =this.scribe.createAlignment(\r\n					\"allocation\",//$NON-NLS-1$\r\n					this.preferences.qualified_allocation_expression_arguments_alignment,\r\n					argumentLength,\r\n					this.scribe.scanner.currentPosition);\r\n			this.scribe.enterAlignment(argumentsAlignment);\r\n			boolean ok = false;\r\n			do {\r\n				try {\r\n					if (this.preferences.insert_space_within_message_send) {\r\n						this.scribe.space();\r\n					}\r\n					for (int i = 0; i < argumentLength; i++) {\r\n						if (i > 0) {\r\n							this.scribe.printNextToken(ITerminalSymbols.TokenNameCOMMA, this.preferences.insert_space_before_comma_in_allocation_expression);\r\n						}\r\n						this.scribe.alignFragment(argumentsAlignment, i);\r\n						if (i > 0 && this.preferences.insert_space_after_comma_in_allocation_expression) {\r\n							this.scribe.space();\r\n						}\r\n						arguments[i].traverse(this, scope);\r\n					}\r\n					ok = true;\r\n				} catch (AlignmentException e) {\r\n					this.scribe.redoAlignment(e);\r\n				}\r\n			} while (!ok);\r\n			this.scribe.exitAlignment(argumentsAlignment, true);\r\n			this.scribe.printNextToken(ITerminalSymbols.TokenNameRPAREN, this.preferences.insert_space_within_message_send); \r\n		} else {\r\n			this.scribe.printNextToken(ITerminalSymbols.TokenNameRPAREN, this.preferences.insert_space_between_empty_arguments); \r\n		}\r\n		final AnonymousLocalTypeDeclaration anonymousType = qualifiedAllocationExpression.anonymousType;\r\n		if (anonymousType != null) {\r\n			anonymousType.traverse(this, scope);\r\n		}\r\n		if (numberOfParens > 0) {\r\n			manageClosingParenthesizedExpression(qualifiedAllocationExpression, numberOfParens);\r\n		}\r\n		return false;\r\n	}\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.QualifiedNameReference, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(\r\n		QualifiedNameReference qualifiedNameReference,\r\n		BlockScope scope) {\r\n\r\n		final int numberOfParens = (qualifiedNameReference.bits & AstNode.ParenthesizedMASK) >> AstNode.ParenthesizedSHIFT;\r\n		if (numberOfParens > 0) {\r\n			manageOpeningParenthesizedExpression(qualifiedNameReference, numberOfParens);\r\n		}\r\n		this.scribe.printQualifiedReference(qualifiedNameReference.sourceEnd);\r\n\r\n		if (numberOfParens > 0) {\r\n			manageClosingParenthesizedExpression(qualifiedNameReference, numberOfParens);\r\n		}\r\n		return false;\r\n	}\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.QualifiedSuperReference, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(\r\n		QualifiedSuperReference qualifiedSuperReference,\r\n		BlockScope scope) {\r\n\r\n		final int numberOfParens = (qualifiedSuperReference.bits & AstNode.ParenthesizedMASK) >> AstNode.ParenthesizedSHIFT;\r\n		if (numberOfParens > 0) {\r\n			manageOpeningParenthesizedExpression(qualifiedSuperReference, numberOfParens);\r\n		}\r\n		qualifiedSuperReference.qualification.traverse(this, scope);\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameDOT);\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNamesuper);\r\n		\r\n		if (numberOfParens > 0) {\r\n			manageClosingParenthesizedExpression(qualifiedSuperReference, numberOfParens);\r\n		}\r\n		return false;\r\n	}\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.QualifiedThisReference, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(\r\n		QualifiedThisReference qualifiedThisReference,\r\n		BlockScope scope) {\r\n\r\n		final int numberOfParens = (qualifiedThisReference.bits & AstNode.ParenthesizedMASK) >> AstNode.ParenthesizedSHIFT;\r\n		if (numberOfParens > 0) {\r\n			manageOpeningParenthesizedExpression(qualifiedThisReference, numberOfParens);\r\n		}\r\n		qualifiedThisReference.qualification.traverse(this, scope);\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameDOT);\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNamethis);\r\n		\r\n		if (numberOfParens > 0) {\r\n			manageClosingParenthesizedExpression(qualifiedThisReference, numberOfParens);\r\n		}\r\n		return false;\r\n	}\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.QualifiedTypeReference, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(\r\n		QualifiedTypeReference qualifiedTypeReference,\r\n		BlockScope scope) {\r\n\r\n		final int numberOfParens = (qualifiedTypeReference.bits & AstNode.ParenthesizedMASK) >> AstNode.ParenthesizedSHIFT;\r\n		if (numberOfParens > 0) {\r\n			manageOpeningParenthesizedExpression(qualifiedTypeReference, numberOfParens);\r\n		}\r\n		this.scribe.printQualifiedReference(qualifiedTypeReference.sourceEnd + 1);\r\n		\r\n		if (numberOfParens > 0) {\r\n			manageClosingParenthesizedExpression(qualifiedTypeReference, numberOfParens);\r\n		}\r\n		return false;\r\n	}\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.QualifiedTypeReference, org.eclipse.jdt.internal.compiler.lookup.ClassScope)\r\n	 */\r\n	public boolean visit(\r\n		QualifiedTypeReference qualifiedTypeReference,\r\n		ClassScope scope) {\r\n\r\n			final int numberOfParens = (qualifiedTypeReference.bits & AstNode.ParenthesizedMASK) >> AstNode.ParenthesizedSHIFT;\r\n			if (numberOfParens > 0) {\r\n				manageOpeningParenthesizedExpression(qualifiedTypeReference, numberOfParens);\r\n			}\r\n			this.scribe.printQualifiedReference(qualifiedTypeReference.sourceEnd + 1);\r\n			\r\n			if (numberOfParens > 0) {\r\n				manageClosingParenthesizedExpression(qualifiedTypeReference, numberOfParens);\r\n			}\r\n			return false;\r\n	}\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.ReturnStatement, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(ReturnStatement returnStatement, BlockScope scope) {\r\n		\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNamereturn);\r\n		final Expression expression = returnStatement.expression;\r\n		if (expression != null) {\r\n			this.scribe.space();\r\n			expression.traverse(this, scope);\r\n		}\r\n		/*\r\n		 * Print the semi-colon\r\n		 */	\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameSEMICOLON, this.preferences.insert_space_before_semicolon);\r\n		return false;\r\n	}\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.AbstractSyntaxTreeVisitorAdapter#visit(org.eclipse.jdt.internal.compiler.ast.SingleNameReference, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(SingleNameReference singleNameReference, BlockScope scope) {\r\n\r\n		final int numberOfParens = (singleNameReference.bits & AstNode.ParenthesizedMASK) >> AstNode.ParenthesizedSHIFT;\r\n		if (numberOfParens > 0) {\r\n			manageOpeningParenthesizedExpression(singleNameReference, numberOfParens);\r\n		}\r\n		this.scribe.printNextToken(SINGLETYPEREFERENCE_EXPECTEDTOKENS, false, true);\r\n		\r\n		if (numberOfParens > 0) {\r\n			manageClosingParenthesizedExpression(singleNameReference, numberOfParens);\r\n		}\r\n		return false;\r\n	}\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.SingleTypeReference, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(\r\n		SingleTypeReference singleTypeReference,\r\n		BlockScope scope) {\r\n\r\n		final int numberOfParens = (singleTypeReference.bits & AstNode.ParenthesizedMASK) >> AstNode.ParenthesizedSHIFT;\r\n		if (numberOfParens > 0) {\r\n			manageOpeningParenthesizedExpression(singleTypeReference, numberOfParens);\r\n		}\r\n		this.scribe.printNextToken(SINGLETYPEREFERENCE_EXPECTEDTOKENS, false, true);\r\n\r\n		if (numberOfParens > 0) {\r\n			manageClosingParenthesizedExpression(singleTypeReference, numberOfParens);\r\n		}\r\n		return false;\r\n	}\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.SingleTypeReference, org.eclipse.jdt.internal.compiler.lookup.ClassScope)\r\n	 */\r\n	public boolean visit(\r\n		SingleTypeReference singleTypeReference,\r\n		ClassScope scope) {\r\n\r\n		final int numberOfParens = (singleTypeReference.bits & AstNode.ParenthesizedMASK) >> AstNode.ParenthesizedSHIFT;\r\n		if (numberOfParens > 0) {\r\n			manageOpeningParenthesizedExpression(singleTypeReference, numberOfParens);\r\n		}\r\n		this.scribe.printNextToken(SINGLETYPEREFERENCE_EXPECTEDTOKENS, false, true);\r\n\r\n		if (numberOfParens > 0) {\r\n			manageClosingParenthesizedExpression(singleTypeReference, numberOfParens);\r\n		}\r\n		return false;\r\n	}\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.StringLiteral, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(StringLiteral stringLiteral, BlockScope scope) {\r\n\r\n		final int numberOfParens = (stringLiteral.bits & AstNode.ParenthesizedMASK) >> AstNode.ParenthesizedSHIFT;\r\n		if (numberOfParens > 0) {\r\n			manageOpeningParenthesizedExpression(stringLiteral, numberOfParens);\r\n		}\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameStringLiteral);\r\n		\r\n		if (numberOfParens > 0) {\r\n			manageClosingParenthesizedExpression(stringLiteral, numberOfParens);\r\n		}\r\n		return false;\r\n	}\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.SuperReference, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(SuperReference superReference, BlockScope scope) {\r\n\r\n		final int numberOfParens = (superReference.bits & AstNode.ParenthesizedMASK) >> AstNode.ParenthesizedSHIFT;\r\n		if (numberOfParens > 0) {\r\n			manageOpeningParenthesizedExpression(superReference, numberOfParens);\r\n		}\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNamesuper);\r\n\r\n		if (numberOfParens > 0) {\r\n			manageClosingParenthesizedExpression(superReference, numberOfParens);\r\n		}\r\n		return false;\r\n	}\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.SwitchStatement, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(SwitchStatement switchStatement, BlockScope scope) {\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameswitch);\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameLPAREN, this.preferences.insert_space_before_switch_condition);\r\n		\r\n		if (this.preferences.insert_space_in_switch_condition) {\r\n			this.scribe.space();\r\n		}\r\n		\r\n		switchStatement.testExpression.traverse(this, scope);\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameRPAREN, this.preferences.insert_space_in_switch_condition);\r\n		/*\r\n		 * Type body\r\n		 */\r\n		String switch_brace = this.preferences.switch_brace_position;\r\n		formatOpeningBrace(switch_brace, this.preferences.insert_space_before_switch_open_brace);\r\n		this.scribe.printNewLine();\r\n\r\n		if (preferences.indent_switchstatements_compare_to_switch) {\r\n			this.scribe.indent();\r\n		}\r\n		final Statement[] statements = switchStatement.statements;\r\n		if (statements != null) {\r\n			int statementsLength = statements.length;\r\n			boolean wasABreak = false;\r\n			for (int i = 0; i < statementsLength; i++) {\r\n				final Statement statement = statements[i];\r\n				if (i == 0) {\r\n					// this is a case or a default statement\r\n					statement.traverse(this, scope);\r\n					if (this.preferences.indent_switchstatements_compare_to_cases) {\r\n						this.scribe.indent();\r\n					}\r\n				} else if (statement instanceof CaseStatement) {\r\n					if (wasABreak) {\r\n						if (this.preferences.indent_breaks_compare_to_cases) {\r\n							this.scribe.unIndent();\r\n						}\r\n					} else if (this.preferences.indent_switchstatements_compare_to_cases) {\r\n						this.scribe.unIndent();\r\n					}\r\n					statement.traverse(this, scope);\r\n					wasABreak = false;\r\n					if (this.preferences.indent_switchstatements_compare_to_cases) {\r\n						this.scribe.indent();\r\n					}\r\n				} else if (statement instanceof BreakStatement) {\r\n					wasABreak = true;\r\n					if (this.preferences.indent_switchstatements_compare_to_cases) {\r\n						if (!this.preferences.indent_breaks_compare_to_cases) {\r\n							this.scribe.unIndent();\r\n						}\r\n					} else if (this.preferences.indent_breaks_compare_to_cases) {\r\n						this.scribe.indent();\r\n					}\r\n					statement.traverse(this, scope);\r\n					if (i == statementsLength - 1 && this.preferences.indent_breaks_compare_to_cases) {\r\n						this.scribe.unIndent();\r\n					}\r\n				} else {\r\n					wasABreak = false;\r\n					statement.traverse(this, scope);\r\n					if (i == statementsLength - 1 && this.preferences.indent_switchstatements_compare_to_cases) {\r\n						this.scribe.unIndent();\r\n					}\r\n				}\r\n				if (statement instanceof Expression) {\r\n					/*\r\n					 * Print the semi-colon\r\n					 */	\r\n					this.scribe.printNextToken(ITerminalSymbols.TokenNameSEMICOLON, this.preferences.insert_space_before_semicolon);\r\n					this.scribe.printTrailingComment();\r\n				} else if (statement instanceof LocalDeclaration) {\r\n					LocalDeclaration currentLocal = (LocalDeclaration) statement;\r\n					if (i < (statementsLength - 1)) {\r\n						/* \r\n						 * We need to check that the next statement is a local declaration\r\n						 */\r\n						if (statements[i + 1] instanceof LocalDeclaration) {\r\n							LocalDeclaration nextLocal = (LocalDeclaration) statements[i + 1];\r\n							if (currentLocal.declarationSourceStart != nextLocal.declarationSourceStart) {\r\n								/*\r\n								 * Print the semi-colon\r\n								 */	\r\n								this.scribe.printNextToken(ITerminalSymbols.TokenNameSEMICOLON, this.preferences.insert_space_before_semicolon);\r\n								this.scribe.printTrailingComment();\r\n							}\r\n						} else {\r\n							/*\r\n							 * Print the semi-colon\r\n							 */	\r\n							this.scribe.printNextToken(ITerminalSymbols.TokenNameSEMICOLON, this.preferences.insert_space_before_semicolon);\r\n							this.scribe.printTrailingComment();\r\n						}\r\n					} else {\r\n						/*\r\n						 * Print the semi-colon\r\n						 */	\r\n						this.scribe.printNextToken(ITerminalSymbols.TokenNameSEMICOLON, this.preferences.insert_space_before_semicolon);\r\n						this.scribe.printTrailingComment();\r\n					}\r\n				} else {\r\n					this.scribe.printTrailingComment();\r\n				}\r\n				this.scribe.printNewLine();\r\n			}\r\n		}		\r\n		\r\n		if (preferences.indent_switchstatements_compare_to_switch) {\r\n			this.scribe.unIndent();\r\n		}\r\n		this.scribe.printNewLine();\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameRBRACE);\r\n		this.scribe.printTrailingComment();\r\n		if (switch_brace.equals(FormattingPreferences.NEXT_LINE_SHIFTED)) {\r\n			this.scribe.unIndent();\r\n		}		\r\n		return false;\r\n	}\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.SynchronizedStatement, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(\r\n		SynchronizedStatement synchronizedStatement,\r\n		BlockScope scope) {\r\n		\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNamesynchronized);\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameLPAREN, this.preferences.insert_space_before_synchronized_condition);\r\n		\r\n		if (this.preferences.insert_space_in_synchronized_condition) {\r\n			this.scribe.space();\r\n		}\r\n		synchronizedStatement.expression.traverse(this, scope);\r\n	\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameRPAREN, this.preferences.insert_space_in_synchronized_condition);\r\n		\r\n		synchronizedStatement.block.traverse(this, scope);\r\n		this.scribe.printTrailingComment();\r\n		return false;\r\n	}\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.ThisReference, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(ThisReference thisReference, BlockScope scope) {\r\n		\r\n		if (!thisReference.isImplicitThis()) {\r\n			final int numberOfParens = (thisReference.bits & AstNode.ParenthesizedMASK) >> AstNode.ParenthesizedSHIFT;\r\n			if (numberOfParens > 0) {\r\n				manageOpeningParenthesizedExpression(thisReference, numberOfParens);\r\n			}\r\n			this.scribe.printNextToken(ITerminalSymbols.TokenNamethis);\r\n			\r\n			if (numberOfParens > 0) {\r\n				manageClosingParenthesizedExpression(thisReference, numberOfParens);\r\n			}\r\n		}\r\n		return false;\r\n	}\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.ThrowStatement, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(ThrowStatement throwStatement, BlockScope scope) {\r\n\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNamethrow);\r\n		this.scribe.space();\r\n		throwStatement.exception.traverse(this, scope);\r\n		/*\r\n		 * Print the semi-colon\r\n		 */	\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameSEMICOLON, this.preferences.insert_space_before_semicolon);\r\n		return false;\r\n	}\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.TrueLiteral, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(TrueLiteral trueLiteral, BlockScope scope) {\r\n\r\n		final int numberOfParens = (trueLiteral.bits & AstNode.ParenthesizedMASK) >> AstNode.ParenthesizedSHIFT;\r\n		if (numberOfParens > 0) {\r\n			manageOpeningParenthesizedExpression(trueLiteral, numberOfParens);\r\n		}\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNametrue);\r\n\r\n		if (numberOfParens > 0) {\r\n			manageClosingParenthesizedExpression(trueLiteral, numberOfParens);\r\n		}\r\n		return false;\r\n	}\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.TryStatement, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(TryStatement tryStatement, BlockScope scope) {\r\n\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNametry);\r\n		tryStatement.tryBlock.traverse(this, scope);\r\n		if (this.preferences.insert_new_line_in_control_statements) {\r\n			this.scribe.printTrailingComment();\r\n		}	\r\n		if (tryStatement.catchArguments != null) {\r\n			for (int i = 0, max = tryStatement.catchBlocks.length; i < max; i++) {\r\n				this.scribe.printNextToken(ITerminalSymbols.TokenNamecatch, this.preferences.insert_space_after_block_close_brace);\r\n				this.scribe.printNextToken(ITerminalSymbols.TokenNameLPAREN, this.preferences.insert_space_before_catch_expression);\r\n				\r\n				if (this.preferences.insert_space_in_catch_expression) {\r\n					this.scribe.space();\r\n				}\r\n				\r\n				tryStatement.catchArguments[i].traverse(this, scope);\r\n			\r\n				this.scribe.printNextToken(ITerminalSymbols.TokenNameRPAREN, this.preferences.insert_space_in_catch_expression);\r\n				\r\n				tryStatement.catchBlocks[i].traverse(this, scope);\r\n				if (this.preferences.insert_new_line_in_control_statements) {\r\n					this.scribe.printTrailingComment();\r\n				}	\r\n			}\r\n		}\r\n		if (tryStatement.finallyBlock != null) {\r\n			this.scribe.printNextToken(ITerminalSymbols.TokenNamefinally, this.preferences.insert_space_after_block_close_brace);\r\n			tryStatement.finallyBlock.traverse(this, scope);\r\n			if (this.preferences.insert_new_line_in_control_statements) {\r\n				this.scribe.printTrailingComment();\r\n			}	\r\n		}\r\n		return false;\r\n	}\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.TypeDeclaration, org.eclipse.jdt.internal.compiler.lookup.CompilationUnitScope)\r\n	 */\r\n	public boolean visit(\r\n		TypeDeclaration typeDeclaration,\r\n		CompilationUnitScope scope) {\r\n\r\n		format(typeDeclaration);\r\n		return false;\r\n	}\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.UnaryExpression, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(UnaryExpression unaryExpression, BlockScope scope) {\r\n\r\n		final int numberOfParens = (unaryExpression.bits & AstNode.ParenthesizedMASK) >> AstNode.ParenthesizedSHIFT;\r\n		if (numberOfParens > 0) {\r\n			manageOpeningParenthesizedExpression(unaryExpression, numberOfParens);\r\n		}\r\n\r\n		/*\r\n		 * Print the operator\r\n		 */\r\n		int operator;\r\n		switch((unaryExpression.bits & AstNode.OperatorMASK) >> AstNode.OperatorSHIFT) {\r\n			case OperatorIds.PLUS:\r\n				operator = ITerminalSymbols.TokenNamePLUS;\r\n				break;\r\n			case OperatorIds.MINUS:\r\n				operator = ITerminalSymbols.TokenNameMINUS;\r\n				break;\r\n			case OperatorIds.TWIDDLE:\r\n				operator = ITerminalSymbols.TokenNameTWIDDLE;\r\n				break;\r\n			default:\r\n				operator = ITerminalSymbols.TokenNameNOT;\r\n		}\r\n\r\n		if (operator == ITerminalSymbols.TokenNameMINUS) {\r\n			this.scribe.printNextToken(operator, true);\r\n		} else {\r\n			this.scribe.printNextToken(operator, this.preferences.insert_space_before_unary_operator);\r\n		}\r\n		if (this.preferences.insert_space_after_unary_operator) {\r\n			this.scribe.space();\r\n		}\r\n		unaryExpression.expression.traverse(this, scope);\r\n\r\n		if (numberOfParens > 0) {\r\n			manageClosingParenthesizedExpression(unaryExpression, numberOfParens);\r\n		}\r\n		return false;\r\n	}\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.WhileStatement, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(WhileStatement whileStatement, BlockScope scope) {\r\n\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNamewhile);\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameLPAREN, this.preferences.insert_space_before_while_condition);\r\n		\r\n		if (this.preferences.insert_space_in_while_condition) {\r\n			this.scribe.space();\r\n		}\r\n		whileStatement.condition.traverse(this, scope);\r\n		\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameRPAREN, this.preferences.insert_space_in_while_condition);\r\n		\r\n		final Statement action = whileStatement.action;\r\n		if (action != null) {\r\n			if (action instanceof Block) {\r\n				action.traverse(this, scope);\r\n			} else {\r\n				this.scribe.printNewLine();\r\n				this.scribe.indent();\r\n				action.traverse(this, scope);\r\n				this.scribe.unIndent();\r\n			}\r\n			if (action instanceof Expression) {\r\n				this.scribe.printNextToken(ITerminalSymbols.TokenNameSEMICOLON, this.preferences.insert_space_before_semicolon);\r\n				this.scribe.printTrailingComment();\r\n			} else if (action instanceof Block) {\r\n				this.scribe.printTrailingComment();\r\n			}		\r\n		} else {\r\n			this.scribe.indent();\r\n			/*\r\n			 * This is an empty statement\r\n			 */\r\n			formatEmptyStatement(); \r\n			this.scribe.unIndent();\r\n		}\r\n\r\n		return false;\r\n	}\r\n}\r\n/*******************************************************************************\r\n * Copyright (c) 2002, 2003 International Business Machines Corp. and others.\r\n * All rights reserved. This program and the accompanying materials \r\n * are made available under the terms of the Common Public License v1.0 \r\n * which accompanies this distribution, and is available at\r\n * http://www.eclipse.org/legal/cpl-v10.html\r\n * \r\n * Contributors:\r\n *     IBM Corporation - initial API and implementation\r\n ******************************************************************************/\r\npackage org.eclipse.jdt.internal.formatter;\r\n\r\nimport java.util.Map;\r\n\r\nimport org.eclipse.jdt.core.JavaCore;\r\nimport org.eclipse.jdt.core.ToolFactory;\r\nimport org.eclipse.jdt.core.compiler.IProblem;\r\nimport org.eclipse.jdt.core.compiler.IScanner;\r\nimport org.eclipse.jdt.core.compiler.ITerminalSymbols;\r\nimport org.eclipse.jdt.core.compiler.InvalidInputException;\r\nimport org.eclipse.jdt.internal.compiler.AbstractSyntaxTreeVisitorAdapter;\r\nimport org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor;\r\nimport org.eclipse.jdt.internal.compiler.ast.AND_AND_Expression;\r\nimport org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration;\r\nimport org.eclipse.jdt.internal.compiler.ast.AllocationExpression;\r\nimport org.eclipse.jdt.internal.compiler.ast.AnonymousLocalTypeDeclaration;\r\nimport org.eclipse.jdt.internal.compiler.ast.Argument;\r\nimport org.eclipse.jdt.internal.compiler.ast.ArrayAllocationExpression;\r\nimport org.eclipse.jdt.internal.compiler.ast.ArrayInitializer;\r\nimport org.eclipse.jdt.internal.compiler.ast.ArrayQualifiedTypeReference;\r\nimport org.eclipse.jdt.internal.compiler.ast.ArrayReference;\r\nimport org.eclipse.jdt.internal.compiler.ast.ArrayTypeReference;\r\nimport org.eclipse.jdt.internal.compiler.ast.AssertStatement;\r\nimport org.eclipse.jdt.internal.compiler.ast.Assignment;\r\nimport org.eclipse.jdt.internal.compiler.ast.AstNode;\r\nimport org.eclipse.jdt.internal.compiler.ast.BinaryExpression;\r\nimport org.eclipse.jdt.internal.compiler.ast.Block;\r\nimport org.eclipse.jdt.internal.compiler.ast.BreakStatement;\r\nimport org.eclipse.jdt.internal.compiler.ast.CaseStatement;\r\nimport org.eclipse.jdt.internal.compiler.ast.CastExpression;\r\nimport org.eclipse.jdt.internal.compiler.ast.CharLiteral;\r\nimport org.eclipse.jdt.internal.compiler.ast.ClassLiteralAccess;\r\nimport org.eclipse.jdt.internal.compiler.ast.Clinit;\r\nimport org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration;\r\nimport org.eclipse.jdt.internal.compiler.ast.CompoundAssignment;\r\nimport org.eclipse.jdt.internal.compiler.ast.ConditionalExpression;\r\nimport org.eclipse.jdt.internal.compiler.ast.ConstructorDeclaration;\r\nimport org.eclipse.jdt.internal.compiler.ast.ContinueStatement;\r\nimport org.eclipse.jdt.internal.compiler.ast.DoStatement;\r\nimport org.eclipse.jdt.internal.compiler.ast.DoubleLiteral;\r\nimport org.eclipse.jdt.internal.compiler.ast.EmptyStatement;\r\nimport org.eclipse.jdt.internal.compiler.ast.EqualExpression;\r\nimport org.eclipse.jdt.internal.compiler.ast.ExplicitConstructorCall;\r\nimport org.eclipse.jdt.internal.compiler.ast.Expression;\r\nimport org.eclipse.jdt.internal.compiler.ast.FalseLiteral;\r\nimport org.eclipse.jdt.internal.compiler.ast.FieldDeclaration;\r\nimport org.eclipse.jdt.internal.compiler.ast.FieldReference;\r\nimport org.eclipse.jdt.internal.compiler.ast.FloatLiteral;\r\nimport org.eclipse.jdt.internal.compiler.ast.ForStatement;\r\nimport org.eclipse.jdt.internal.compiler.ast.IfStatement;\r\nimport org.eclipse.jdt.internal.compiler.ast.ImportReference;\r\nimport org.eclipse.jdt.internal.compiler.ast.Initializer;\r\nimport org.eclipse.jdt.internal.compiler.ast.InstanceOfExpression;\r\nimport org.eclipse.jdt.internal.compiler.ast.IntLiteral;\r\nimport org.eclipse.jdt.internal.compiler.ast.LabeledStatement;\r\nimport org.eclipse.jdt.internal.compiler.ast.LocalDeclaration;\r\nimport org.eclipse.jdt.internal.compiler.ast.LocalTypeDeclaration;\r\nimport org.eclipse.jdt.internal.compiler.ast.LongLiteral;\r\nimport org.eclipse.jdt.internal.compiler.ast.MemberTypeDeclaration;\r\nimport org.eclipse.jdt.internal.compiler.ast.MessageSend;\r\nimport org.eclipse.jdt.internal.compiler.ast.MethodDeclaration;\r\nimport org.eclipse.jdt.internal.compiler.ast.NullLiteral;\r\nimport org.eclipse.jdt.internal.compiler.ast.OR_OR_Expression;\r\nimport org.eclipse.jdt.internal.compiler.ast.OperatorIds;\r\nimport org.eclipse.jdt.internal.compiler.ast.PostfixExpression;\r\nimport org.eclipse.jdt.internal.compiler.ast.PrefixExpression;\r\nimport org.eclipse.jdt.internal.compiler.ast.QualifiedAllocationExpression;\r\nimport org.eclipse.jdt.internal.compiler.ast.QualifiedNameReference;\r\nimport org.eclipse.jdt.internal.compiler.ast.QualifiedSuperReference;\r\nimport org.eclipse.jdt.internal.compiler.ast.QualifiedThisReference;\r\nimport org.eclipse.jdt.internal.compiler.ast.QualifiedTypeReference;\r\nimport org.eclipse.jdt.internal.compiler.ast.ReturnStatement;\r\nimport org.eclipse.jdt.internal.compiler.ast.SingleNameReference;\r\nimport org.eclipse.jdt.internal.compiler.ast.SingleTypeReference;\r\nimport org.eclipse.jdt.internal.compiler.ast.Statement;\r\nimport org.eclipse.jdt.internal.compiler.ast.StringLiteral;\r\nimport org.eclipse.jdt.internal.compiler.ast.SuperReference;\r\nimport org.eclipse.jdt.internal.compiler.ast.SwitchStatement;\r\nimport org.eclipse.jdt.internal.compiler.ast.SynchronizedStatement;\r\nimport org.eclipse.jdt.internal.compiler.ast.ThisReference;\r\nimport org.eclipse.jdt.internal.compiler.ast.ThrowStatement;\r\nimport org.eclipse.jdt.internal.compiler.ast.TrueLiteral;\r\nimport org.eclipse.jdt.internal.compiler.ast.TryStatement;\r\nimport org.eclipse.jdt.internal.compiler.ast.TypeDeclaration;\r\nimport org.eclipse.jdt.internal.compiler.ast.TypeReference;\r\nimport org.eclipse.jdt.internal.compiler.ast.UnaryExpression;\r\nimport org.eclipse.jdt.internal.compiler.ast.WhileStatement;\r\nimport org.eclipse.jdt.internal.compiler.impl.Constant;\r\nimport org.eclipse.jdt.internal.compiler.lookup.BlockScope;\r\nimport org.eclipse.jdt.internal.compiler.lookup.ClassScope;\r\nimport org.eclipse.jdt.internal.compiler.lookup.CompilationUnitScope;\r\nimport org.eclipse.jdt.internal.compiler.lookup.CompilerModifiers;\r\nimport org.eclipse.jdt.internal.compiler.lookup.MethodScope;\r\nimport org.eclipse.jdt.internal.formatter.align.Alignment;\r\nimport org.eclipse.jdt.internal.formatter.align.AlignmentException;\r\n\r\n/**\r\n * This class is responsible for formatting a valid java source code.\r\n * @since 2.1\r\n */\r\n// TODO add line splitting for all remaining expression and statements\r\n// TODO find a way to handle complex boolean expression\r\n// TODO Add the ICodeFormatter extension point once the UI has fixed their code\r\n/*\r\n   <extension\r\n         id=\"org.eclipse.jdt.core.newformatter.codeformatter\"\r\n         name=\"org.eclipse.jdt.core.newformatter.codeformatter\"\r\n         point=\"org.eclipse.jdt.core.codeFormatter\">\r\n      <codeFormatter\r\n            class=\"org.eclipse.jdt.internal.formatter.CodeFormatterVisitor\">\r\n      </codeFormatter>\r\n   </extension>\r\n*/\r\npublic class CodeFormatterVisitor extends AbstractSyntaxTreeVisitorAdapter {\r\n\r\n	public static class MultiFieldDeclaration extends FieldDeclaration {\r\n		\r\n		FieldDeclaration[] declarations;\r\n		\r\n		MultiFieldDeclaration(FieldDeclaration[] declarations){\r\n			this.declarations = declarations;\r\n			this.modifiers = declarations[0].modifiers; \r\n		}\r\n	}\r\n	\r\n	public static boolean DEBUG = false;\r\n	private static final int NO_MODIFIERS = 0;\r\n	/*\r\n	 * Set of expected tokens type for a single type reference.\r\n	 * This array needs to be SORTED.\r\n	 */\r\n	private static final int[] SINGLETYPEREFERENCE_EXPECTEDTOKENS = new int[] {\r\n		ITerminalSymbols.TokenNameIdentifier,\r\n		ITerminalSymbols.TokenNameboolean,\r\n		ITerminalSymbols.TokenNamebyte,\r\n		ITerminalSymbols.TokenNamechar,\r\n		ITerminalSymbols.TokenNamedouble,\r\n		ITerminalSymbols.TokenNamefloat,\r\n		ITerminalSymbols.TokenNameint,\r\n		ITerminalSymbols.TokenNamelong,\r\n		ITerminalSymbols.TokenNameshort,\r\n		ITerminalSymbols.TokenNamevoid\r\n	};\r\n	private int chunkKind;\r\n	public int lastLocalDeclarationSourceStart;\r\n	private IScanner localScanner;\r\n	public FormattingPreferences preferences;\r\n	public Scribe scribe;\r\n	\r\n	/*\r\n	 * TODO: See how to choose the formatter\'s options. The extension point is calling\r\n	 * this constructor, but then there is no way to initialize the option used by the formatter.\r\n	 */ \r\n	public CodeFormatterVisitor() {\r\n		this(FormattingPreferences.getSunSetttings(), JavaCore.getOptions());\r\n	}\r\n\r\n	public CodeFormatterVisitor(FormattingPreferences preferences, Map settings) {\r\n		if (settings != null) {\r\n			String compiler_source = (String) settings.get(JavaCore.COMPILER_SOURCE);\r\n			if (compiler_source == null) {\r\n				this.localScanner = ToolFactory.createScanner(false, false, false, false);\r\n			} else {\r\n				this.localScanner = ToolFactory.createScanner(false, false, false, compiler_source);\r\n			}\r\n		} else {\r\n			this.localScanner = ToolFactory.createScanner(false, false, false, false);\r\n		}\r\n		// TODO set the java core options when common preferences are changed\r\n//		convertOldOptionsToPreferences(settings, preferences);\r\n		this.preferences = preferences;\r\n		this.scribe = new Scribe(this, settings);\r\n	}\r\n	\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#acceptProblem(org.eclipse.jdt.core.compiler.IProblem)\r\n	 */\r\n	public void acceptProblem(IProblem problem) {\r\n		super.acceptProblem(problem);\r\n	}\r\n\r\n	private BinaryExpressionFragmentBuilder buildFragments(BinaryExpression binaryExpression, BlockScope scope) {\r\n		BinaryExpressionFragmentBuilder builder = new BinaryExpressionFragmentBuilder();\r\n		\r\n		switch((binaryExpression.bits & AstNode.OperatorMASK) >> AstNode.OperatorSHIFT) {\r\n			case OperatorIds.AND_AND :\r\n				binaryExpression.left.traverse(builder, scope);\r\n				builder.operatorsList.add(new Integer(ITerminalSymbols.TokenNameAND_AND));\r\n				binaryExpression.right.traverse(builder, scope);\r\n				break;\r\n			case OperatorIds.OR_OR :\r\n				binaryExpression.left.traverse(builder, scope);\r\n				builder.operatorsList.add(new Integer(ITerminalSymbols.TokenNameOR_OR));\r\n				binaryExpression.right.traverse(builder, scope);\r\n				break;\r\n		}\r\n\r\n		return builder;\r\n	}\r\n\r\n	public boolean checkChunkStart(int kind) {\r\n		if (this.chunkKind != kind) {\r\n			this.chunkKind = kind;\r\n			return true;\r\n		}\r\n		return false;\r\n	}\r\n	\r\n	private AstNode[] computeMergedMemberDeclarations(TypeDeclaration typeDeclaration){\r\n		\r\n		int fieldIndex = 0, fieldCount = (typeDeclaration.fields == null) ? 0 : typeDeclaration.fields.length;\r\n		FieldDeclaration field = fieldCount == 0 ? null : typeDeclaration.fields[fieldIndex];\r\n		int fieldStart = field == null ? Integer.MAX_VALUE : field.declarationSourceStart;\r\n\r\n		int methodIndex = 0, methodCount = (typeDeclaration.methods == null) ? 0 : typeDeclaration.methods.length;\r\n		AbstractMethodDeclaration method = methodCount == 0 ? null : typeDeclaration.methods[methodIndex];\r\n		int methodStart = method == null ? Integer.MAX_VALUE : method.declarationSourceStart;\r\n\r\n		int typeIndex = 0, typeCount = (typeDeclaration.memberTypes == null) ? 0 : typeDeclaration.memberTypes.length;\r\n		MemberTypeDeclaration type = typeCount == 0 ? null : typeDeclaration.memberTypes[typeIndex];\r\n		int typeStart = type == null ? Integer.MAX_VALUE : type.declarationSourceStart;\r\n	\r\n		final int memberLength = fieldCount+methodCount+typeCount;\r\n		AstNode[] members = new AstNode[memberLength];\r\n		if (memberLength != 0) {\r\n			int index = 0;\r\n			int previousFieldStart = -1;\r\n			do {\r\n				if (fieldStart < methodStart && fieldStart < typeStart) {\r\n					// next member is a field\r\n					if (fieldStart == previousFieldStart){ \r\n						AstNode previousMember = members[index - 1];\r\n						if (previousMember instanceof MultiFieldDeclaration) {\r\n							MultiFieldDeclaration multiField = (MultiFieldDeclaration) previousMember;\r\n							int length = multiField.declarations.length;\r\n							System.arraycopy(multiField.declarations, 0, multiField.declarations=new FieldDeclaration[length+1], 0, length);\r\n							multiField.declarations[length] = (FieldDeclaration) field;\r\n						} else {\r\n							members[index - 1] = new MultiFieldDeclaration(new FieldDeclaration[]{ (FieldDeclaration)previousMember, field});\r\n						}\r\n					} else {\r\n						members[index++] = field;					\r\n					}\r\n					previousFieldStart = fieldStart;\r\n					if (++fieldIndex < fieldCount) { // find next field if any\r\n						fieldStart = (field = typeDeclaration.fields[fieldIndex]).declarationSourceStart;\r\n					} else {\r\n						fieldStart = Integer.MAX_VALUE;\r\n					}\r\n				} else if (methodStart < fieldStart && methodStart < typeStart) {\r\n					// next member is a method\r\n					if (!method.isDefaultConstructor() && !method.isClinit()) {\r\n						members[index++] = method;					\r\n					}\r\n					if (++methodIndex < methodCount) { // find next method if any\r\n						methodStart = (method = typeDeclaration.methods[methodIndex]).declarationSourceStart;\r\n					} else {\r\n						methodStart = Integer.MAX_VALUE;\r\n					}\r\n				} else {\r\n					// next member is a type\r\n					members[index++] = type;\r\n					if (++typeIndex < typeCount) { // find next type if any\r\n						typeStart = (type = typeDeclaration.memberTypes[typeIndex]).declarationSourceStart;\r\n					} else {\r\n						typeStart = Integer.MAX_VALUE;\r\n					}\r\n				}\r\n			} while ((fieldIndex < fieldCount) || (typeIndex < typeCount) || (methodIndex < methodCount));\r\n			\r\n			if (members.length != index) {\r\n				System.arraycopy(members, 0, members=new AstNode[index], 0, index);\r\n			}\r\n		}\r\n		return members;\r\n	}\r\n\r\n	void convertOldOptionsToPreferences(Map oldOptions, FormattingPreferences formattingPreferences) {\r\n		if (oldOptions == null) {\r\n			return;\r\n		}\r\n		Object[] entries = oldOptions.entrySet().toArray();\r\n		\r\n		for (int i = 0, max = entries.length; i < max; i++){\r\n			Map.Entry entry = (Map.Entry)entries[i];\r\n			if (!(entry.getKey() instanceof String)) continue;\r\n			if (!(entry.getValue() instanceof String)) continue;\r\n			String optionID = (String) entry.getKey();\r\n			String optionValue = (String) entry.getValue();\r\n			\r\n			if(optionID.equals(JavaCore.FORMATTER_NEWLINE_OPENING_BRACE)){\r\n				if (optionValue.equals(JavaCore.INSERT)){\r\n					formattingPreferences.anonymous_type_declaration_brace_position = FormattingPreferences.NEXT_LINE;\r\n					formattingPreferences.type_declaration_brace_position = FormattingPreferences.NEXT_LINE;\r\n					formattingPreferences.method_declaration_brace_position = FormattingPreferences.NEXT_LINE;\r\n					formattingPreferences.block_brace_position = FormattingPreferences.NEXT_LINE;\r\n					formattingPreferences.switch_brace_position = FormattingPreferences.NEXT_LINE;\r\n				} else if (optionValue.equals(JavaCore.DO_NOT_INSERT)){\r\n					formattingPreferences.anonymous_type_declaration_brace_position = FormattingPreferences.END_OF_LINE;\r\n					formattingPreferences.type_declaration_brace_position = FormattingPreferences.END_OF_LINE;\r\n					formattingPreferences.method_declaration_brace_position = FormattingPreferences.END_OF_LINE;\r\n					formattingPreferences.block_brace_position = FormattingPreferences.END_OF_LINE;\r\n					formattingPreferences.switch_brace_position = FormattingPreferences.END_OF_LINE;\r\n				}\r\n				continue;\r\n			}\r\n			if(optionID.equals(JavaCore.FORMATTER_NEWLINE_CONTROL)) {\r\n				if (optionValue.equals(JavaCore.INSERT)){\r\n					formattingPreferences.insert_new_line_in_control_statements = true;\r\n				} else if (optionValue.equals(JavaCore.DO_NOT_INSERT)){\r\n					formattingPreferences.insert_new_line_in_control_statements = false;\r\n				}\r\n				continue;\r\n			}\r\n			if(optionID.equals(JavaCore.FORMATTER_CLEAR_BLANK_LINES)) {\r\n				if (optionValue.equals(JavaCore.CLEAR_ALL)){\r\n					formattingPreferences.number_of_empty_lines_to_preserve = 0;\r\n				} else if (optionValue.equals(JavaCore.PRESERVE_ONE)){\r\n					formattingPreferences.number_of_empty_lines_to_preserve = 1;\r\n				}\r\n				continue;\r\n			}\r\n			if(optionID.equals(JavaCore.FORMATTER_NEWLINE_ELSE_IF)){\r\n				if (optionValue.equals(JavaCore.INSERT)){\r\n					formattingPreferences.compact_else_if = false;\r\n				} else if (optionValue.equals(JavaCore.DO_NOT_INSERT)){\r\n					formattingPreferences.compact_else_if = true;\r\n				}\r\n				continue;\r\n			}\r\n			if(optionID.equals(JavaCore.FORMATTER_NEWLINE_EMPTY_BLOCK)){\r\n				if (optionValue.equals(JavaCore.INSERT)){\r\n					formattingPreferences.insert_new_line_in_empty_anonymous_type_declaration = true;\r\n					formattingPreferences.insert_new_line_in_empty_type_declaration = true;\r\n					formattingPreferences.insert_new_line_in_empty_method_body = true;\r\n					formattingPreferences.insert_new_line_in_empty_block = true;\r\n				} else if (optionValue.equals(JavaCore.DO_NOT_INSERT)){\r\n					formattingPreferences.insert_new_line_in_empty_anonymous_type_declaration = false;\r\n					formattingPreferences.insert_new_line_in_empty_type_declaration = false;\r\n					formattingPreferences.insert_new_line_in_empty_method_body = false;\r\n					formattingPreferences.insert_new_line_in_empty_block = false;\r\n				}\r\n				continue;\r\n			}\r\n			if(optionID.equals(JavaCore.FORMATTER_LINE_SPLIT)){\r\n				try {\r\n					int val = Integer.parseInt(optionValue);\r\n					if (val >= 0) {\r\n						formattingPreferences.page_width = val;\r\n					}\r\n				} catch(NumberFormatException e){\r\n				}\r\n			}\r\n			if(optionID.equals(JavaCore.FORMATTER_COMPACT_ASSIGNMENT)){\r\n				if (optionValue.equals(JavaCore.COMPACT)){\r\n					formattingPreferences.insert_space_before_assignment_operators = false;\r\n				} else if (optionValue.equals(JavaCore.NORMAL)){\r\n					formattingPreferences.insert_space_before_assignment_operators = true;\r\n				}\r\n				continue;\r\n			}\r\n			if(optionID.equals(JavaCore.FORMATTER_TAB_CHAR)){\r\n				if (optionValue.equals(JavaCore.TAB)){\r\n					formattingPreferences.use_tab = true;\r\n				} else if (optionValue.equals(JavaCore.SPACE)){\r\n					formattingPreferences.use_tab = false;\r\n				}\r\n				continue;\r\n			}\r\n			if(optionID.equals(JavaCore.FORMATTER_TAB_SIZE)){\r\n				try {\r\n					int val = Integer.parseInt(optionValue);\r\n					if (val > 0) {\r\n						formattingPreferences.tab_size = val;\r\n					}\r\n				} catch(NumberFormatException e){\r\n				}\r\n			}\r\n			if(optionID.equals(JavaCore.FORMATTER_SPACE_CASTEXPRESSION)){\r\n				if (optionValue.equals(JavaCore.INSERT)){\r\n					formattingPreferences.insert_space_after_closing_paren_in_cast = true;\r\n				} else if (optionValue.equals(JavaCore.DO_NOT_INSERT)){\r\n					formattingPreferences.insert_space_after_closing_paren_in_cast = false;\r\n				}\r\n				continue;\r\n			}		\r\n		}		\r\n	}\r\n\r\n	private boolean dumpBinaryExpression(\r\n		BinaryExpression binaryExpression,\r\n		int operator,\r\n		BlockScope scope) {\r\n\r\n		final int numberOfParens = (binaryExpression.bits & AstNode.ParenthesizedMASK) >> AstNode.ParenthesizedSHIFT;\r\n\r\n		if (numberOfParens > 0) {\r\n			manageOpeningParenthesizedExpression(binaryExpression, numberOfParens);\r\n		}	\r\n		BinaryExpressionFragmentBuilder builder = buildFragments(binaryExpression, scope);\r\n		final int fragmentsSize = builder.size();\r\n		\r\n		if (fragmentsSize > 1) {\r\n			Alignment binaryExpressionAlignment = this.scribe.createAlignment(\"binaryExpressionAlignment\", this.preferences.binary_expression_alignment, fragmentsSize, this.scribe.scanner.currentPosition); //$NON-NLS-1$\r\n			this.scribe.enterAlignment(binaryExpressionAlignment);\r\n			boolean ok = false;\r\n			AstNode[] fragments = builder.fragments();\r\n			int[] operators = builder.operators();\r\n			do {\r\n				try {\r\n					for (int i = 0; i < fragmentsSize - 1; i++) {\r\n						AstNode fragment = fragments[i];\r\n						fragment.traverse(this, scope);\r\n						this.scribe.alignFragment(binaryExpressionAlignment, i);\r\n						this.scribe.printNextToken(operators[i], this.preferences.insert_space_before_binary_operator);\r\n						if (this.preferences.insert_space_after_binary_operator) {\r\n							this.scribe.space();\r\n						}						\r\n					}\r\n					fragments[fragmentsSize - 1].traverse(this, scope);\r\n					ok = true;\r\n				} catch(AlignmentException e){\r\n					this.scribe.redoAlignment(e);\r\n				}\r\n			} while (!ok);		\r\n			this.scribe.exitAlignment(binaryExpressionAlignment, true);\r\n		} else {\r\n			binaryExpression.left.traverse(this, scope);\r\n			this.scribe.printNextToken(operator, this.preferences.insert_space_before_binary_operator);\r\n			if (this.preferences.insert_space_after_binary_operator) {\r\n				this.scribe.space();\r\n			}\r\n			binaryExpression.right.traverse(this, scope);\r\n		}	\r\n		if (numberOfParens > 0) {\r\n			manageClosingParenthesizedExpression(binaryExpression, numberOfParens);\r\n		}\r\n		return false;\r\n	}\r\n\r\n	private String failedToFormat(final char[] compilationUnitSource) {\r\n		StringBuffer buffer = new StringBuffer(this.scribe.formattedSource());\r\n		buffer.append(compilationUnitSource, this.scribe.scanner.getCurrentTokenEndPosition(), this.scribe.scannerEndPosition - this.scribe.scanner.getCurrentTokenEndPosition());\r\n		System.out.println(\"COULD NOT FORMAT \\n\" + this.scribe.scanner); //$NON-NLS-1$\r\n		if (DEBUG) {\r\n			System.out.println(this.scribe);\r\n		}\r\n		return buffer.toString();\r\n	}\r\n\r\n	private void format(\r\n		AbstractMethodDeclaration methodDeclaration,\r\n		ClassScope scope,\r\n		boolean isChunkStart) {\r\n\r\n		final int newLineBeforeChunk = isChunkStart ? this.preferences.blank_lines_before_new_chunk : 0;\r\n		if (newLineBeforeChunk > 0) {\r\n			this.scribe.printNewLines(newLineBeforeChunk);\r\n		}\r\n		final int newLinesBeforeMethod = this.preferences.blank_lines_before_method;\r\n		if (newLinesBeforeMethod > 0) {\r\n			this.scribe.printNewLines(newLinesBeforeMethod);\r\n		}\r\n		methodDeclaration.traverse(this, scope);\r\n	}\r\n	\r\n	private void format(FieldDeclaration fieldDeclaration, IAbstractSyntaxTreeVisitor visitor, MethodScope scope, boolean isChunkStart) {\r\n		\r\n		int newLineBeforeChunk = isChunkStart ? this.preferences.blank_lines_before_new_chunk : 0;\r\n		if (newLineBeforeChunk > 0) {\r\n			this.scribe.printNewLines(newLineBeforeChunk);\r\n		}\r\n		final int newLinesBeforeField = this.preferences.blank_lines_before_field;\r\n		if (newLinesBeforeField > 0) {\r\n			this.scribe.printNewLines(newLinesBeforeField);\r\n		}\r\n		Alignment fieldAlignment = this.scribe.getAlignment(\"typeMembers\");	//$NON-NLS-1$\r\n\r\n		if (fieldDeclaration.modifiers != NO_MODIFIERS) {\r\n			this.scribe.printModifiers();\r\n		}\r\n		/*\r\n		 * Field type\r\n		 */\r\n		this.scribe.alignFragment(fieldAlignment, 0);\r\n\r\n		fieldDeclaration.type.traverse(this, scope);\r\n		\r\n		/*\r\n		 * Field name\r\n		 */\r\n		this.scribe.alignFragment(fieldAlignment, 1);\r\n\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameIdentifier, true);\r\n\r\n		/*\r\n		 * Check for extra dimensions\r\n		 */\r\n		int extraDimensions = getExtraDimension();\r\n		if (extraDimensions != 0) {\r\n			 for (int i = 0; i < extraDimensions; i++) {\r\n			 	this.scribe.printNextToken(ITerminalSymbols.TokenNameLBRACKET);\r\n			 	this.scribe.printNextToken(ITerminalSymbols.TokenNameRBRACKET);\r\n			 }\r\n		}\r\n	\r\n		/*\r\n		 * Field initialization\r\n		 */\r\n		if (fieldDeclaration.initialization != null) {\r\n			this.scribe.alignFragment(fieldAlignment, 2);\r\n			this.scribe.printNextToken(ITerminalSymbols.TokenNameEQUAL, this.preferences.insert_space_before_assignment_operators);\r\n			if (this.preferences.insert_space_after_assignment_operators) {\r\n				this.scribe.space();\r\n			}\r\n			fieldDeclaration.initialization.traverse(this, scope);\r\n		}\r\n		\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameSEMICOLON, this.preferences.insert_space_before_semicolon);\r\n\r\n		if (fieldDeclaration.initialization == null) {\r\n			this.scribe.alignFragment(fieldAlignment, 2);\r\n		}\r\n\r\n		if (fieldAlignment != null) {\r\n			this.scribe.alignFragment(fieldAlignment, 3);\r\n			this.scribe.printTrailingComment();\r\n			this.scribe.printNewLine();\r\n			this.scribe.exitAlignment(fieldAlignment, false);\r\n		} else {\r\n			this.scribe.space();\r\n			this.scribe.printTrailingComment();\r\n			this.scribe.printNewLine();\r\n		}\r\n	}\r\n\r\n	private void format(\r\n		MemberTypeDeclaration memberTypeDeclaration,\r\n		ClassScope scope,\r\n		boolean isChunkStart) {\r\n\r\n		int newLineBeforeChunk = isChunkStart ? this.preferences.blank_lines_before_new_chunk : 0;\r\n		if (newLineBeforeChunk > 0) {\r\n			this.scribe.printNewLines(newLineBeforeChunk);\r\n		}\r\n		final int newLinesBeforeMember = this.preferences.blank_lines_before_member_type;\r\n		if (newLinesBeforeMember > 0) {\r\n			this.scribe.printNewLines(newLinesBeforeMember);\r\n		}\r\n		memberTypeDeclaration.traverse(this, scope);\r\n	}\r\n	\r\n	private void format(MultiFieldDeclaration multiFieldDeclaration, IAbstractSyntaxTreeVisitor visitor, MethodScope scope, boolean isChunkStart) {\r\n\r\n		int newLineBeforeChunk = isChunkStart ? this.preferences.blank_lines_before_new_chunk : 0;\r\n		if (newLineBeforeChunk > 0) {\r\n			this.scribe.printNewLines(newLineBeforeChunk);\r\n		}\r\n		final int newLinesBeforeField = this.preferences.blank_lines_before_field;\r\n		if (newLinesBeforeField > 0) {\r\n			this.scribe.printNewLines(newLinesBeforeField);\r\n		}\r\n		Alignment fieldAlignment = this.scribe.getAlignment(\"typeMembers\");	//$NON-NLS-1$\r\n\r\n		if (multiFieldDeclaration.declarations[0].modifiers != NO_MODIFIERS) {\r\n			this.scribe.printModifiers();\r\n		}\r\n		this.scribe.alignFragment(fieldAlignment, 0);\r\n\r\n		multiFieldDeclaration.declarations[0].type.traverse(this, scope);\r\n\r\n		for (int i = 0, length = multiFieldDeclaration.declarations.length; i < length; i++) {\r\n			FieldDeclaration fieldDeclaration = multiFieldDeclaration.declarations[i];\r\n			/*\r\n			 * Field name\r\n			 */\r\n			if (i == 0) {\r\n				this.scribe.alignFragment(fieldAlignment, 1);\r\n			}\r\n			this.scribe.printNextToken(ITerminalSymbols.TokenNameIdentifier, true);\r\n	\r\n			/*\r\n			 * Check for extra dimensions\r\n			 */\r\n			int extraDimensions = getExtraDimension();\r\n			if (extraDimensions != 0) {\r\n				 for (int index = 0; index < extraDimensions; index++) {\r\n				 	this.scribe.printNextToken(ITerminalSymbols.TokenNameLBRACKET);\r\n				 	this.scribe.printNextToken(ITerminalSymbols.TokenNameRBRACKET);\r\n				 }\r\n			}\r\n		\r\n			/*\r\n			 * Field initialization\r\n			 */\r\n			if (fieldDeclaration.initialization != null) {\r\n				if (i == 0) {\r\n					this.scribe.alignFragment(fieldAlignment, 2);\r\n				}\r\n				this.scribe.printNextToken(ITerminalSymbols.TokenNameEQUAL, this.preferences.insert_space_before_assignment_operators);\r\n				if (this.preferences.insert_space_after_assignment_operators) {\r\n					this.scribe.space();\r\n				}\r\n				fieldDeclaration.initialization.traverse(this, scope);\r\n			}\r\n			\r\n			if (i != length - 1) {\r\n				if (i == 0 && fieldDeclaration.initialization == null) {\r\n					this.scribe.alignFragment(fieldAlignment, 2);\r\n				}				\r\n				this.scribe.printNextToken(ITerminalSymbols.TokenNameCOMMA, this.preferences.insert_space_before_comma_in_multiple_field_declarations);\r\n				if (this.preferences.insert_space_after_comma_in_multiple_field_declarations) {\r\n					this.scribe.space();\r\n				}\r\n			} else {\r\n				this.scribe.printNextToken(ITerminalSymbols.TokenNameSEMICOLON, this.preferences.insert_space_before_semicolon);\r\n				\r\n				this.scribe.alignFragment(fieldAlignment, 3);\r\n				this.scribe.printTrailingComment();\r\n				this.scribe.printNewLine();\r\n			}\r\n		}\r\n		if (fieldAlignment != null) {\r\n			this.scribe.exitAlignment(fieldAlignment, false);\r\n		}\r\n	}\r\n	\r\n	/**\r\n	 * @see org.eclipse.jdt.core.ICodeFormatter#format(java.lang.String, int, int, java.lang.String)\r\n	 */\r\n	public String format(String string, int[] positions, AstNode[] nodes) {\r\n		// reset the scribe\r\n		this.scribe.reset(positions);\r\n		\r\n		long startTime = System.currentTimeMillis();\r\n\r\n		final char[] compilationUnitSource = string.toCharArray();\r\n		\r\n		this.scribe.scanner.setSource(compilationUnitSource);\r\n		this.localScanner.setSource(compilationUnitSource);\r\n		this.scribe.scannerEndPosition = compilationUnitSource.length;\r\n		this.scribe.scanner.resetTo(0, this.scribe.scannerEndPosition);\r\n		if (nodes == null) {\r\n			return string;\r\n		}\r\n\r\n		this.lastLocalDeclarationSourceStart = 0;\r\n		try {\r\n			if (nodes != null) {\r\n				formatClassBodyDeclarations(nodes);\r\n			}\r\n		} catch(AbortFormatting e){\r\n			return failedToFormat(compilationUnitSource);\r\n		}\r\n		if (DEBUG){\r\n			System.out.println(\"Formatting time: \" + (System.currentTimeMillis() - startTime));  //$NON-NLS-1$\r\n		}\r\n		return this.scribe.toString();\r\n	}\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.core.ICodeFormatter#format(java.lang.String, int, int, java.lang.String)\r\n	 */\r\n	public String format(String string, int[] positions, CompilationUnitDeclaration compilationUnitDeclaration) {\r\n		// reset the scribe\r\n		this.scribe.reset(positions);\r\n		\r\n		long startTime = System.currentTimeMillis();\r\n\r\n		final char[] compilationUnitSource = string.toCharArray();\r\n		\r\n		this.scribe.scanner.setSource(compilationUnitSource);\r\n		this.localScanner.setSource(compilationUnitSource);\r\n		this.scribe.scannerEndPosition = compilationUnitSource.length;\r\n		this.scribe.scanner.resetTo(0, this.scribe.scannerEndPosition);\r\n		if (compilationUnitDeclaration == null || compilationUnitDeclaration.ignoreFurtherInvestigation) {\r\n			return string;\r\n		}\r\n\r\n		this.lastLocalDeclarationSourceStart = 0;\r\n		try {\r\n			compilationUnitDeclaration.traverse(this, compilationUnitDeclaration.scope);\r\n		} catch(AbortFormatting e){\r\n			return failedToFormat(compilationUnitSource);\r\n		}\r\n		if (DEBUG){\r\n			System.out.println(\"Formatting time: \" + (System.currentTimeMillis() - startTime));  //$NON-NLS-1$\r\n		}\r\n		return this.scribe.toString();\r\n	}\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.core.ICodeFormatter#format(java.lang.String, int, int, java.lang.String)\r\n	 */\r\n	public String format(String string, int[] positions, ConstructorDeclaration constructorDeclaration) {\r\n		// reset the scribe\r\n		this.scribe.reset(positions);\r\n		\r\n		long startTime = System.currentTimeMillis();\r\n\r\n		final char[] compilationUnitSource = string.toCharArray();\r\n		\r\n		this.scribe.scanner.setSource(compilationUnitSource);\r\n		this.localScanner.setSource(compilationUnitSource);\r\n		this.scribe.scannerEndPosition = compilationUnitSource.length;\r\n		this.scribe.scanner.resetTo(0, this.scribe.scannerEndPosition);\r\n		if (constructorDeclaration == null) {\r\n			return string;\r\n		}\r\n\r\n		this.lastLocalDeclarationSourceStart = 0;\r\n		try {\r\n			ExplicitConstructorCall explicitConstructorCall = constructorDeclaration.constructorCall;\r\n			if (explicitConstructorCall != SuperReference.implicitSuperConstructorCall()) {\r\n				explicitConstructorCall.traverse(this, null);\r\n			}\r\n			Statement[] statements = constructorDeclaration.statements;\r\n			if (statements != null) {\r\n				formatStatements(null, statements);\r\n			}\r\n			this.scribe.printComment();\r\n		} catch(AbortFormatting e){\r\n			return failedToFormat(compilationUnitSource);\r\n		}\r\n		if (DEBUG){\r\n			System.out.println(\"Formatting time: \" + (System.currentTimeMillis() - startTime));  //$NON-NLS-1$\r\n		}\r\n		return this.scribe.toString();\r\n	}\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.core.ICodeFormatter#format(java.lang.String, int, int, java.lang.String)\r\n	 */\r\n	public String format(String string, int[] positions, Expression expression) {\r\n		// reset the scribe\r\n		this.scribe.reset(positions);\r\n		\r\n		long startTime = System.currentTimeMillis();\r\n\r\n		final char[] compilationUnitSource = string.toCharArray();\r\n		\r\n		this.scribe.scanner.setSource(compilationUnitSource);\r\n		this.localScanner.setSource(compilationUnitSource);\r\n		this.scribe.scannerEndPosition = compilationUnitSource.length;\r\n		this.scribe.scanner.resetTo(0, this.scribe.scannerEndPosition);\r\n		if (expression == null) {\r\n			return string;\r\n		}\r\n\r\n		this.lastLocalDeclarationSourceStart = 0;\r\n		try {\r\n			expression.traverse(this, null);\r\n			this.scribe.printComment();\r\n		} catch(AbortFormatting e){\r\n			return failedToFormat(compilationUnitSource);\r\n		}\r\n		if (DEBUG){\r\n			System.out.println(\"Formatting time: \" + (System.currentTimeMillis() - startTime));  //$NON-NLS-1$\r\n		}\r\n		return this.scribe.toString();\r\n	}\r\n	\r\n	private void format(TypeDeclaration typeDeclaration){\r\n\r\n		if (typeDeclaration.modifiers != NO_MODIFIERS) {\r\n			this.scribe.printModifiers();\r\n		} else {\r\n			this.scribe.printComment();\r\n		}\r\n		/*\r\n		 * Type name\r\n		 */\r\n		if (typeDeclaration.isInterface()) {\r\n			this.scribe.printNextToken(ITerminalSymbols.TokenNameinterface, true); \r\n		} else {\r\n			this.scribe.printNextToken(ITerminalSymbols.TokenNameclass, true); \r\n		}\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameIdentifier, true); \r\n\r\n		/* \r\n		 * Superclass \r\n		 */\r\n		final TypeReference superclass = typeDeclaration.superclass;\r\n		if (superclass != null) {\r\n			Alignment superclassAlignment =this.scribe.createAlignment(\r\n					\"superclass\", //$NON-NLS-1$\r\n					this.preferences.type_declaration_superclass_alignment,\r\n					2,\r\n					this.scribe.scanner.currentPosition);\r\n			this.scribe.enterAlignment(superclassAlignment);\r\n			boolean ok = false;\r\n			do {\r\n				try {\r\n					this.scribe.alignFragment(superclassAlignment, 0);\r\n					this.scribe.printNextToken(ITerminalSymbols.TokenNameextends, true);\r\n					this.scribe.alignFragment(superclassAlignment, 1);\r\n					this.scribe.space();\r\n					superclass.traverse(this, typeDeclaration.scope);\r\n					ok = true;\r\n				} catch (AlignmentException e) {\r\n					this.scribe.redoAlignment(e);\r\n				}\r\n			} while (!ok);\r\n			this.scribe.exitAlignment(superclassAlignment, true); \r\n		}\r\n\r\n		/* \r\n		 * Super Interfaces \r\n		 */\r\n		final TypeReference[] superInterfaces = typeDeclaration.superInterfaces;\r\n		if (superInterfaces != null) {\r\n			\r\n			int superInterfaceLength = superInterfaces.length;\r\n			Alignment interfaceAlignment =this.scribe.createAlignment(\r\n					\"superInterfaces\",//$NON-NLS-1$\r\n					this.preferences.type_declaration_superinterfaces_alignment,\r\n					superInterfaceLength+1,  // implements token is first fragment\r\n					this.scribe.scanner.currentPosition);\r\n			this.scribe.enterAlignment(interfaceAlignment);\r\n			boolean ok = false;\r\n			do {\r\n				try {\r\n					this.scribe.alignFragment(interfaceAlignment, 0);\r\n					if (typeDeclaration.isInterface()) {\r\n						this.scribe.printNextToken(ITerminalSymbols.TokenNameextends, true);\r\n					} else  {\r\n						this.scribe.printNextToken(ITerminalSymbols.TokenNameimplements, true);\r\n					}\r\n					for (int i = 0; i < superInterfaceLength; i++) {\r\n						if (i > 0) {\r\n							this.scribe.printNextToken(ITerminalSymbols.TokenNameCOMMA, this.preferences.insert_space_before_comma_in_superinterfaces);\r\n							this.scribe.alignFragment(interfaceAlignment, i+1);\r\n							if (this.preferences.insert_space_after_comma_in_superinterfaces) {\r\n								this.scribe.space();\r\n							}\r\n							superInterfaces[i].traverse(this, typeDeclaration.scope);\r\n						} else {\r\n							this.scribe.alignFragment(interfaceAlignment, i+1);\r\n							this.scribe.space();\r\n							superInterfaces[i].traverse(this, typeDeclaration.scope);\r\n						}\r\n					}\r\n					ok = true;\r\n				} catch (AlignmentException e) {\r\n					this.scribe.redoAlignment(e);\r\n				}\r\n			} while (!ok);\r\n			this.scribe.exitAlignment(interfaceAlignment, true);\r\n		}\r\n\r\n		/*\r\n		 * Type body\r\n		 */\r\n		String class_declaration_brace = this.preferences.type_declaration_brace_position;\r\n\r\n		formatTypeOpeningBrace(class_declaration_brace, this.preferences.insert_space_before_type_open_brace, typeDeclaration);\r\n		\r\n		if (this.preferences.indent_body_declarations_compare_to_type_header) {\r\n			this.scribe.indent();\r\n		}\r\n\r\n		formatTypeMembers(typeDeclaration);\r\n\r\n		this.scribe.printComment();\r\n		\r\n		if (this.preferences.indent_body_declarations_compare_to_type_header) {\r\n			this.scribe.unIndent();\r\n		}\r\n		\r\n		if (this.preferences.insert_new_line_in_empty_type_declaration) {\r\n			this.scribe.printNewLine();\r\n		}\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameRBRACE);\r\n		this.scribe.printTrailingComment();\r\n		if (class_declaration_brace.equals(FormattingPreferences.NEXT_LINE_SHIFTED)) {\r\n			this.scribe.unIndent();\r\n		}\r\n	}\r\n\r\n	/*\r\n	 * Merged traversal of member (types, fields, methods)\r\n	 */\r\n	private void formatClassBodyDeclarations(AstNode[] nodes) {\r\n		final int FIELD = 1, METHOD = 2, TYPE = 3;\r\n		\r\n		Alignment memberAlignment = this.scribe.createAlignment(\"typeMembers\", this.preferences.type_member_alignment, 4, this.scribe.scanner.currentPosition); //$NON-NLS-1$\r\n		this.scribe.enterAlignment(memberAlignment);\r\n		boolean isChunkStart = false;\r\n		boolean ok = false;\r\n		int startIndex = 0;\r\n		do {\r\n			try {\r\n				for (int i = startIndex, max = nodes.length; i < max; i++) {\r\n					AstNode member = nodes[i];\r\n					if (member instanceof FieldDeclaration) {\r\n						isChunkStart = memberAlignment.checkChunkStart(FIELD, i, this.scribe.scanner.currentPosition);\r\n						if (member instanceof MultiFieldDeclaration){\r\n							MultiFieldDeclaration multiField = (MultiFieldDeclaration) member;\r\n							\r\n							if (multiField.isStatic()) {\r\n								format(multiField, this, null, isChunkStart);\r\n							} else {\r\n								format(multiField, this, null, isChunkStart);\r\n							}					\r\n						} else if (member instanceof Initializer) {\r\n							Initializer initializer = (Initializer) member;\r\n							if (initializer.isStatic()) {\r\n								initializer.traverse(this, null);\r\n							} else {\r\n								initializer.traverse(this, null);\r\n							}					\r\n						} else {\r\n							FieldDeclaration field = (FieldDeclaration) member;\r\n							if (field.isStatic()) {\r\n								format(field, this, null, isChunkStart);\r\n							} else {\r\n								format(field, this, null, isChunkStart);\r\n							}					\r\n						}\r\n					} else if (member instanceof AbstractMethodDeclaration) {\r\n						isChunkStart = memberAlignment.checkChunkStart(METHOD, i, this.scribe.scanner.currentPosition);\r\n						format((AbstractMethodDeclaration) member, null, isChunkStart);\r\n					} else {\r\n						isChunkStart = memberAlignment.checkChunkStart(TYPE, i, this.scribe.scanner.currentPosition);\r\n						format((MemberTypeDeclaration)member, null, isChunkStart);\r\n					}\r\n					if (isSemiColon()) {\r\n						this.scribe.printNextToken(ITerminalSymbols.TokenNameSEMICOLON, this.preferences.insert_space_before_semicolon);\r\n						this.scribe.printTrailingComment();\r\n					}\r\n				}\r\n				ok = true;\r\n			} catch(AlignmentException e){\r\n				startIndex = memberAlignment.chunkStartIndex;\r\n				this.scribe.redoAlignment(e);\r\n			}\r\n		} while (!ok);		\r\n		this.scribe.exitAlignment(memberAlignment, true);\r\n		this.scribe.printComment();\r\n	}\r\n	\r\n	private void formatEmptyStatement() {\r\n\r\n		if (this.preferences.put_empty_statement_on_new_line) {\r\n			this.scribe.printNewLine();\r\n		}\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameSEMICOLON, this.preferences.insert_space_before_semicolon);\r\n		this.scribe.printTrailingComment();\r\n		this.scribe.printNewLine();\r\n	}\r\n\r\n	private void formatGuardClauseBlock(Block block, BlockScope scope) {\r\n\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameLBRACE, this.preferences.insert_space_before_block_open_brace);\r\n		this.scribe.space();\r\n\r\n		final Statement[] statements = block.statements;\r\n		statements[0].traverse(this, scope);\r\n		this.scribe.space();\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameRBRACE, false, true);\r\n		this.scribe.printTrailingComment();\r\n	}	\r\n\r\n	public void formatMessageSend(\r\n		MessageSend messageSend,\r\n		BlockScope scope,\r\n		Alignment messageAlignment) {\r\n\r\n		if (messageAlignment != null) {\r\n			this.scribe.alignFragment(messageAlignment, 0);\r\n			this.scribe.printNextToken(ITerminalSymbols.TokenNameDOT);\r\n		}\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameIdentifier); // selector\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameLPAREN, this.preferences.insert_space_before_message_send);\r\n\r\n		final Expression[] arguments = messageSend.arguments;\r\n		if (arguments != null) {\r\n			int argumentLength = arguments.length;\r\n			Alignment argumentsAlignment = this.scribe.createAlignment(\r\n					\"messageArguments\", //$NON-NLS-1$\r\n					this.preferences.message_send_arguments_alignment,\r\n					argumentLength,\r\n					this.scribe.scanner.currentPosition);\r\n			this.scribe.enterAlignment(argumentsAlignment);\r\n			boolean ok = false;\r\n			do {\r\n				try {\r\n					if (this.preferences.insert_space_within_message_send) {\r\n						this.scribe.space();\r\n					}\r\n					for (int i = 0; i < argumentLength; i++) {\r\n						if (i > 0) {\r\n							this.scribe.printNextToken(ITerminalSymbols.TokenNameCOMMA, this.preferences.insert_space_before_comma_in_messagesend_arguments);\r\n						}\r\n						this.scribe.alignFragment(argumentsAlignment, i);\r\n						if (i > 0 && this.preferences.insert_space_after_comma_in_messagesend_arguments) {\r\n							this.scribe.space();\r\n						}\r\n						arguments[i].traverse(this, scope);\r\n					}\r\n					this.scribe.printNextToken(ITerminalSymbols.TokenNameRPAREN, this.preferences.insert_space_within_message_send);\r\n					ok = true;\r\n				} catch (AlignmentException e) {\r\n					this.scribe.redoAlignment(e);\r\n				}\r\n			} while (!ok);\r\n			this.scribe.exitAlignment(argumentsAlignment, true);\r\n		} else {\r\n			this.scribe.printNextToken(ITerminalSymbols.TokenNameRPAREN, this.preferences.insert_space_between_empty_arguments);\r\n		}\r\n	}\r\n\r\n	public void formatMethodArguments(\r\n			AbstractMethodDeclaration methodDeclaration, \r\n			boolean spaceBeforeOpenParen, \r\n			boolean spaceBetweenEmptyArgument,\r\n			boolean spaceBeforeClosingParen, \r\n			boolean spaceBeforeFirstArgument, \r\n			boolean spaceBeforeComma, \r\n			boolean spaceAfterComma) {\r\n				\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameLPAREN, spaceBeforeOpenParen); \r\n		\r\n		final Argument[] arguments = methodDeclaration.arguments;\r\n		if (arguments != null) {\r\n			int argumentLength = arguments.length;\r\n			Alignment argumentsAlignment = this.scribe.createAlignment(\r\n					\"methodArguments\",//$NON-NLS-1$\r\n					this.preferences.method_declaration_arguments_alignment,\r\n					argumentLength,\r\n					this.scribe.scanner.currentPosition);\r\n			this.scribe.enterAlignment(argumentsAlignment);\r\n			boolean ok = false;\r\n			do {\r\n				try {\r\n					if (spaceBeforeFirstArgument) {\r\n						this.scribe.space();\r\n					}\r\n					for (int i = 0; i < argumentLength; i++) {\r\n						if (i > 0) {\r\n							this.scribe.printNextToken(ITerminalSymbols.TokenNameCOMMA, spaceBeforeComma);\r\n						}\r\n						this.scribe.alignFragment(argumentsAlignment, i);\r\n						if (i > 0 && spaceAfterComma) {\r\n							this.scribe.space();\r\n						}\r\n						arguments[i].traverse(this, methodDeclaration.scope);\r\n					}\r\n					ok = true;\r\n				} catch (AlignmentException e) {\r\n					this.scribe.redoAlignment(e);\r\n				}\r\n			} while (!ok);\r\n			this.scribe.exitAlignment(argumentsAlignment, true);\r\n		\r\n			this.scribe.printNextToken(ITerminalSymbols.TokenNameRPAREN, spaceBeforeClosingParen); \r\n		} else {\r\n			this.scribe.printNextToken(ITerminalSymbols.TokenNameRPAREN, spaceBetweenEmptyArgument); \r\n		}\r\n	}\r\n\r\n	private void formatOpeningBrace(String bracePosition, boolean insertSpaceBeforeBrace) {\r\n	\r\n		if (bracePosition.equals(FormattingPreferences.NEXT_LINE)) {\r\n			this.scribe.printNewLine();\r\n		} else if (bracePosition.equals(FormattingPreferences.NEXT_LINE_SHIFTED)) {\r\n			this.scribe.printNewLine();\r\n			this.scribe.indent();\r\n		}\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameLBRACE, insertSpaceBeforeBrace);\r\n\r\n		this.scribe.printTrailingComment();\r\n		this.scribe.printNewLine();\r\n	}\r\n\r\n	public void formatStatements(BlockScope scope, final Statement[] statements) {\r\n		int statementsLength = statements.length;\r\n		for (int i = 0; i < statementsLength; i++) {\r\n			final Statement statement = statements[i];\r\n			statement.traverse(this, scope);\r\n			if (statement instanceof Expression) {\r\n				this.scribe.printNextToken(ITerminalSymbols.TokenNameSEMICOLON, this.preferences.insert_space_before_semicolon);\r\n				this.scribe.printTrailingComment();\r\n			} else if (statement instanceof LocalDeclaration) {\r\n				LocalDeclaration currentLocal = (LocalDeclaration) statement;\r\n				if (i < (statementsLength - 1)) {\r\n					/* \r\n					 * We need to check that the next statement is a local declaration\r\n					 */\r\n					if (statements[i + 1] instanceof LocalDeclaration) {\r\n						LocalDeclaration nextLocal = (LocalDeclaration) statements[i + 1];\r\n						if (currentLocal.declarationSourceStart != nextLocal.declarationSourceStart) {\r\n							this.scribe.printNextToken(ITerminalSymbols.TokenNameSEMICOLON, this.preferences.insert_space_before_semicolon);\r\n							this.scribe.printTrailingComment();\r\n						}\r\n					} else {\r\n						this.scribe.printNextToken(ITerminalSymbols.TokenNameSEMICOLON, this.preferences.insert_space_before_semicolon);\r\n						this.scribe.printTrailingComment();\r\n					}\r\n				} else {\r\n					this.scribe.printNextToken(ITerminalSymbols.TokenNameSEMICOLON, this.preferences.insert_space_before_semicolon);\r\n					this.scribe.printTrailingComment();\r\n				}\r\n			} else {\r\n				this.scribe.printTrailingComment();\r\n			}\r\n			this.scribe.printNewLine();\r\n		}\r\n	}\r\n	\r\n	private void formatThrowsClause(\r\n		AbstractMethodDeclaration methodDeclaration,\r\n		boolean spaceBeforeComma,\r\n		boolean spaceAfterComma) {\r\n			\r\n		final TypeReference[] thrownExceptions = methodDeclaration.thrownExceptions;\r\n		if (thrownExceptions != null) {\r\n			int thrownExceptionsLength = thrownExceptions.length;\r\n			Alignment throwsAlignment = this.scribe.createAlignment(\r\n					\"throws\",//$NON-NLS-1$\r\n					this.preferences.method_throws_clause_alignment,\r\n					thrownExceptionsLength + 1, // throws is the first token\r\n					this.scribe.scanner.currentPosition);\r\n		\r\n			this.scribe.enterAlignment(throwsAlignment);\r\n			boolean ok = false;\r\n			do {\r\n				try {\r\n					this.scribe.alignFragment(throwsAlignment, 0);\r\n					this.scribe.printNextToken(ITerminalSymbols.TokenNamethrows, true); \r\n					this.scribe.space();\r\n		\r\n					for (int i = 0; i < thrownExceptionsLength; i++) {\r\n						if (i > 0) {\r\n							this.scribe.printNextToken(ITerminalSymbols.TokenNameCOMMA, spaceBeforeComma);\r\n							if (spaceAfterComma) {\r\n								this.scribe.space();\r\n							}\r\n						}\r\n						this.scribe.alignFragment(throwsAlignment, i + 1);\r\n						thrownExceptions[i].traverse(this, methodDeclaration.scope);\r\n					}\r\n					ok = true;\r\n				} catch (AlignmentException e) {\r\n					this.scribe.redoAlignment(e);\r\n				}\r\n			} while (!ok);\r\n			this.scribe.exitAlignment(throwsAlignment, true);\r\n		}\r\n	}\r\n\r\n	/*\r\n	 * Merged traversal of member (types, fields, methods)\r\n	 */\r\n	private void formatTypeMembers(TypeDeclaration typeDeclaration) {\r\n		final int FIELD = 1, METHOD = 2, TYPE = 3;\r\n		\r\n		Alignment memberAlignment = this.scribe.createAlignment(\"typeMembers\", this.preferences.type_member_alignment, 4, this.scribe.scanner.currentPosition); //$NON-NLS-1$\r\n		this.scribe.enterAlignment(memberAlignment);\r\n		AstNode[] members = computeMergedMemberDeclarations(typeDeclaration);\r\n		boolean isChunkStart = false;\r\n		boolean ok = false;\r\n		int startIndex = 0;\r\n		do {\r\n			try {\r\n				for (int i = startIndex, max = members.length; i < max; i++) {\r\n					AstNode member = members[i];\r\n					if (member instanceof FieldDeclaration) {\r\n						isChunkStart = memberAlignment.checkChunkStart(FIELD, i, this.scribe.scanner.currentPosition);\r\n						if (member instanceof MultiFieldDeclaration){\r\n							MultiFieldDeclaration multiField = (MultiFieldDeclaration) member;\r\n							\r\n							if (multiField.isStatic()) {\r\n								format(multiField, this, typeDeclaration.staticInitializerScope, isChunkStart);\r\n							} else {\r\n								format(multiField, this, typeDeclaration.initializerScope, isChunkStart);\r\n							}					\r\n						} else if (member instanceof Initializer) {\r\n							int newLineBeforeChunk = isChunkStart ? this.preferences.blank_lines_before_new_chunk : 0;\r\n							if (newLineBeforeChunk > 0) {\r\n								this.scribe.printNewLines(newLineBeforeChunk);\r\n							}\r\n							Initializer initializer = (Initializer) member;\r\n							if (initializer.isStatic()) {\r\n								initializer.traverse(this, typeDeclaration.staticInitializerScope);\r\n							} else {\r\n								initializer.traverse(this, typeDeclaration.initializerScope);\r\n							}					\r\n						} else {\r\n							FieldDeclaration field = (FieldDeclaration) member;\r\n							if (field.isStatic()) {\r\n								format(field, this, typeDeclaration.staticInitializerScope, isChunkStart);\r\n							} else {\r\n								format(field, this, typeDeclaration.initializerScope, isChunkStart);\r\n							}					\r\n						}\r\n					} else if (member instanceof AbstractMethodDeclaration) {\r\n						isChunkStart = memberAlignment.checkChunkStart(METHOD, i, this.scribe.scanner.currentPosition);\r\n						format((AbstractMethodDeclaration) member, typeDeclaration.scope, isChunkStart);\r\n					} else {\r\n						isChunkStart = memberAlignment.checkChunkStart(TYPE, i, this.scribe.scanner.currentPosition);\r\n						format((MemberTypeDeclaration)member, typeDeclaration.scope, isChunkStart);\r\n					}\r\n					if (isSemiColon()) {\r\n						this.scribe.printNextToken(ITerminalSymbols.TokenNameSEMICOLON, this.preferences.insert_space_before_semicolon);\r\n						this.scribe.printTrailingComment();\r\n						this.scribe.printNewLine();\r\n					}\r\n				}\r\n				ok = true;\r\n			} catch(AlignmentException e){\r\n				startIndex = memberAlignment.chunkStartIndex;\r\n				this.scribe.redoAlignment(e);\r\n			}\r\n		} while (!ok);		\r\n		this.scribe.exitAlignment(memberAlignment, true);\r\n	}\r\n\r\n	private void formatTypeOpeningBrace(String bracePosition, boolean insertSpaceBeforeBrace, TypeDeclaration typeDeclaration) {\r\n		int fieldCount = (typeDeclaration.fields == null) ? 0 : typeDeclaration.fields.length;\r\n		int methodCount = (typeDeclaration.methods == null) ? 0 : typeDeclaration.methods.length;\r\n		int typeCount = (typeDeclaration.memberTypes == null) ? 0 : typeDeclaration.memberTypes.length;\r\n	\r\n		if (methodCount == 1 && typeDeclaration.methods[0].isDefaultConstructor()) {\r\n			methodCount = 0;\r\n		}\r\n		final int memberLength = fieldCount+methodCount+typeCount;\r\n\r\n		boolean insertNewLine = memberLength > 0;\r\n		\r\n		if (!insertNewLine) {\r\n			if (typeDeclaration instanceof AnonymousLocalTypeDeclaration) {\r\n				insertNewLine = this.preferences.insert_new_line_in_empty_anonymous_type_declaration;\r\n			} else {\r\n				insertNewLine = this.preferences.insert_new_line_in_empty_type_declaration;\r\n			}\r\n		}\r\n	\r\n		formatOpeningBrace(bracePosition, insertSpaceBeforeBrace);\r\n		\r\n		if (insertNewLine) {\r\n			this.scribe.printNewLine();\r\n		}\r\n	}\r\n\r\n	private int getExtraDimension() {\r\n\r\n		this.localScanner.resetTo(this.scribe.scanner.currentPosition, this.scribe.scannerEndPosition - 1);\r\n		int dimensions = 0;\r\n		try {\r\n			int token;\r\n			while ((token = this.localScanner.getNextToken()) != ITerminalSymbols.TokenNameEOF) {\r\n				switch(token) {\r\n					case ITerminalSymbols.TokenNameRBRACKET://166 \r\n						dimensions++;\r\n						break;\r\n					case ITerminalSymbols.TokenNameIdentifier ://90						\r\n					case ITerminalSymbols.TokenNameLBRACE ://90						\r\n					case ITerminalSymbols.TokenNameLPAREN :\r\n					case ITerminalSymbols.TokenNameCOMMA ://90\r\n					case ITerminalSymbols.TokenNameEQUAL ://167\r\n					case ITerminalSymbols.TokenNameSEMICOLON ://64\r\n					case ITerminalSymbols.TokenNameRPAREN : //86\r\n						return dimensions;\r\n				}\r\n			}\r\n		} catch(InvalidInputException e) {\r\n		}\r\n		return dimensions;\r\n	}\r\n\r\n	private boolean isComma() {\r\n\r\n		this.localScanner.resetTo(this.scribe.scanner.currentPosition, this.scribe.scannerEndPosition - 1);\r\n		try {\r\n			return this.localScanner.getNextToken() == ITerminalSymbols.TokenNameCOMMA;\r\n		} catch(InvalidInputException e) {\r\n		}\r\n		return false;\r\n	}\r\n\r\n	private boolean isGuardClause(Block block) {\r\n		return block.statements != null \r\n				&& block.statements.length == 1\r\n				&& (block.statements[0] instanceof ReturnStatement\r\n					|| block.statements[0] instanceof ThrowStatement);\r\n	}	\r\n\r\n	private boolean isMultipleLocalDeclaration(LocalDeclaration localDeclaration) {\r\n\r\n		if (localDeclaration.declarationSourceStart == this.lastLocalDeclarationSourceStart) return true;\r\n		this.lastLocalDeclarationSourceStart = localDeclaration.declarationSourceStart;\r\n		return false;\r\n	}\r\n\r\n	private boolean isPartOfMultipleLocalDeclaration() {\r\n		this.localScanner.resetTo(this.scribe.scanner.currentPosition, this.scribe.scannerEndPosition - 1);\r\n		try {\r\n			int token;\r\n			while ((token = this.localScanner.getNextToken()) != ITerminalSymbols.TokenNameEOF) {\r\n				switch(token) {\r\n					case ITerminalSymbols.TokenNameCOMMA ://90\r\n						return true;\r\n					default:\r\n						return false;\r\n				}\r\n			}\r\n		} catch(InvalidInputException e) {\r\n		}\r\n		return false;\r\n	}\r\n\r\n	private boolean isSemiColon() {\r\n\r\n		this.localScanner.resetTo(this.scribe.scanner.currentPosition, this.scribe.scannerEndPosition - 1);\r\n		try {\r\n			return this.localScanner.getNextToken() == ITerminalSymbols.TokenNameSEMICOLON;\r\n		} catch(InvalidInputException e) {\r\n		}\r\n		return false;\r\n	}\r\n	\r\n	private void manageClosingParenthesizedExpression(Expression expression, int numberOfParens) {\r\n		for (int i = 0; i < numberOfParens; i++) {\r\n			this.scribe.printNextToken(ITerminalSymbols.TokenNameRPAREN, this.preferences.insert_space_before_closing_paren_in_parenthesized_expression);\r\n		}\r\n	}\r\n\r\n	private void manageOpeningParenthesizedExpression(Expression expression, int numberOfParens) {\r\n		for (int i = 0; i < numberOfParens; i++) {\r\n			this.scribe.printNextToken(ITerminalSymbols.TokenNameLPAREN, this.preferences.insert_space_before_open_paren_in_parenthesized_expression);\r\n			if (this.preferences.insert_space_after_open_paren_in_parenthesized_expression) {\r\n				this.scribe.space();\r\n			}\r\n		}\r\n	}\r\n			\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.AllocationExpression, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(\r\n		AllocationExpression allocationExpression,\r\n		BlockScope scope) {\r\n		// \'new\' ClassType \'(\' ArgumentListopt \')\' ClassBodyopt\r\n\r\n		final int numberOfParens = (allocationExpression.bits & AstNode.ParenthesizedMASK) >> AstNode.ParenthesizedSHIFT;\r\n		if (numberOfParens > 0) {\r\n			manageOpeningParenthesizedExpression(allocationExpression, numberOfParens);\r\n		}\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNamenew);\r\n		this.scribe.space();\r\n		allocationExpression.type.traverse(this, scope);\r\n		\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameLPAREN, this.preferences.insert_space_before_message_send);\r\n\r\n		final Expression[] arguments = allocationExpression.arguments;\r\n		if (arguments != null) {\r\n			int argumentLength = arguments.length;\r\n			Alignment argumentsAlignment =this.scribe.createAlignment(\r\n					\"allocation\",//$NON-NLS-1$\r\n					this.preferences.allocation_expression_arguments_alignment,\r\n					argumentLength,\r\n					this.scribe.scanner.currentPosition);\r\n			this.scribe.enterAlignment(argumentsAlignment);\r\n			boolean ok = false;\r\n			do {\r\n				try {\r\n					if (this.preferences.insert_space_within_message_send) {\r\n						this.scribe.space();\r\n					}\r\n					for (int i = 0; i < argumentLength; i++) {\r\n						if (i > 0) {\r\n							this.scribe.printNextToken(ITerminalSymbols.TokenNameCOMMA, this.preferences.insert_space_before_comma_in_allocation_expression);\r\n						}\r\n						this.scribe.alignFragment(argumentsAlignment, i);\r\n						if (i > 0 && this.preferences.insert_space_after_comma_in_allocation_expression) {\r\n							this.scribe.space();\r\n						}\r\n						arguments[i].traverse(this, scope);\r\n					}\r\n					ok = true;\r\n				} catch (AlignmentException e) {\r\n					this.scribe.redoAlignment(e);\r\n				}\r\n			} while (!ok);\r\n			this.scribe.exitAlignment(argumentsAlignment, true);\r\n			this.scribe.printNextToken(ITerminalSymbols.TokenNameRPAREN, this.preferences.insert_space_within_message_send); \r\n		} else {\r\n			this.scribe.printNextToken(ITerminalSymbols.TokenNameRPAREN, this.preferences.insert_space_between_empty_arguments); \r\n		}\r\n		\r\n		if (numberOfParens > 0) {\r\n			manageClosingParenthesizedExpression(allocationExpression, numberOfParens);\r\n		}\r\n		return false;\r\n	}\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.AND_AND_Expression, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(\r\n		AND_AND_Expression and_and_Expression,\r\n		BlockScope scope) {\r\n			\r\n		return dumpBinaryExpression(and_and_Expression, ITerminalSymbols.TokenNameAND_AND, scope);\r\n	}\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.AnonymousLocalTypeDeclaration, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(\r\n		AnonymousLocalTypeDeclaration anonymousTypeDeclaration,\r\n		BlockScope scope) {\r\n			\r\n		/*\r\n		 * Type body\r\n		 */\r\n		String anonymous_type_declaration_brace_position = this.preferences.anonymous_type_declaration_brace_position;\r\n		formatTypeOpeningBrace(anonymous_type_declaration_brace_position, this.preferences.insert_space_before_anonymous_type_open_brace, anonymousTypeDeclaration);\r\n		\r\n		this.scribe.indent();\r\n\r\n		formatTypeMembers(anonymousTypeDeclaration);\r\n		\r\n		this.scribe.printComment();\r\n		this.scribe.unIndent();\r\n		if (this.preferences.insert_new_line_in_empty_anonymous_type_declaration) {\r\n			this.scribe.printNewLine();\r\n		}\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameRBRACE);\r\n		if (anonymous_type_declaration_brace_position.equals(FormattingPreferences.NEXT_LINE_SHIFTED)) {\r\n			this.scribe.unIndent();\r\n		}\r\n		return false;\r\n	}\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.Argument, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(Argument argument, BlockScope scope) {\r\n\r\n		if (argument.modifiers != NO_MODIFIERS) {\r\n			this.scribe.printModifiers();\r\n			this.scribe.space();\r\n		}\r\n\r\n		/*\r\n		 * Argument type \r\n		 */		\r\n		if (argument.type != null) {\r\n			argument.type.traverse(this, scope);\r\n		}\r\n		\r\n		/*\r\n		 * Print the argument name\r\n		 */	\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameIdentifier, true);\r\n\r\n\r\n		/*\r\n		 * Check for extra dimensions\r\n		 */\r\n		int extraDimensions = getExtraDimension();\r\n		if (extraDimensions != 0) {\r\n			 for (int i = 0; i < extraDimensions; i++) {\r\n			 	this.scribe.printNextToken(ITerminalSymbols.TokenNameLBRACKET);\r\n			 	this.scribe.printNextToken(ITerminalSymbols.TokenNameRBRACKET);\r\n			 }\r\n		}\r\n		\r\n		return false;\r\n	}\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.ArrayAllocationExpression, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(\r\n		ArrayAllocationExpression arrayAllocationExpression,\r\n		BlockScope scope) {\r\n\r\n			final int numberOfParens = (arrayAllocationExpression.bits & AstNode.ParenthesizedMASK) >> AstNode.ParenthesizedSHIFT;\r\n			if (numberOfParens > 0) {\r\n				manageOpeningParenthesizedExpression(arrayAllocationExpression, numberOfParens);\r\n			}\r\n			this.scribe.printNextToken(ITerminalSymbols.TokenNamenew);\r\n			this.scribe.space();\r\n			arrayAllocationExpression.type.traverse(this, scope);\r\n			\r\n			final Expression[] dimensions = arrayAllocationExpression.dimensions;\r\n			int dimensionsLength = dimensions.length;\r\n			for (int i = 0; i < dimensionsLength; i++) {\r\n				this.scribe.printNextToken(ITerminalSymbols.TokenNameLBRACKET);\r\n				if (dimensions[i] != null) {\r\n					dimensions[i].traverse(this, scope);\r\n				}\r\n				this.scribe.printNextToken(ITerminalSymbols.TokenNameRBRACKET);\r\n			}\r\n			final ArrayInitializer initializer = arrayAllocationExpression.initializer;\r\n			if (initializer != null) {\r\n				initializer.traverse(this, scope);\r\n			}\r\n\r\n			if (numberOfParens > 0) {\r\n				manageClosingParenthesizedExpression(arrayAllocationExpression, numberOfParens);\r\n			}\r\n			return false;\r\n	}\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.ArrayInitializer, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(ArrayInitializer arrayInitializer, BlockScope scope) {\r\n\r\n		final int numberOfParens = (arrayInitializer.bits & AstNode.ParenthesizedMASK) >> AstNode.ParenthesizedSHIFT;\r\n		if (numberOfParens > 0) {\r\n			manageOpeningParenthesizedExpression(arrayInitializer, numberOfParens);\r\n		}\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameLBRACE);\r\n		\r\n		final Expression[] expressions = arrayInitializer.expressions;\r\n		if (expressions != null) {\r\n			int expressionsLength = expressions.length;\r\n			if (expressionsLength > 1) {\r\n				Alignment expressionsAlignment =this.scribe.createAlignment(\r\n						\"expressions\",//$NON-NLS-1$\r\n						this.preferences.array_initializer_expressions_alignment,\r\n						expressionsLength - 1,\r\n						this.scribe.scanner.currentPosition);\r\n				this.scribe.enterAlignment(expressionsAlignment);\r\n				boolean ok = false;\r\n				do {\r\n					try {\r\n						if (this.preferences.insert_space_before_first_initializer) {\r\n							this.scribe.space();\r\n						}\r\n						expressions[0].traverse(this, scope);\r\n						for (int i = 1; i < expressionsLength; i++) {\r\n							this.scribe.printNextToken(ITerminalSymbols.TokenNameCOMMA, this.preferences.insert_space_before_comma_in_array_initializer);\r\n							if (this.preferences.insert_space_after_comma_in_array_initializer) {\r\n								this.scribe.space();\r\n							}\r\n							this.scribe.alignFragment(expressionsAlignment, i - 1);\r\n							expressions[i].traverse(this, scope);\r\n						}\r\n						ok = true;\r\n					} catch (AlignmentException e) {\r\n						this.scribe.redoAlignment(e);\r\n					}\r\n				} while (!ok);\r\n				this.scribe.exitAlignment(expressionsAlignment, true);\r\n			} else {\r\n				// we don\'t need to use an alignment\r\n				if (this.preferences.insert_space_before_first_initializer) {\r\n					this.scribe.space();\r\n				}\r\n				expressions[0].traverse(this, scope);\r\n				for (int i = 1; i < expressionsLength; i++) {\r\n					this.scribe.printNextToken(ITerminalSymbols.TokenNameCOMMA, this.preferences.insert_space_before_comma_in_array_initializer);\r\n					if (this.preferences.insert_space_after_comma_in_array_initializer) {\r\n						this.scribe.space();\r\n					}\r\n					expressions[i].traverse(this, scope);\r\n				}\r\n			}\r\n			if (isComma()) {\r\n				this.scribe.printNextToken(ITerminalSymbols.TokenNameCOMMA, this.preferences.insert_space_before_comma_in_array_initializer);\r\n			}\r\n			this.scribe.printNextToken(ITerminalSymbols.TokenNameRBRACE, this.preferences.insert_space_before_closing_brace_in_array_initializer, true); \r\n		} else {\r\n			this.scribe.printNextToken(ITerminalSymbols.TokenNameRBRACE, this.preferences.insert_space_between_empty_array_initializer, true);\r\n		}\r\n\r\n		if (numberOfParens > 0) {\r\n			manageClosingParenthesizedExpression(arrayInitializer, numberOfParens);\r\n		}\r\n		return false;\r\n	}\r\n	\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.ArrayQualifiedTypeReference, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(\r\n		ArrayQualifiedTypeReference arrayQualifiedTypeReference,\r\n		BlockScope scope) {\r\n\r\n			final int numberOfParens = (arrayQualifiedTypeReference.bits & AstNode.ParenthesizedMASK) >> AstNode.ParenthesizedSHIFT;\r\n			if (numberOfParens > 0) {\r\n				manageOpeningParenthesizedExpression(arrayQualifiedTypeReference, numberOfParens);\r\n			}\r\n			this.scribe.printQualifiedReference(arrayQualifiedTypeReference.sourceEnd - 1);\r\n			int dimensions = getExtraDimension();\r\n			if (dimensions != 0) {\r\n				for (int i = 0; i < dimensions; i++) {\r\n					this.scribe.printNextToken(ITerminalSymbols.TokenNameLBRACKET);\r\n					this.scribe.printNextToken(ITerminalSymbols.TokenNameRBRACKET);\r\n				}\r\n			}\r\n			if (numberOfParens > 0) {\r\n				manageClosingParenthesizedExpression(arrayQualifiedTypeReference, numberOfParens);\r\n			}\r\n			return false;\r\n	}\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.ArrayQualifiedTypeReference, org.eclipse.jdt.internal.compiler.lookup.ClassScope)\r\n	 */\r\n	public boolean visit(\r\n		ArrayQualifiedTypeReference arrayQualifiedTypeReference,\r\n		ClassScope scope) {\r\n\r\n			final int numberOfParens = (arrayQualifiedTypeReference.bits & AstNode.ParenthesizedMASK) >> AstNode.ParenthesizedSHIFT;\r\n			if (numberOfParens > 0) {\r\n				manageOpeningParenthesizedExpression(arrayQualifiedTypeReference, numberOfParens);\r\n			}\r\n			this.scribe.printQualifiedReference(arrayQualifiedTypeReference.sourceEnd - 1);\r\n			int dimensions = getExtraDimension();\r\n			if (dimensions != 0) {\r\n				for (int i = 0; i < dimensions; i++) {\r\n					this.scribe.printNextToken(ITerminalSymbols.TokenNameLBRACKET);\r\n					this.scribe.printNextToken(ITerminalSymbols.TokenNameRBRACKET);\r\n				}\r\n			}\r\n			if (numberOfParens > 0) {\r\n				manageClosingParenthesizedExpression(arrayQualifiedTypeReference, numberOfParens);\r\n			}\r\n			return false;\r\n	}\r\n\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.ArrayReference, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(ArrayReference arrayReference, BlockScope scope) {\r\n\r\n		final int numberOfParens = (arrayReference.bits & AstNode.ParenthesizedMASK) >> AstNode.ParenthesizedSHIFT;\r\n		if (numberOfParens > 0) {\r\n			manageOpeningParenthesizedExpression(arrayReference, numberOfParens);\r\n		}\r\n		arrayReference.receiver.traverse(this, scope);\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameLBRACKET);\r\n		arrayReference.position.traverse(this, scope);\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameRBRACKET);\r\n		\r\n		if (numberOfParens > 0) {\r\n			manageClosingParenthesizedExpression(arrayReference, numberOfParens);\r\n		}\r\n		return false;\r\n	}\r\n	\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.ArrayTypeReference, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(\r\n		ArrayTypeReference arrayTypeReference,\r\n		BlockScope scope) {\r\n\r\n		final int numberOfParens = (arrayTypeReference.bits & AstNode.ParenthesizedMASK) >> AstNode.ParenthesizedSHIFT;\r\n		if (numberOfParens > 0) {\r\n			manageOpeningParenthesizedExpression(arrayTypeReference, numberOfParens);\r\n		}\r\n		this.scribe.printNextToken(SINGLETYPEREFERENCE_EXPECTEDTOKENS, false, true);\r\n		\r\n		int dimensions = getExtraDimension();\r\n		if (dimensions != 0) {\r\n			if (this.preferences.insert_space_before_bracket_in_array_type_reference) {\r\n				this.scribe.space();\r\n			}\r\n			for (int i = 0; i < dimensions; i++) {\r\n				this.scribe.printNextToken(ITerminalSymbols.TokenNameLBRACKET);\r\n				if (this.preferences.insert_space_between_brackets_in_array_type_reference) {\r\n					this.scribe.space();\r\n				}\r\n				this.scribe.printNextToken(ITerminalSymbols.TokenNameRBRACKET);\r\n			}\r\n		}\r\n		if (numberOfParens > 0) {\r\n			manageClosingParenthesizedExpression(arrayTypeReference, numberOfParens);\r\n		}\r\n		return false;\r\n	}\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.ArrayTypeReference, org.eclipse.jdt.internal.compiler.lookup.ClassScope)\r\n	 */\r\n	public boolean visit(\r\n		ArrayTypeReference arrayTypeReference,\r\n		ClassScope scope) {\r\n\r\n		final int numberOfParens = (arrayTypeReference.bits & AstNode.ParenthesizedMASK) >> AstNode.ParenthesizedSHIFT;\r\n		if (numberOfParens > 0) { \r\n			manageOpeningParenthesizedExpression(arrayTypeReference, numberOfParens);\r\n		}\r\n		this.scribe.printNextToken(SINGLETYPEREFERENCE_EXPECTEDTOKENS, false, true);\r\n		int dimensions = getExtraDimension();\r\n		if (dimensions != 0) {\r\n			if (this.preferences.insert_space_before_bracket_in_array_type_reference) {\r\n				this.scribe.space();\r\n			}\r\n			for (int i = 0; i < dimensions; i++) {\r\n				this.scribe.printNextToken(ITerminalSymbols.TokenNameLBRACKET);\r\n				if (this.preferences.insert_space_between_brackets_in_array_type_reference) {\r\n					this.scribe.space();\r\n				}\r\n				this.scribe.printNextToken(ITerminalSymbols.TokenNameRBRACKET);\r\n			}\r\n		}\r\n		if (numberOfParens > 0) {\r\n			manageClosingParenthesizedExpression(arrayTypeReference, numberOfParens);\r\n		}\r\n		return false;\r\n	}\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.AssertStatement, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(AssertStatement assertStatement, BlockScope scope) {\r\n		\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameassert);\r\n		this.scribe.space();\r\n		assertStatement.assertExpression.traverse(this, scope);\r\n		\r\n		if (assertStatement.exceptionArgument != null) {\r\n			this.scribe.printNextToken(ITerminalSymbols.TokenNameCOLON, this.preferences.insert_space_before_colon_in_assert);\r\n			if (this.preferences.insert_space_after_colon_in_assert) {\r\n				this.scribe.space();\r\n			}\r\n			assertStatement.exceptionArgument.traverse(this, scope);\r\n		}\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameSEMICOLON, this.preferences.insert_space_before_semicolon);		\r\n		return false;\r\n	}\r\n	\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.Assignment, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(Assignment assignment, BlockScope scope) {\r\n\r\n		final int numberOfParens = (assignment.bits & AstNode.ParenthesizedMASK) >> AstNode.ParenthesizedSHIFT;\r\n		if (numberOfParens > 0) {\r\n			manageOpeningParenthesizedExpression(assignment, numberOfParens);\r\n		}\r\n		assignment.lhs.traverse(this, scope);\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameEQUAL, this.preferences.insert_space_before_assignment_operators);\r\n		if (this.preferences.insert_space_after_assignment_operators) {\r\n			this.scribe.space();\r\n		}\r\n		assignment.expression.traverse(this, scope);\r\n		\r\n		if (numberOfParens > 0) {\r\n			manageClosingParenthesizedExpression(assignment, numberOfParens);\r\n		}\r\n		return false;\r\n	}\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.BinaryExpression, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(BinaryExpression binaryExpression, BlockScope scope) {\r\n\r\n		switch((binaryExpression.bits & AstNode.OperatorMASK) >> AstNode.OperatorSHIFT) {\r\n			case OperatorIds.AND :\r\n				return dumpBinaryExpression(binaryExpression, ITerminalSymbols.TokenNameAND, scope);\r\n			case OperatorIds.DIVIDE :\r\n				return dumpBinaryExpression(binaryExpression, ITerminalSymbols.TokenNameDIVIDE, scope);\r\n			case OperatorIds.GREATER :\r\n				return dumpBinaryExpression(binaryExpression, ITerminalSymbols.TokenNameGREATER, scope);\r\n			case OperatorIds.GREATER_EQUAL :\r\n				return dumpBinaryExpression(binaryExpression, ITerminalSymbols.TokenNameGREATER_EQUAL, scope);\r\n			case OperatorIds.LEFT_SHIFT :\r\n				return dumpBinaryExpression(binaryExpression, ITerminalSymbols.TokenNameLEFT_SHIFT, scope);\r\n			case OperatorIds.LESS :\r\n				return dumpBinaryExpression(binaryExpression, ITerminalSymbols.TokenNameLESS, scope);\r\n			case OperatorIds.LESS_EQUAL :\r\n				return dumpBinaryExpression(binaryExpression, ITerminalSymbols.TokenNameLESS_EQUAL, scope);\r\n			case OperatorIds.MINUS :\r\n				return dumpBinaryExpression(binaryExpression, ITerminalSymbols.TokenNameMINUS, scope);\r\n			case OperatorIds.MULTIPLY :\r\n				return dumpBinaryExpression(binaryExpression, ITerminalSymbols.TokenNameMULTIPLY, scope);\r\n			case OperatorIds.OR :\r\n				return dumpBinaryExpression(binaryExpression, ITerminalSymbols.TokenNameOR, scope);\r\n			case OperatorIds.PLUS :\r\n				return dumpBinaryExpression(binaryExpression, ITerminalSymbols.TokenNamePLUS, scope);\r\n			case OperatorIds.REMAINDER :\r\n				return dumpBinaryExpression(binaryExpression, ITerminalSymbols.TokenNameREMAINDER, scope);\r\n			case OperatorIds.RIGHT_SHIFT :\r\n				return dumpBinaryExpression(binaryExpression, ITerminalSymbols.TokenNameRIGHT_SHIFT, scope);\r\n			case OperatorIds.UNSIGNED_RIGHT_SHIFT :\r\n				return dumpBinaryExpression(binaryExpression, ITerminalSymbols.TokenNameUNSIGNED_RIGHT_SHIFT, scope);\r\n			case OperatorIds.XOR :\r\n				return dumpBinaryExpression(binaryExpression, ITerminalSymbols.TokenNameXOR, scope);\r\n			default:\r\n				throw new IllegalStateException();\r\n		}\r\n	}\r\n	\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.Block, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(Block block, BlockScope scope) {\r\n	\r\n		String block_brace_position = this.preferences.block_brace_position;\r\n		formatOpeningBrace(block_brace_position, this.preferences.insert_space_before_block_open_brace);\r\n		this.scribe.indent();\r\n	\r\n		final Statement[] statements = block.statements;\r\n		if (statements != null) {\r\n			this.scribe.printTrailingComment();\r\n			this.scribe.printNewLine();\r\n			formatStatements(scope, statements);\r\n		} else if (this.preferences.insert_new_line_in_empty_block) {\r\n			this.scribe.printNewLine();\r\n		}\r\n		this.scribe.printComment();\r\n\r\n		this.scribe.unIndent();\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameRBRACE);\r\n		this.scribe.printTrailingComment();\r\n		this.scribe.printNewLine();\r\n	\r\n		if (block_brace_position.equals(FormattingPreferences.NEXT_LINE_SHIFTED)) {\r\n			this.scribe.unIndent();\r\n		}		\r\n		return false;	\r\n	}\r\n\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.Break, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(BreakStatement breakStatement, BlockScope scope) {\r\n		\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNamebreak);\r\n		if (breakStatement.label != null) {\r\n			this.scribe.printNextToken(ITerminalSymbols.TokenNameIdentifier, true);\r\n		}\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameSEMICOLON, this.preferences.insert_space_before_semicolon);\r\n		return false;\r\n	}\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.Case, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(CaseStatement caseStatement, BlockScope scope) {		\r\n		if (caseStatement.constantExpression == null) {\r\n			this.scribe.printNextToken(ITerminalSymbols.TokenNamedefault);\r\n			this.scribe.printNextToken(ITerminalSymbols.TokenNameCOLON, this.preferences.insert_space_before_colon_in_default);\r\n		} else {\r\n			this.scribe.printNextToken(ITerminalSymbols.TokenNamecase);\r\n			this.scribe.space();\r\n			caseStatement.constantExpression.traverse(this, scope);\r\n			this.scribe.printNextToken(ITerminalSymbols.TokenNameCOLON, this.preferences.insert_space_before_colon_in_case);\r\n		}\r\n		return false;\r\n	}\r\n\r\n\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.CastExpression, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(CastExpression castExpression, BlockScope scope) {\r\n\r\n		final int numberOfParens = (castExpression.bits & AstNode.ParenthesizedMASK) >> AstNode.ParenthesizedSHIFT;\r\n		if (numberOfParens > 0) {\r\n			manageOpeningParenthesizedExpression(castExpression, numberOfParens);\r\n		}\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameLPAREN);\r\n		if (this.preferences.insert_space_after_opening_paren_in_cast) {\r\n			this.scribe.space();\r\n		}\r\n		castExpression.type.traverse(this, scope);\r\n\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameRPAREN, this.preferences.insert_space_before_closing_paren_in_cast);\r\n		if (this.preferences.insert_space_after_closing_paren_in_cast) {\r\n			this.scribe.space();\r\n		}\r\n		castExpression.expression.traverse(this, scope);\r\n		\r\n		if (numberOfParens > 0) {\r\n			manageClosingParenthesizedExpression(castExpression, numberOfParens);\r\n		}\r\n		return false;\r\n	}\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.CharLiteral, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(CharLiteral charLiteral, BlockScope scope) {\r\n\r\n		final int numberOfParens = (charLiteral.bits & AstNode.ParenthesizedMASK) >> AstNode.ParenthesizedSHIFT;\r\n		if (numberOfParens > 0) {\r\n			manageOpeningParenthesizedExpression(charLiteral, numberOfParens);\r\n		}\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameCharacterLiteral);\r\n\r\n		if (numberOfParens > 0) {\r\n			manageClosingParenthesizedExpression(charLiteral, numberOfParens);\r\n		}\r\n		return false;\r\n	}\r\n\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.ClassLiteralAccess, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(ClassLiteralAccess classLiteral, BlockScope scope) {\r\n\r\n		final int numberOfParens = (classLiteral.bits & AstNode.ParenthesizedMASK) >> AstNode.ParenthesizedSHIFT;\r\n		if (numberOfParens > 0) {\r\n			manageOpeningParenthesizedExpression(classLiteral, numberOfParens);\r\n		}\r\n		classLiteral.type.traverse(this, scope);\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameDOT);\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameclass);\r\n		\r\n		if (numberOfParens > 0) {\r\n			manageClosingParenthesizedExpression(classLiteral, numberOfParens);\r\n		}\r\n		return false;\r\n	}\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.Clinit, org.eclipse.jdt.internal.compiler.lookup.ClassScope)\r\n	 */\r\n	public boolean visit(Clinit clinit, ClassScope scope) {\r\n\r\n		return false;\r\n	}\r\n	\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration, org.eclipse.jdt.internal.compiler.lookup.CompilationUnitScope)\r\n	 */\r\n	public boolean visit(\r\n		CompilationUnitDeclaration compilationUnitDeclaration,\r\n		CompilationUnitScope scope) {\r\n		\r\n		/* \r\n		 * Package declaration\r\n		 */\r\n		if (compilationUnitDeclaration.currentPackage != null) {\r\n			// OPTION\r\n			// dump the package keyword\r\n			int blankLinesBeforePackage = this.preferences.blank_lines_before_package;\r\n			if (blankLinesBeforePackage > 0) {\r\n				this.scribe.printNewLines(blankLinesBeforePackage - 1);\r\n			}\r\n			this.scribe.printComment();\r\n			this.scribe.printNextToken(ITerminalSymbols.TokenNamepackage);\r\n			this.scribe.space();\r\n			this.scribe.printQualifiedReference(compilationUnitDeclaration.currentPackage.sourceEnd);\r\n			this.scribe.printNextToken(ITerminalSymbols.TokenNameSEMICOLON, this.preferences.insert_space_before_semicolon);\r\n			this.scribe.printTrailingComment();\r\n			int blankLinesAfterPackage = this.preferences.blank_lines_after_package;\r\n			if (blankLinesAfterPackage > 0) {\r\n				this.scribe.printNewLines(blankLinesAfterPackage);\r\n			}				\r\n		} else {\r\n			this.scribe.printComment();\r\n		}\r\n		\r\n		/*\r\n		 * Import statements\r\n		 */\r\n		final ImportReference[] imports = compilationUnitDeclaration.imports;\r\n		if (imports != null) {\r\n			int blankLinesBeforeImports = this.preferences.blank_lines_before_imports;\r\n			if (blankLinesBeforeImports > 0) {\r\n				this.scribe.printNewLines(blankLinesBeforeImports);\r\n			}\r\n			int importLength = imports.length;\r\n			for (int i = 0; i < importLength; i++) {\r\n				imports[i].traverse(this, scope);\r\n			}			\r\n			\r\n			int blankLinesAfterImports = this.preferences.blank_lines_after_imports;\r\n			if (blankLinesAfterImports > 0) {\r\n				this.scribe.printNewLines(blankLinesAfterImports);\r\n			}\r\n		}\r\n\r\n		/*\r\n		 * Type declarations\r\n		 */\r\n		final TypeDeclaration[] types = compilationUnitDeclaration.types;\r\n		if (types != null) {\r\n			int typesLength = types.length;\r\n			for (int i = 0; i < typesLength; i++) {\r\n				types[i].traverse(this, scope);\r\n			}\r\n		}\r\n		this.scribe.printComment();\r\n		return false;\r\n	}\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.CompoundAssignment, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(\r\n		CompoundAssignment compoundAssignment,\r\n		BlockScope scope) {\r\n			\r\n		final int numberOfParens = (compoundAssignment.bits & AstNode.ParenthesizedMASK) >> AstNode.ParenthesizedSHIFT;\r\n		if (numberOfParens > 0) {\r\n			manageOpeningParenthesizedExpression(compoundAssignment, numberOfParens);\r\n		}\r\n		compoundAssignment.lhs.traverse(this, scope);\r\n		\r\n		/*\r\n		 * Print the operator\r\n		 */\r\n		int operator;\r\n		switch(compoundAssignment.operator) {\r\n			case OperatorIds.PLUS :\r\n				operator = ITerminalSymbols.TokenNamePLUS_EQUAL;\r\n				break;\r\n			case OperatorIds.MINUS :\r\n				operator = ITerminalSymbols.TokenNameMINUS_EQUAL;\r\n				break;\r\n			case OperatorIds.MULTIPLY :\r\n				operator = ITerminalSymbols.TokenNameMULTIPLY_EQUAL;\r\n				break;\r\n			case OperatorIds.DIVIDE :\r\n				operator = ITerminalSymbols.TokenNameDIVIDE_EQUAL;\r\n				break;\r\n			case OperatorIds.AND :\r\n				operator = ITerminalSymbols.TokenNameAND_EQUAL;\r\n				break;\r\n			case OperatorIds.OR :\r\n				operator = ITerminalSymbols.TokenNameOR_EQUAL;\r\n				break;\r\n			case OperatorIds.XOR :\r\n				operator = ITerminalSymbols.TokenNameXOR_EQUAL;\r\n				break;\r\n			case OperatorIds.REMAINDER :\r\n				operator = ITerminalSymbols.TokenNameREMAINDER_EQUAL;\r\n				break;\r\n			case OperatorIds.LEFT_SHIFT :\r\n				operator = ITerminalSymbols.TokenNameLEFT_SHIFT_EQUAL;\r\n				break;\r\n			case OperatorIds.RIGHT_SHIFT :\r\n				operator = ITerminalSymbols.TokenNameRIGHT_SHIFT_EQUAL;\r\n				break;\r\n			default: // OperatorIds.UNSIGNED_RIGHT_SHIFT :\r\n				operator = ITerminalSymbols.TokenNameUNSIGNED_RIGHT_SHIFT_EQUAL;\r\n		}\r\n		\r\n		this.scribe.printNextToken(operator, this.preferences.insert_space_before_assignment_operators);\r\n		if (this.preferences.insert_space_after_assignment_operators) {\r\n			this.scribe.space();\r\n		}\r\n		compoundAssignment.expression.traverse(this, scope);\r\n		\r\n		if (numberOfParens > 0) {\r\n			manageClosingParenthesizedExpression(compoundAssignment, numberOfParens);\r\n		}\r\n		return false;\r\n	}\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.ConditionalExpression, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(\r\n		ConditionalExpression conditionalExpression,\r\n		BlockScope scope) {\r\n\r\n		final int numberOfParens = (conditionalExpression.bits & AstNode.ParenthesizedMASK) >> AstNode.ParenthesizedSHIFT;\r\n		if (numberOfParens > 0) {\r\n			manageOpeningParenthesizedExpression(conditionalExpression, numberOfParens);\r\n		}\r\n		conditionalExpression.condition.traverse(this, scope);\r\n\r\n		Alignment conditionalExpressionAlignment =this.scribe.createAlignment(\r\n				\"conditionalExpression\", //$NON-NLS-1$\r\n				this.preferences.conditional_expression_alignment,\r\n				2,\r\n				this.scribe.scanner.currentPosition);\r\n\r\n		this.scribe.enterAlignment(conditionalExpressionAlignment);\r\n		boolean ok = false;\r\n		do {\r\n			try {\r\n				this.scribe.alignFragment(conditionalExpressionAlignment, 0);\r\n				this.scribe.printNextToken(ITerminalSymbols.TokenNameQUESTION, this.preferences.insert_space_before_question_in_conditional);\r\n\r\n				if (this.preferences.insert_space_after_question_in_conditional) {\r\n					this.scribe.space();\r\n				}\r\n				conditionalExpression.valueIfTrue.traverse(this, scope);\r\n\r\n				this.scribe.alignFragment(conditionalExpressionAlignment, 1);\r\n				this.scribe.printNextToken(ITerminalSymbols.TokenNameCOLON, this.preferences.insert_space_before_colon_in_conditional);\r\n\r\n				if (this.preferences.insert_space_after_colon_in_conditional) {\r\n					this.scribe.space();\r\n				}\r\n				conditionalExpression.valueIfFalse.traverse(this, scope);\r\n\r\n				ok = true;\r\n			} catch (AlignmentException e) {\r\n				this.scribe.redoAlignment(e);\r\n			}\r\n		} while (!ok);\r\n		this.scribe.exitAlignment(conditionalExpressionAlignment, true);\r\n			\r\n		if (numberOfParens > 0) {\r\n			manageClosingParenthesizedExpression(conditionalExpression, numberOfParens);\r\n		}\r\n		return false;	\r\n	}\r\n\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.ConstructorDeclaration, org.eclipse.jdt.internal.compiler.lookup.ClassScope)\r\n	 */\r\n	public boolean visit(\r\n		ConstructorDeclaration constructorDeclaration,\r\n		ClassScope scope) {\r\n			\r\n		if (constructorDeclaration.modifiers != NO_MODIFIERS) {\r\n			this.scribe.printModifiers();\r\n		} else {\r\n			this.scribe.printComment();\r\n		}			\r\n		/*\r\n		 * Print the method name\r\n		 */	\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameIdentifier, true); \r\n\r\n		formatMethodArguments(\r\n			constructorDeclaration, \r\n			this.preferences.insert_space_before_method_declaration_open_paren,\r\n			this.preferences.insert_space_between_empty_arguments,\r\n			this.preferences.insert_space_before_closing_paren,\r\n			this.preferences.insert_space_before_first_argument,\r\n			this.preferences.insert_space_before_comma_in_constructor_arguments,\r\n			this.preferences.insert_space_after_comma_in_constructor_arguments);\r\n\r\n		formatThrowsClause(\r\n				constructorDeclaration,\r\n				this.preferences.insert_space_before_comma_in_constructor_throws,\r\n				this.preferences.insert_space_after_comma_in_constructor_throws);\r\n\r\n		if (!constructorDeclaration.isNative() && !constructorDeclaration.isAbstract()) {\r\n			/*\r\n			 * Method body\r\n			 */\r\n			String method_declaration_brace = this.preferences.method_declaration_brace_position;\r\n			formatOpeningBrace(method_declaration_brace, this.preferences.insert_space_before_method_open_brace);\r\n			this.scribe.indent();			\r\n			final int numberOfBlankLinesAtBeginningOfMethodBody = this.preferences.number_of_blank_lines_to_insert_at_beginning_of_method_body;\r\n			if (numberOfBlankLinesAtBeginningOfMethodBody > 0) {\r\n				this.scribe.printNewLines(numberOfBlankLinesAtBeginningOfMethodBody);\r\n			}\r\n			if (constructorDeclaration.constructorCall != null && !constructorDeclaration.constructorCall.isImplicitSuper()) {\r\n				this.scribe.printNewLine();\r\n				constructorDeclaration.constructorCall.traverse(this, constructorDeclaration.scope);\r\n				this.scribe.printNextToken(ITerminalSymbols.TokenNameSEMICOLON, this.preferences.insert_space_before_semicolon);\r\n				this.scribe.printTrailingComment();\r\n			}\r\n			final Statement[] statements = constructorDeclaration.statements;\r\n			if (statements != null) {\r\n				this.scribe.printNewLine();\r\n				formatStatements(constructorDeclaration.scope, statements);\r\n			} else if (this.preferences.insert_new_line_in_empty_method_body) {\r\n				this.scribe.printNewLine();\r\n			}\r\n			this.scribe.printComment();\r\n			this.scribe.unIndent();\r\n			this.scribe.printNextToken(ITerminalSymbols.TokenNameRBRACE);\r\n			this.scribe.printTrailingComment();\r\n			if (method_declaration_brace.equals(FormattingPreferences.NEXT_LINE_SHIFTED)) {\r\n				this.scribe.unIndent();\r\n			}\r\n		} else {\r\n			// no method body\r\n			this.scribe.printNextToken(ITerminalSymbols.TokenNameSEMICOLON, this.preferences.insert_space_before_semicolon);\r\n			this.scribe.printTrailingComment();\r\n		}\r\n		return false;\r\n	}\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.Continue, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(ContinueStatement continueStatement, BlockScope scope) {\r\n\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNamecontinue);\r\n		if (continueStatement.label != null) {\r\n			this.scribe.printNextToken(ITerminalSymbols.TokenNameIdentifier, true);\r\n		}\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameSEMICOLON, this.preferences.insert_space_before_semicolon);\r\n		return false;\r\n	}\r\n\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.DoStatement, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(DoStatement doStatement, BlockScope scope) {\r\n\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNamedo);\r\n		\r\n		final Statement action = doStatement.action;\r\n		if (action != null) {\r\n			if (action instanceof Block) {\r\n				action.traverse(this, scope);\r\n			} else {\r\n				this.scribe.printNewLine();\r\n				this.scribe.indent();\r\n				action.traverse(this, scope);\r\n				this.scribe.unIndent();\r\n			}\r\n			if (action instanceof Expression) {\r\n				this.scribe.printNextToken(ITerminalSymbols.TokenNameSEMICOLON, this.preferences.insert_space_before_semicolon);\r\n				this.scribe.printTrailingComment();\r\n			} else if (action instanceof Block && this.preferences.insert_new_line_in_control_statements) {\r\n				this.scribe.printTrailingComment();\r\n			}\r\n		} else {\r\n			this.scribe.indent();\r\n			/*\r\n			 * This is an empty statement\r\n			 */\r\n			formatEmptyStatement(); \r\n			this.scribe.unIndent();\r\n		}\r\n		\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNamewhile, this.preferences.insert_space_after_block_close_brace);\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameLPAREN, this.preferences.insert_space_before_while_condition);\r\n		\r\n		if (this.preferences.insert_space_in_while_condition) {\r\n			this.scribe.space();\r\n		}\r\n		\r\n		doStatement.condition.traverse(this, scope);\r\n		\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameRPAREN, this.preferences.insert_space_in_while_condition);\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameSEMICOLON, this.preferences.insert_space_before_semicolon);\r\n		return false;\r\n	}\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.DoubleLiteral, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(DoubleLiteral doubleLiteral, BlockScope scope) {\r\n\r\n		final int numberOfParens = (doubleLiteral.bits & AstNode.ParenthesizedMASK) >> AstNode.ParenthesizedSHIFT;\r\n		if (numberOfParens > 0) {\r\n			manageOpeningParenthesizedExpression(doubleLiteral, numberOfParens);\r\n		}\r\n		Constant constant = doubleLiteral.constant;\r\n		if (constant != null && constant.doubleValue() < 0) {\r\n			this.scribe.printNextToken(ITerminalSymbols.TokenNameMINUS);			\r\n		}\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameDoubleLiteral);\r\n\r\n		if (numberOfParens > 0) {\r\n			manageClosingParenthesizedExpression(doubleLiteral, numberOfParens);\r\n		}\r\n		return false;\r\n	}\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.EmptyStatement, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(EmptyStatement statement, BlockScope scope) {\r\n\r\n		formatEmptyStatement();\r\n		return false;	\r\n	}\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.EqualExpression, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(EqualExpression equalExpression, BlockScope scope) {\r\n\r\n		if ((equalExpression.bits & AstNode.OperatorMASK) >> AstNode.OperatorSHIFT == OperatorIds.EQUAL_EQUAL) {\r\n			return dumpBinaryExpression(equalExpression, ITerminalSymbols.TokenNameEQUAL_EQUAL, scope);\r\n		} else {\r\n			return dumpBinaryExpression(equalExpression, ITerminalSymbols.TokenNameNOT_EQUAL, scope);\r\n		}			\r\n	}\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.ExplicitConstructorCall, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(\r\n		ExplicitConstructorCall explicitConstructor,\r\n		BlockScope scope) {\r\n\r\n		if (explicitConstructor.isImplicitSuper()) {\r\n			return false;\r\n		}\r\n		final Expression qualification = explicitConstructor.qualification;\r\n		if (qualification != null) {\r\n			qualification.traverse(this, scope);\r\n		}\r\n\r\n		if (explicitConstructor.isSuperAccess()) {\r\n			this.scribe.printNextToken(ITerminalSymbols.TokenNamesuper);\r\n		} else {\r\n			this.scribe.printNextToken(ITerminalSymbols.TokenNamethis);\r\n		}\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameLPAREN, this.preferences.insert_space_before_message_send);\r\n		\r\n		final Expression[] arguments = explicitConstructor.arguments;\r\n		if (arguments != null) {\r\n			int argumentLength = arguments.length;\r\n			Alignment argumentsAlignment =this.scribe.createAlignment(\r\n					\"explicit_constructor_call\",//$NON-NLS-1$\r\n					this.preferences.explicit_constructor_arguments_alignment,\r\n					argumentLength,\r\n					this.scribe.scanner.currentPosition);\r\n			this.scribe.enterAlignment(argumentsAlignment);\r\n			boolean ok = false;\r\n			do {\r\n				try {\r\n					if (this.preferences.insert_space_within_message_send) {\r\n						this.scribe.space();\r\n					}\r\n					for (int i = 0; i < argumentLength; i++) {\r\n						if (i > 0) {\r\n							this.scribe.printNextToken(ITerminalSymbols.TokenNameCOMMA, this.preferences.insert_space_before_comma_in_explicitconstructorcall_arguments);\r\n						}\r\n						this.scribe.alignFragment(argumentsAlignment, i);\r\n						if (i > 0 && this.preferences.insert_space_after_comma_in_explicitconstructorcall_arguments) {\r\n							this.scribe.space();\r\n						}\r\n						arguments[i].traverse(this, scope);\r\n					}\r\n					ok = true;\r\n				} catch (AlignmentException e) {\r\n					this.scribe.redoAlignment(e);\r\n				}\r\n			} while (!ok);\r\n			this.scribe.exitAlignment(argumentsAlignment, true);\r\n			this.scribe.printNextToken(ITerminalSymbols.TokenNameRPAREN, this.preferences.insert_space_within_message_send); \r\n		} else {\r\n			this.scribe.printNextToken(ITerminalSymbols.TokenNameRPAREN, this.preferences.insert_space_between_empty_arguments); \r\n		}\r\n		return false;\r\n	}\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.FalseLiteral, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(FalseLiteral falseLiteral, BlockScope scope) {\r\n\r\n		final int numberOfParens = (falseLiteral.bits & AstNode.ParenthesizedMASK) >> AstNode.ParenthesizedSHIFT;\r\n		if (numberOfParens > 0) {\r\n			manageOpeningParenthesizedExpression(falseLiteral, numberOfParens);\r\n		}\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNamefalse);\r\n\r\n		if (numberOfParens > 0) {\r\n			manageClosingParenthesizedExpression(falseLiteral, numberOfParens);\r\n		}\r\n		return false;\r\n	}\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.FieldReference, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(FieldReference fieldReference, BlockScope scope) {\r\n\r\n		final int numberOfParens = (fieldReference.bits & AstNode.ParenthesizedMASK) >> AstNode.ParenthesizedSHIFT;\r\n		if (numberOfParens > 0) {\r\n			manageOpeningParenthesizedExpression(fieldReference, numberOfParens);\r\n		}\r\n		fieldReference.receiver.traverse(this, scope);\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameDOT);\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameIdentifier);\r\n		\r\n		if (numberOfParens > 0) {\r\n			manageClosingParenthesizedExpression(fieldReference, numberOfParens);\r\n		}\r\n		return false;\r\n	}\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.FloatLiteral, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(FloatLiteral floatLiteral, BlockScope scope) {\r\n\r\n		final int numberOfParens = (floatLiteral.bits & AstNode.ParenthesizedMASK) >> AstNode.ParenthesizedSHIFT;\r\n		if (numberOfParens > 0) {\r\n			manageOpeningParenthesizedExpression(floatLiteral, numberOfParens);\r\n		}\r\n		Constant constant = floatLiteral.constant;\r\n		if (constant != null && floatLiteral.constant.floatValue() < 0) {\r\n			this.scribe.printNextToken(ITerminalSymbols.TokenNameMINUS);			\r\n		}\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameFloatingPointLiteral);\r\n\r\n		if (numberOfParens > 0) {\r\n			manageClosingParenthesizedExpression(floatLiteral, numberOfParens);\r\n		}\r\n		return false;\r\n	}\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.ForStatement, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(ForStatement forStatement, BlockScope scope) {\r\n	\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNamefor);\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameLPAREN, this.preferences.insert_space_before_for_paren);\r\n		\r\n		if (this.preferences.insert_space_in_for_parens) {\r\n			this.scribe.space();\r\n		}\r\n		final Statement[] initializations = forStatement.initializations;\r\n		if (initializations != null) {\r\n			int length = initializations.length;\r\n			for (int i = 0; i < length; i++) {\r\n				initializations[i].traverse(this, scope);\r\n				if (i >= 0 && (i < length - 1) && !(initializations[i] instanceof LocalDeclaration)) {\r\n					this.scribe.printNextToken(ITerminalSymbols.TokenNameCOMMA, this.preferences.insert_space_before_comma_in_for_inits);\r\n					if (this.preferences.insert_space_after_comma_in_for_inits) {\r\n						this.scribe.space();\r\n					}\r\n				}				\r\n			}\r\n		}\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameSEMICOLON, this.preferences.insert_space_before_semicolon);\r\n		if (this.preferences.insert_space_after_semicolon_in_for) {\r\n			this.scribe.space();\r\n		}\r\n		final Expression condition = forStatement.condition;\r\n		if (condition != null) {\r\n			condition.traverse(this, scope);\r\n		}\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameSEMICOLON, this.preferences.insert_space_before_semicolon);\r\n		if (this.preferences.insert_space_after_semicolon_in_for) {\r\n			this.scribe.space();\r\n		}\r\n		final Statement[] increments = forStatement.increments;\r\n		if (increments != null) {\r\n			for (int i = 0, length = increments.length; i < length; i++) {\r\n				increments[i].traverse(this, scope);\r\n				if (i != length - 1) {\r\n					this.scribe.printNextToken(ITerminalSymbols.TokenNameCOMMA, this.preferences.insert_space_before_comma_in_for_increments);\r\n					if (this.preferences.insert_space_after_comma_in_for_increments) {\r\n						this.scribe.space();\r\n					}\r\n				}\r\n			}\r\n		}\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameRPAREN, this.preferences.insert_space_in_for_parens);\r\n		\r\n		final Statement action = forStatement.action;\r\n		if (action != null) {\r\n			if (action instanceof Block) {\r\n				action.traverse(this, scope);\r\n			} else {\r\n				this.scribe.indent();\r\n				this.scribe.printNewLine();\r\n				action.traverse(this, scope);\r\n				this.scribe.unIndent();\r\n			}\r\n			if (action instanceof Expression) {\r\n				this.scribe.printNextToken(ITerminalSymbols.TokenNameSEMICOLON, this.preferences.insert_space_before_semicolon);\r\n				this.scribe.printTrailingComment();\r\n				this.scribe.printNewLine();\r\n			} else if (action instanceof Block && this.preferences.insert_new_line_in_control_statements) {\r\n				this.scribe.printTrailingComment();\r\n				this.scribe.printNewLine();\r\n			}\r\n		} else {\r\n			this.scribe.indent();\r\n			/*\r\n			 * This is an empty statement\r\n			 */\r\n			formatEmptyStatement(); \r\n			this.scribe.unIndent();\r\n		}\r\n		return false;\r\n	}\r\n\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.IfStatement, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(IfStatement ifStatement, BlockScope scope) {\r\n\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameif);\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameLPAREN, this.preferences.insert_space_before_if_condition);\r\n		if (this.preferences.insert_space_in_if_condition) {\r\n			this.scribe.space();\r\n		}\r\n		ifStatement.condition.traverse(this, scope);\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameRPAREN, this.preferences.insert_space_in_if_condition);\r\n\r\n		final Statement thenStatement = ifStatement.thenStatement;\r\n		final Statement elseStatement = ifStatement.elseStatement;\r\n\r\n		if (thenStatement != null) {\r\n			if (thenStatement instanceof Block) {\r\n				if (isGuardClause((Block)thenStatement) && elseStatement == null && this.preferences.format_guardian_clause_on_one_line) {\r\n					/* \r\n					 * Need a specific formatting for guard clauses\r\n					 * guard clauses are block with a single return or throw\r\n					 * statement\r\n					 */\r\n					 formatGuardClauseBlock((Block) thenStatement, scope);\r\n				} else {\r\n					if (thenStatement instanceof Block) {\r\n						thenStatement.traverse(this, scope);\r\n					} else {\r\n						this.scribe.printNewLine();\r\n						this.scribe.indent();\r\n						thenStatement.traverse(this, scope);\r\n						this.scribe.unIndent();\r\n					}\r\n					if (elseStatement == null || this.preferences.insert_new_line_in_control_statements) {\r\n						this.scribe.printTrailingComment();\r\n					}\r\n				}\r\n			} else if (elseStatement == null && this.preferences.keep_simple_if_on_one_line) {\r\n				Alignment compactIfAlignment = this.scribe.createAlignment(\r\n					\"compactIf\", //$NON-NLS-1$\r\n					this.preferences.compact_if_alignment,\r\n					Alignment.R_OUTERMOST,\r\n					1, \r\n					this.scribe.scanner.currentPosition);\r\n				this.scribe.enterAlignment(compactIfAlignment);\r\n				boolean ok = false;\r\n				do {\r\n					try {\r\n						this.scribe.alignFragment(compactIfAlignment, 0);\r\n						this.scribe.space();\r\n						thenStatement.traverse(this, scope);\r\n						if (thenStatement instanceof Expression) {\r\n							this.scribe.printNextToken(ITerminalSymbols.TokenNameSEMICOLON, this.preferences.insert_space_before_semicolon);\r\n						}\r\n						ok = true;\r\n					} catch (AlignmentException e) {\r\n						this.scribe.redoAlignment(e);\r\n					}\r\n				} while (!ok);\r\n				this.scribe.exitAlignment(compactIfAlignment, true);				\r\n			} else if (this.preferences.keep_then_statement_on_same_line) {\r\n				this.scribe.space();\r\n				thenStatement.traverse(this, scope);\r\n				if (thenStatement instanceof Expression) {\r\n					this.scribe.printNextToken(ITerminalSymbols.TokenNameSEMICOLON, this.preferences.insert_space_before_semicolon);\r\n				}\r\n				this.scribe.printTrailingComment();\r\n				this.scribe.printNewLine();\r\n			} else {\r\n				this.scribe.printTrailingComment();\r\n				this.scribe.printNewLine();\r\n				this.scribe.indent();\r\n				thenStatement.traverse(this, scope);\r\n				if (thenStatement instanceof Expression) {\r\n					this.scribe.printNextToken(ITerminalSymbols.TokenNameSEMICOLON, this.preferences.insert_space_before_semicolon);\r\n				}\r\n				this.scribe.printTrailingComment();\r\n				this.scribe.printNewLine();\r\n				this.scribe.unIndent();\r\n			}\r\n		}\r\n		\r\n		if (elseStatement != null) {\r\n			this.scribe.printNextToken(ITerminalSymbols.TokenNameelse, true);\r\n			if (elseStatement instanceof Block) {\r\n				elseStatement.traverse(this, scope);\r\n			} else if (elseStatement instanceof IfStatement) {\r\n				if (!this.preferences.compact_else_if) {\r\n					this.scribe.printTrailingComment();\r\n					this.scribe.indent();\r\n				}\r\n				this.scribe.space();				\r\n				elseStatement.traverse(this, scope);\r\n				if (!this.preferences.compact_else_if) {\r\n					this.scribe.printTrailingComment();\r\n					this.scribe.unIndent();\r\n				}\r\n			} else if (this.preferences.keep_else_statement_on_same_line) {\r\n				this.scribe.space();\r\n				elseStatement.traverse(this, scope);\r\n				if (elseStatement instanceof Expression) {\r\n					this.scribe.printNextToken(ITerminalSymbols.TokenNameSEMICOLON, this.preferences.insert_space_before_semicolon);\r\n				}\r\n				this.scribe.printTrailingComment();\r\n				this.scribe.printNewLine();\r\n			} else {\r\n				this.scribe.printTrailingComment();\r\n				this.scribe.indent();\r\n				elseStatement.traverse(this, scope);\r\n				if (elseStatement instanceof Expression) {\r\n					this.scribe.printNextToken(ITerminalSymbols.TokenNameSEMICOLON, this.preferences.insert_space_before_semicolon);\r\n				}\r\n				this.scribe.printTrailingComment();\r\n				this.scribe.printNewLine();\r\n				this.scribe.unIndent();\r\n			}\r\n		}\r\n		return false;\r\n	}\r\n	\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.ImportReference, org.eclipse.jdt.internal.compiler.lookup.CompilationUnitScope)\r\n	 */\r\n	public boolean visit(\r\n		ImportReference importRef,\r\n		CompilationUnitScope scope) {\r\n		\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameimport);\r\n		this.scribe.space();\r\n		if (importRef.onDemand) {\r\n			this.scribe.printQualifiedReference(importRef.sourceEnd);\r\n			this.scribe.printNextToken(ITerminalSymbols.TokenNameDOT);\r\n			this.scribe.printNextToken(ITerminalSymbols.TokenNameMULTIPLY);			\r\n			this.scribe.printNextToken(ITerminalSymbols.TokenNameSEMICOLON, this.preferences.insert_space_before_semicolon);\r\n		} else {\r\n			this.scribe.printQualifiedReference(importRef.sourceEnd);\r\n			this.scribe.printNextToken(ITerminalSymbols.TokenNameSEMICOLON, this.preferences.insert_space_before_semicolon);\r\n		}\r\n		this.scribe.printTrailingComment();\r\n		this.scribe.printNewLine();\r\n		return false;\r\n	}\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.Initializer, org.eclipse.jdt.internal.compiler.lookup.MethodScope)\r\n	 */\r\n	public boolean visit(Initializer initializer, MethodScope scope) {\r\n\r\n		if (initializer.isStatic()) {\r\n			this.scribe.printNextToken(ITerminalSymbols.TokenNamestatic);\r\n		}\r\n		initializer.block.traverse(this, scope);\r\n		return false;\r\n	}\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.InstanceOfExpression, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(\r\n		InstanceOfExpression instanceOfExpression,\r\n		BlockScope scope) {\r\n\r\n		final int numberOfParens = (instanceOfExpression.bits & AstNode.ParenthesizedMASK) >> AstNode.ParenthesizedSHIFT;\r\n		if (numberOfParens > 0) {\r\n			manageOpeningParenthesizedExpression(instanceOfExpression, numberOfParens);\r\n		}\r\n		instanceOfExpression.expression.traverse(this, scope);\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameinstanceof, true);\r\n		this.scribe.space();\r\n		instanceOfExpression.type.traverse(this, scope);\r\n		\r\n		if (numberOfParens > 0) {\r\n			manageClosingParenthesizedExpression(instanceOfExpression, numberOfParens);\r\n		}\r\n		return false;\r\n	}\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.AbstractSyntaxTreeVisitorAdapter#visit(org.eclipse.jdt.internal.compiler.ast.IntLiteral, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(IntLiteral intLiteral, BlockScope scope) {\r\n\r\n		final int numberOfParens = (intLiteral.bits & AstNode.ParenthesizedMASK) >> AstNode.ParenthesizedSHIFT;\r\n		if (numberOfParens > 0) {\r\n			manageOpeningParenthesizedExpression(intLiteral, numberOfParens);\r\n		}\r\n		Constant constant = intLiteral.constant;\r\n		if (constant != null && constant.intValue() < 0) {\r\n			this.scribe.printNextToken(ITerminalSymbols.TokenNameMINUS);			\r\n		}\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameIntegerLiteral);\r\n\r\n		if (numberOfParens > 0) {\r\n			manageClosingParenthesizedExpression(intLiteral, numberOfParens);\r\n		}\r\n		return false;\r\n	}\r\n\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.LabeledStatement, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(LabeledStatement labeledStatement, BlockScope scope) {\r\n\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameIdentifier);\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameCOLON, this.preferences.insert_space_before_colon_in_labeled_statement);\r\n		if (this.preferences.insert_space_after_colon_in_labeled_statement) {\r\n			this.scribe.space();\r\n		}\r\n		labeledStatement.statement.traverse(this, scope);\r\n		return false;\r\n	}\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.LocalDeclaration, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(LocalDeclaration localDeclaration, BlockScope scope) {\r\n\r\n		if (!isMultipleLocalDeclaration(localDeclaration)) {\r\n			if (localDeclaration.modifiers != NO_MODIFIERS) {\r\n				this.scribe.printModifiers();\r\n				this.scribe.space();\r\n			}\r\n	\r\n			/*\r\n			 * Argument type \r\n			 */		\r\n			if (localDeclaration.type != null) {\r\n				localDeclaration.type.traverse(this, scope);\r\n			}\r\n		}\r\n		/*\r\n		 * Print the argument name\r\n		 */	\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameIdentifier, true); \r\n		/*\r\n		 * Check for extra dimensions\r\n		 */\r\n		int extraDimensions = getExtraDimension();\r\n		if (extraDimensions != 0) {\r\n			 for (int index = 0; index < extraDimensions; index++) {\r\n			 	this.scribe.printNextToken(ITerminalSymbols.TokenNameLBRACKET);\r\n			 	this.scribe.printNextToken(ITerminalSymbols.TokenNameRBRACKET);\r\n			 }\r\n		}\r\n	\r\n		if (localDeclaration.initialization != null) {\r\n			/*\r\n			 * Print the method name\r\n			 */	\r\n			this.scribe.printNextToken(ITerminalSymbols.TokenNameEQUAL, this.preferences.insert_space_before_assignment_operators);\r\n			if (this.preferences.insert_space_after_assignment_operators) {\r\n				this.scribe.space();\r\n			}			 \r\n			localDeclaration.initialization.traverse(this, scope);\r\n		}\r\n\r\n		if (isPartOfMultipleLocalDeclaration()) {\r\n			this.scribe.printNextToken(ITerminalSymbols.TokenNameCOMMA, this.preferences.insert_space_before_comma_in_multiple_local_declarations); \r\n			if (this.preferences.insert_space_after_comma_in_multiple_local_declarations) {\r\n				this.scribe.space();\r\n			}\r\n		}\r\n		return false;\r\n	}\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.LocalTypeDeclaration, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(\r\n		LocalTypeDeclaration localTypeDeclaration,\r\n		BlockScope scope) {\r\n\r\n			format(localTypeDeclaration);\r\n			return false;\r\n	}\r\n	\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.LongLiteral, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(LongLiteral longLiteral, BlockScope scope) {\r\n\r\n		final int numberOfParens = (longLiteral.bits & AstNode.ParenthesizedMASK) >> AstNode.ParenthesizedSHIFT;\r\n		if (numberOfParens > 0) {\r\n			manageOpeningParenthesizedExpression(longLiteral, numberOfParens);\r\n		}\r\n		Constant constant = longLiteral.constant;\r\n		if (constant != null && constant.longValue() < 0) {\r\n			this.scribe.printNextToken(ITerminalSymbols.TokenNameMINUS);			\r\n		}\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameLongLiteral);\r\n\r\n		if (numberOfParens > 0) {\r\n			manageClosingParenthesizedExpression(longLiteral, numberOfParens);\r\n		}\r\n		return false;\r\n	}\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.AbstractSyntaxTreeVisitorAdapter#visit(org.eclipse.jdt.internal.compiler.ast.MemberTypeDeclaration, org.eclipse.jdt.internal.compiler.lookup.ClassScope)\r\n	 */\r\n	public boolean visit(MemberTypeDeclaration memberTypeDeclaration, ClassScope scope) {\r\n		Alignment memberTypeAlignment = this.scribe.getAlignment(\"typeMembers\");		//$NON-NLS-1$\r\n		format(memberTypeDeclaration);\r\n		this.scribe.exitAlignment(memberTypeAlignment, false);		\r\n		return false;\r\n	}\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.MessageSend, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(MessageSend messageSend, BlockScope scope) {\r\n\r\n		final int numberOfParens = (messageSend.bits & AstNode.ParenthesizedMASK) >> AstNode.ParenthesizedSHIFT;\r\n		if (numberOfParens > 0) {\r\n			manageOpeningParenthesizedExpression(messageSend, numberOfParens);\r\n		}\r\n		Alignment messageAlignment = null;\r\n		if (!messageSend.receiver.isImplicitThis()) {\r\n			messageSend.receiver.traverse(this, scope);\r\n			messageAlignment = this.scribe.createAlignment(\r\n					\"messageAlignment\", //$NON-NLS-1$\r\n					this.preferences.message_send_selector_alignment,\r\n					1,\r\n					this.scribe.scanner.currentPosition);\r\n			this.scribe.enterAlignment(messageAlignment);\r\n			boolean ok = false;\r\n			do {\r\n				try {\r\n					formatMessageSend(messageSend, scope, messageAlignment);\r\n					ok = true;\r\n				} catch (AlignmentException e) {\r\n					this.scribe.redoAlignment(e);\r\n				}\r\n			} while (!ok);\r\n			this.scribe.exitAlignment(messageAlignment, true);\r\n		} else {\r\n			formatMessageSend(messageSend, scope, null);			\r\n		}\r\n		if (numberOfParens > 0) {\r\n			manageClosingParenthesizedExpression(messageSend, numberOfParens);\r\n		}\r\n		return false;\r\n	}\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.MethodDeclaration, org.eclipse.jdt.internal.compiler.lookup.ClassScope)\r\n	 */\r\n	public boolean visit(\r\n		MethodDeclaration methodDeclaration,\r\n		ClassScope scope) {\r\n\r\n		if (methodDeclaration.modifiers != NO_MODIFIERS) {\r\n			this.scribe.printModifiers();\r\n			this.scribe.space();\r\n		}\r\n		\r\n		/*\r\n		 * Print the method return type\r\n		 */	\r\n		final TypeReference returnType = methodDeclaration.returnType;\r\n		final MethodScope methodDeclarationScope = methodDeclaration.scope;\r\n		\r\n		if (returnType != null) {\r\n			returnType.traverse(this, methodDeclarationScope);\r\n		}\r\n		/*\r\n		 * Print the method name\r\n		 */\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameIdentifier, true); \r\n\r\n		/*\r\n		 * Check for extra dimensions\r\n		 */\r\n		int extraDimensions = getExtraDimension();\r\n		if (extraDimensions != 0) {\r\n			 for (int i = 0; i < extraDimensions; i++) {\r\n			 	this.scribe.printNextToken(ITerminalSymbols.TokenNameLBRACKET);\r\n			 	this.scribe.printNextToken(ITerminalSymbols.TokenNameRBRACKET);\r\n			 }\r\n		}\r\n\r\n		formatMethodArguments(\r\n			methodDeclaration, \r\n			this.preferences.insert_space_before_method_declaration_open_paren,\r\n			this.preferences.insert_space_between_empty_arguments,\r\n			this.preferences.insert_space_before_closing_paren,\r\n			this.preferences.insert_space_before_first_argument,\r\n			this.preferences.insert_space_before_comma_in_method_arguments,\r\n			this.preferences.insert_space_after_comma_in_method_arguments);\r\n\r\n		formatThrowsClause(\r\n			methodDeclaration,\r\n			this.preferences.insert_space_before_comma_in_method_throws,\r\n			this.preferences.insert_space_after_comma_in_method_throws);\r\n\r\n		if (!methodDeclaration.isNative() && !methodDeclaration.isAbstract() && ((methodDeclaration.modifiers & CompilerModifiers.AccSemicolonBody) == 0)) {\r\n			/*\r\n			 * Method body\r\n			 */\r\n			String method_declaration_brace = this.preferences.method_declaration_brace_position;\r\n			formatOpeningBrace(method_declaration_brace, this.preferences.insert_space_before_method_open_brace);\r\n			this.scribe.indent();			\r\n			final int numberOfBlankLinesAtBeginningOfMethodBody = this.preferences.number_of_blank_lines_to_insert_at_beginning_of_method_body;\r\n			if (numberOfBlankLinesAtBeginningOfMethodBody > 0) {\r\n				this.scribe.printNewLines(numberOfBlankLinesAtBeginningOfMethodBody);\r\n			}\r\n			final Statement[] statements = methodDeclaration.statements;\r\n			if (statements != null) {\r\n				this.scribe.printNewLine();\r\n				formatStatements(methodDeclarationScope, statements);\r\n			} else if (this.preferences.insert_new_line_in_empty_method_body) {\r\n				this.scribe.printNewLine();\r\n			}\r\n			this.scribe.printComment();\r\n			this.scribe.unIndent();\r\n			this.scribe.printNextToken(ITerminalSymbols.TokenNameRBRACE);\r\n			this.scribe.printTrailingComment();\r\n			this.scribe.printNewLine();\r\n			if (method_declaration_brace.equals(FormattingPreferences.NEXT_LINE_SHIFTED)) {\r\n				this.scribe.unIndent();\r\n			}\r\n		} else {\r\n			// no method body\r\n			this.scribe.printNextToken(ITerminalSymbols.TokenNameSEMICOLON, this.preferences.insert_space_before_semicolon);\r\n			this.scribe.printTrailingComment();\r\n			this.scribe.printNewLine();\r\n		}\r\n		return false;\r\n	}\r\n	\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.NullLiteral, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(NullLiteral nullLiteral, BlockScope scope) {\r\n\r\n		final int numberOfParens = (nullLiteral.bits & AstNode.ParenthesizedMASK) >> AstNode.ParenthesizedSHIFT;\r\n		if (numberOfParens > 0) {\r\n			manageOpeningParenthesizedExpression(nullLiteral, numberOfParens);\r\n		}\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNamenull);\r\n\r\n		if (numberOfParens > 0) {\r\n			manageClosingParenthesizedExpression(nullLiteral, numberOfParens);\r\n		}\r\n		return false;\r\n	}\r\n\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.OR_OR_Expression, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(OR_OR_Expression or_or_Expression, BlockScope scope) {\r\n\r\n		return dumpBinaryExpression(or_or_Expression, ITerminalSymbols.TokenNameOR_OR, scope);\r\n	}\r\n	\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.PostfixExpression, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(\r\n		PostfixExpression postfixExpression,\r\n		BlockScope scope) {\r\n\r\n		final int numberOfParens = (postfixExpression.bits & AstNode.ParenthesizedMASK) >> AstNode.ParenthesizedSHIFT;\r\n		if (numberOfParens > 0) {\r\n			manageOpeningParenthesizedExpression(postfixExpression, numberOfParens);\r\n		}\r\n		postfixExpression.lhs.traverse(this, scope);\r\n		int operator = postfixExpression.operator == OperatorIds.PLUS \r\n			? ITerminalSymbols.TokenNamePLUS_PLUS : ITerminalSymbols.TokenNameMINUS_MINUS;\r\n		this.scribe.printNextToken(operator, this.preferences.insert_space_before_postfix_operator);\r\n		if (this.preferences.insert_space_after_postfix_operator) {\r\n			this.scribe.space();\r\n		}\r\n		if (numberOfParens > 0) {\r\n			manageClosingParenthesizedExpression(postfixExpression, numberOfParens);\r\n		}\r\n		return false;\r\n	}\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.PrefixExpression, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(PrefixExpression prefixExpression, BlockScope scope) {\r\n\r\n		final int numberOfParens = (prefixExpression.bits & AstNode.ParenthesizedMASK) >> AstNode.ParenthesizedSHIFT;\r\n		if (numberOfParens > 0) {\r\n			manageOpeningParenthesizedExpression(prefixExpression, numberOfParens);\r\n		}\r\n		int operator = prefixExpression.operator == OperatorIds.PLUS \r\n			? ITerminalSymbols.TokenNamePLUS_PLUS : ITerminalSymbols.TokenNameMINUS_MINUS;\r\n		this.scribe.printNextToken(operator, this.preferences.insert_space_before_prefix_operator);\r\n		prefixExpression.lhs.traverse(this, scope);\r\n		if (this.preferences.insert_space_after_prefix_operator) {\r\n			this.scribe.space();\r\n		}\r\n		if (numberOfParens > 0) {\r\n			manageClosingParenthesizedExpression(prefixExpression, numberOfParens);\r\n		}\r\n		return false;\r\n	}\r\n	\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.QualifiedAllocationExpression, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(\r\n		QualifiedAllocationExpression qualifiedAllocationExpression,\r\n		BlockScope scope) {\r\n			\r\n		final int numberOfParens = (qualifiedAllocationExpression.bits & AstNode.ParenthesizedMASK) >> AstNode.ParenthesizedSHIFT;\r\n		if (numberOfParens > 0) {\r\n			manageOpeningParenthesizedExpression(qualifiedAllocationExpression, numberOfParens);\r\n		}\r\n		final Expression enclosingInstance = qualifiedAllocationExpression.enclosingInstance;\r\n		if (enclosingInstance != null) {\r\n			enclosingInstance.traverse(this, scope);\r\n			this.scribe.printNextToken(ITerminalSymbols.TokenNameDOT);\r\n		}\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNamenew);\r\n		this.scribe.space();\r\n		qualifiedAllocationExpression.type.traverse(this, scope);\r\n		\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameLPAREN, this.preferences.insert_space_before_message_send);\r\n\r\n		final Expression[] arguments = qualifiedAllocationExpression.arguments;\r\n		if (arguments != null) {\r\n			int argumentLength = arguments.length;\r\n			Alignment argumentsAlignment =this.scribe.createAlignment(\r\n					\"allocation\",//$NON-NLS-1$\r\n					this.preferences.qualified_allocation_expression_arguments_alignment,\r\n					argumentLength,\r\n					this.scribe.scanner.currentPosition);\r\n			this.scribe.enterAlignment(argumentsAlignment);\r\n			boolean ok = false;\r\n			do {\r\n				try {\r\n					if (this.preferences.insert_space_within_message_send) {\r\n						this.scribe.space();\r\n					}\r\n					for (int i = 0; i < argumentLength; i++) {\r\n						if (i > 0) {\r\n							this.scribe.printNextToken(ITerminalSymbols.TokenNameCOMMA, this.preferences.insert_space_before_comma_in_allocation_expression);\r\n						}\r\n						this.scribe.alignFragment(argumentsAlignment, i);\r\n						if (i > 0 && this.preferences.insert_space_after_comma_in_allocation_expression) {\r\n							this.scribe.space();\r\n						}\r\n						arguments[i].traverse(this, scope);\r\n					}\r\n					ok = true;\r\n				} catch (AlignmentException e) {\r\n					this.scribe.redoAlignment(e);\r\n				}\r\n			} while (!ok);\r\n			this.scribe.exitAlignment(argumentsAlignment, true);\r\n			this.scribe.printNextToken(ITerminalSymbols.TokenNameRPAREN, this.preferences.insert_space_within_message_send); \r\n		} else {\r\n			this.scribe.printNextToken(ITerminalSymbols.TokenNameRPAREN, this.preferences.insert_space_between_empty_arguments); \r\n		}\r\n		final AnonymousLocalTypeDeclaration anonymousType = qualifiedAllocationExpression.anonymousType;\r\n		if (anonymousType != null) {\r\n			anonymousType.traverse(this, scope);\r\n		}\r\n		if (numberOfParens > 0) {\r\n			manageClosingParenthesizedExpression(qualifiedAllocationExpression, numberOfParens);\r\n		}\r\n		return false;\r\n	}\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.QualifiedNameReference, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(\r\n		QualifiedNameReference qualifiedNameReference,\r\n		BlockScope scope) {\r\n\r\n		final int numberOfParens = (qualifiedNameReference.bits & AstNode.ParenthesizedMASK) >> AstNode.ParenthesizedSHIFT;\r\n		if (numberOfParens > 0) {\r\n			manageOpeningParenthesizedExpression(qualifiedNameReference, numberOfParens);\r\n		}\r\n		this.scribe.printQualifiedReference(qualifiedNameReference.sourceEnd);\r\n\r\n		if (numberOfParens > 0) {\r\n			manageClosingParenthesizedExpression(qualifiedNameReference, numberOfParens);\r\n		}\r\n		return false;\r\n	}\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.QualifiedSuperReference, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(\r\n		QualifiedSuperReference qualifiedSuperReference,\r\n		BlockScope scope) {\r\n\r\n		final int numberOfParens = (qualifiedSuperReference.bits & AstNode.ParenthesizedMASK) >> AstNode.ParenthesizedSHIFT;\r\n		if (numberOfParens > 0) {\r\n			manageOpeningParenthesizedExpression(qualifiedSuperReference, numberOfParens);\r\n		}\r\n		qualifiedSuperReference.qualification.traverse(this, scope);\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameDOT);\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNamesuper);\r\n		\r\n		if (numberOfParens > 0) {\r\n			manageClosingParenthesizedExpression(qualifiedSuperReference, numberOfParens);\r\n		}\r\n		return false;\r\n	}\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.QualifiedThisReference, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(\r\n		QualifiedThisReference qualifiedThisReference,\r\n		BlockScope scope) {\r\n\r\n		final int numberOfParens = (qualifiedThisReference.bits & AstNode.ParenthesizedMASK) >> AstNode.ParenthesizedSHIFT;\r\n		if (numberOfParens > 0) {\r\n			manageOpeningParenthesizedExpression(qualifiedThisReference, numberOfParens);\r\n		}\r\n		qualifiedThisReference.qualification.traverse(this, scope);\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameDOT);\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNamethis);\r\n		\r\n		if (numberOfParens > 0) {\r\n			manageClosingParenthesizedExpression(qualifiedThisReference, numberOfParens);\r\n		}\r\n		return false;\r\n	}\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.QualifiedTypeReference, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(\r\n		QualifiedTypeReference qualifiedTypeReference,\r\n		BlockScope scope) {\r\n\r\n		final int numberOfParens = (qualifiedTypeReference.bits & AstNode.ParenthesizedMASK) >> AstNode.ParenthesizedSHIFT;\r\n		if (numberOfParens > 0) {\r\n			manageOpeningParenthesizedExpression(qualifiedTypeReference, numberOfParens);\r\n		}\r\n		this.scribe.printQualifiedReference(qualifiedTypeReference.sourceEnd + 1);\r\n		\r\n		if (numberOfParens > 0) {\r\n			manageClosingParenthesizedExpression(qualifiedTypeReference, numberOfParens);\r\n		}\r\n		return false;\r\n	}\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.QualifiedTypeReference, org.eclipse.jdt.internal.compiler.lookup.ClassScope)\r\n	 */\r\n	public boolean visit(\r\n		QualifiedTypeReference qualifiedTypeReference,\r\n		ClassScope scope) {\r\n\r\n			final int numberOfParens = (qualifiedTypeReference.bits & AstNode.ParenthesizedMASK) >> AstNode.ParenthesizedSHIFT;\r\n			if (numberOfParens > 0) {\r\n				manageOpeningParenthesizedExpression(qualifiedTypeReference, numberOfParens);\r\n			}\r\n			this.scribe.printQualifiedReference(qualifiedTypeReference.sourceEnd + 1);\r\n			\r\n			if (numberOfParens > 0) {\r\n				manageClosingParenthesizedExpression(qualifiedTypeReference, numberOfParens);\r\n			}\r\n			return false;\r\n	}\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.ReturnStatement, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(ReturnStatement returnStatement, BlockScope scope) {\r\n		\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNamereturn);\r\n		final Expression expression = returnStatement.expression;\r\n		if (expression != null) {\r\n			this.scribe.space();\r\n			expression.traverse(this, scope);\r\n		}\r\n		/*\r\n		 * Print the semi-colon\r\n		 */	\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameSEMICOLON, this.preferences.insert_space_before_semicolon);\r\n		return false;\r\n	}\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.AbstractSyntaxTreeVisitorAdapter#visit(org.eclipse.jdt.internal.compiler.ast.SingleNameReference, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(SingleNameReference singleNameReference, BlockScope scope) {\r\n\r\n		final int numberOfParens = (singleNameReference.bits & AstNode.ParenthesizedMASK) >> AstNode.ParenthesizedSHIFT;\r\n		if (numberOfParens > 0) {\r\n			manageOpeningParenthesizedExpression(singleNameReference, numberOfParens);\r\n		}\r\n		this.scribe.printNextToken(SINGLETYPEREFERENCE_EXPECTEDTOKENS, false, true);\r\n		\r\n		if (numberOfParens > 0) {\r\n			manageClosingParenthesizedExpression(singleNameReference, numberOfParens);\r\n		}\r\n		return false;\r\n	}\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.SingleTypeReference, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(\r\n		SingleTypeReference singleTypeReference,\r\n		BlockScope scope) {\r\n\r\n		final int numberOfParens = (singleTypeReference.bits & AstNode.ParenthesizedMASK) >> AstNode.ParenthesizedSHIFT;\r\n		if (numberOfParens > 0) {\r\n			manageOpeningParenthesizedExpression(singleTypeReference, numberOfParens);\r\n		}\r\n		this.scribe.printNextToken(SINGLETYPEREFERENCE_EXPECTEDTOKENS, false, true);\r\n\r\n		if (numberOfParens > 0) {\r\n			manageClosingParenthesizedExpression(singleTypeReference, numberOfParens);\r\n		}\r\n		return false;\r\n	}\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.SingleTypeReference, org.eclipse.jdt.internal.compiler.lookup.ClassScope)\r\n	 */\r\n	public boolean visit(\r\n		SingleTypeReference singleTypeReference,\r\n		ClassScope scope) {\r\n\r\n		final int numberOfParens = (singleTypeReference.bits & AstNode.ParenthesizedMASK) >> AstNode.ParenthesizedSHIFT;\r\n		if (numberOfParens > 0) {\r\n			manageOpeningParenthesizedExpression(singleTypeReference, numberOfParens);\r\n		}\r\n		this.scribe.printNextToken(SINGLETYPEREFERENCE_EXPECTEDTOKENS, false, true);\r\n\r\n		if (numberOfParens > 0) {\r\n			manageClosingParenthesizedExpression(singleTypeReference, numberOfParens);\r\n		}\r\n		return false;\r\n	}\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.StringLiteral, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(StringLiteral stringLiteral, BlockScope scope) {\r\n\r\n		final int numberOfParens = (stringLiteral.bits & AstNode.ParenthesizedMASK) >> AstNode.ParenthesizedSHIFT;\r\n		if (numberOfParens > 0) {\r\n			manageOpeningParenthesizedExpression(stringLiteral, numberOfParens);\r\n		}\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameStringLiteral);\r\n		\r\n		if (numberOfParens > 0) {\r\n			manageClosingParenthesizedExpression(stringLiteral, numberOfParens);\r\n		}\r\n		return false;\r\n	}\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.SuperReference, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(SuperReference superReference, BlockScope scope) {\r\n\r\n		final int numberOfParens = (superReference.bits & AstNode.ParenthesizedMASK) >> AstNode.ParenthesizedSHIFT;\r\n		if (numberOfParens > 0) {\r\n			manageOpeningParenthesizedExpression(superReference, numberOfParens);\r\n		}\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNamesuper);\r\n\r\n		if (numberOfParens > 0) {\r\n			manageClosingParenthesizedExpression(superReference, numberOfParens);\r\n		}\r\n		return false;\r\n	}\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.SwitchStatement, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(SwitchStatement switchStatement, BlockScope scope) {\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameswitch);\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameLPAREN, this.preferences.insert_space_before_switch_condition);\r\n		\r\n		if (this.preferences.insert_space_in_switch_condition) {\r\n			this.scribe.space();\r\n		}\r\n		\r\n		switchStatement.testExpression.traverse(this, scope);\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameRPAREN, this.preferences.insert_space_in_switch_condition);\r\n		/*\r\n		 * Type body\r\n		 */\r\n		String switch_brace = this.preferences.switch_brace_position;\r\n		formatOpeningBrace(switch_brace, this.preferences.insert_space_before_switch_open_brace);\r\n		this.scribe.printNewLine();\r\n\r\n		if (preferences.indent_switchstatements_compare_to_switch) {\r\n			this.scribe.indent();\r\n		}\r\n		final Statement[] statements = switchStatement.statements;\r\n		if (statements != null) {\r\n			int statementsLength = statements.length;\r\n			boolean wasABreak = false;\r\n			for (int i = 0; i < statementsLength; i++) {\r\n				final Statement statement = statements[i];\r\n				if (i == 0) {\r\n					// this is a case or a default statement\r\n					statement.traverse(this, scope);\r\n					if (this.preferences.indent_switchstatements_compare_to_cases) {\r\n						this.scribe.indent();\r\n					}\r\n				} else if (statement instanceof CaseStatement) {\r\n					if (wasABreak) {\r\n						if (this.preferences.indent_breaks_compare_to_cases) {\r\n							this.scribe.unIndent();\r\n						}\r\n					} else if (this.preferences.indent_switchstatements_compare_to_cases) {\r\n						this.scribe.unIndent();\r\n					}\r\n					statement.traverse(this, scope);\r\n					wasABreak = false;\r\n					if (this.preferences.indent_switchstatements_compare_to_cases) {\r\n						this.scribe.indent();\r\n					}\r\n				} else if (statement instanceof BreakStatement) {\r\n					wasABreak = true;\r\n					if (this.preferences.indent_switchstatements_compare_to_cases) {\r\n						if (!this.preferences.indent_breaks_compare_to_cases) {\r\n							this.scribe.unIndent();\r\n						}\r\n					} else if (this.preferences.indent_breaks_compare_to_cases) {\r\n						this.scribe.indent();\r\n					}\r\n					statement.traverse(this, scope);\r\n					if (i == statementsLength - 1 && this.preferences.indent_breaks_compare_to_cases) {\r\n						this.scribe.unIndent();\r\n					}\r\n				} else {\r\n					wasABreak = false;\r\n					statement.traverse(this, scope);\r\n					if (i == statementsLength - 1 && this.preferences.indent_switchstatements_compare_to_cases) {\r\n						this.scribe.unIndent();\r\n					}\r\n				}\r\n				if (statement instanceof Expression) {\r\n					/*\r\n					 * Print the semi-colon\r\n					 */	\r\n					this.scribe.printNextToken(ITerminalSymbols.TokenNameSEMICOLON, this.preferences.insert_space_before_semicolon);\r\n					this.scribe.printTrailingComment();\r\n				} else if (statement instanceof LocalDeclaration) {\r\n					LocalDeclaration currentLocal = (LocalDeclaration) statement;\r\n					if (i < (statementsLength - 1)) {\r\n						/* \r\n						 * We need to check that the next statement is a local declaration\r\n						 */\r\n						if (statements[i + 1] instanceof LocalDeclaration) {\r\n							LocalDeclaration nextLocal = (LocalDeclaration) statements[i + 1];\r\n							if (currentLocal.declarationSourceStart != nextLocal.declarationSourceStart) {\r\n								/*\r\n								 * Print the semi-colon\r\n								 */	\r\n								this.scribe.printNextToken(ITerminalSymbols.TokenNameSEMICOLON, this.preferences.insert_space_before_semicolon);\r\n								this.scribe.printTrailingComment();\r\n							}\r\n						} else {\r\n							/*\r\n							 * Print the semi-colon\r\n							 */	\r\n							this.scribe.printNextToken(ITerminalSymbols.TokenNameSEMICOLON, this.preferences.insert_space_before_semicolon);\r\n							this.scribe.printTrailingComment();\r\n						}\r\n					} else {\r\n						/*\r\n						 * Print the semi-colon\r\n						 */	\r\n						this.scribe.printNextToken(ITerminalSymbols.TokenNameSEMICOLON, this.preferences.insert_space_before_semicolon);\r\n						this.scribe.printTrailingComment();\r\n					}\r\n				} else {\r\n					this.scribe.printTrailingComment();\r\n				}\r\n				this.scribe.printNewLine();\r\n			}\r\n		}		\r\n		\r\n		if (preferences.indent_switchstatements_compare_to_switch) {\r\n			this.scribe.unIndent();\r\n		}\r\n		this.scribe.printNewLine();\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameRBRACE);\r\n		this.scribe.printTrailingComment();\r\n		if (switch_brace.equals(FormattingPreferences.NEXT_LINE_SHIFTED)) {\r\n			this.scribe.unIndent();\r\n		}		\r\n		return false;\r\n	}\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.SynchronizedStatement, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(\r\n		SynchronizedStatement synchronizedStatement,\r\n		BlockScope scope) {\r\n		\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNamesynchronized);\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameLPAREN, this.preferences.insert_space_before_synchronized_condition);\r\n		\r\n		if (this.preferences.insert_space_in_synchronized_condition) {\r\n			this.scribe.space();\r\n		}\r\n		synchronizedStatement.expression.traverse(this, scope);\r\n	\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameRPAREN, this.preferences.insert_space_in_synchronized_condition);\r\n		\r\n		synchronizedStatement.block.traverse(this, scope);\r\n		this.scribe.printTrailingComment();\r\n		return false;\r\n	}\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.ThisReference, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(ThisReference thisReference, BlockScope scope) {\r\n		\r\n		if (!thisReference.isImplicitThis()) {\r\n			final int numberOfParens = (thisReference.bits & AstNode.ParenthesizedMASK) >> AstNode.ParenthesizedSHIFT;\r\n			if (numberOfParens > 0) {\r\n				manageOpeningParenthesizedExpression(thisReference, numberOfParens);\r\n			}\r\n			this.scribe.printNextToken(ITerminalSymbols.TokenNamethis);\r\n			\r\n			if (numberOfParens > 0) {\r\n				manageClosingParenthesizedExpression(thisReference, numberOfParens);\r\n			}\r\n		}\r\n		return false;\r\n	}\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.ThrowStatement, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(ThrowStatement throwStatement, BlockScope scope) {\r\n\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNamethrow);\r\n		this.scribe.space();\r\n		throwStatement.exception.traverse(this, scope);\r\n		/*\r\n		 * Print the semi-colon\r\n		 */	\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameSEMICOLON, this.preferences.insert_space_before_semicolon);\r\n		return false;\r\n	}\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.TrueLiteral, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(TrueLiteral trueLiteral, BlockScope scope) {\r\n\r\n		final int numberOfParens = (trueLiteral.bits & AstNode.ParenthesizedMASK) >> AstNode.ParenthesizedSHIFT;\r\n		if (numberOfParens > 0) {\r\n			manageOpeningParenthesizedExpression(trueLiteral, numberOfParens);\r\n		}\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNametrue);\r\n\r\n		if (numberOfParens > 0) {\r\n			manageClosingParenthesizedExpression(trueLiteral, numberOfParens);\r\n		}\r\n		return false;\r\n	}\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.TryStatement, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(TryStatement tryStatement, BlockScope scope) {\r\n\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNametry);\r\n		tryStatement.tryBlock.traverse(this, scope);\r\n		if (this.preferences.insert_new_line_in_control_statements) {\r\n			this.scribe.printTrailingComment();\r\n		}	\r\n		if (tryStatement.catchArguments != null) {\r\n			for (int i = 0, max = tryStatement.catchBlocks.length; i < max; i++) {\r\n				this.scribe.printNextToken(ITerminalSymbols.TokenNamecatch, this.preferences.insert_space_after_block_close_brace);\r\n				this.scribe.printNextToken(ITerminalSymbols.TokenNameLPAREN, this.preferences.insert_space_before_catch_expression);\r\n				\r\n				if (this.preferences.insert_space_in_catch_expression) {\r\n					this.scribe.space();\r\n				}\r\n				\r\n				tryStatement.catchArguments[i].traverse(this, scope);\r\n			\r\n				this.scribe.printNextToken(ITerminalSymbols.TokenNameRPAREN, this.preferences.insert_space_in_catch_expression);\r\n				\r\n				tryStatement.catchBlocks[i].traverse(this, scope);\r\n				if (this.preferences.insert_new_line_in_control_statements) {\r\n					this.scribe.printTrailingComment();\r\n				}	\r\n			}\r\n		}\r\n		if (tryStatement.finallyBlock != null) {\r\n			this.scribe.printNextToken(ITerminalSymbols.TokenNamefinally, this.preferences.insert_space_after_block_close_brace);\r\n			tryStatement.finallyBlock.traverse(this, scope);\r\n			if (this.preferences.insert_new_line_in_control_statements) {\r\n				this.scribe.printTrailingComment();\r\n			}	\r\n		}\r\n		return false;\r\n	}\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.TypeDeclaration, org.eclipse.jdt.internal.compiler.lookup.CompilationUnitScope)\r\n	 */\r\n	public boolean visit(\r\n		TypeDeclaration typeDeclaration,\r\n		CompilationUnitScope scope) {\r\n\r\n		format(typeDeclaration);\r\n		return false;\r\n	}\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.UnaryExpression, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(UnaryExpression unaryExpression, BlockScope scope) {\r\n\r\n		final int numberOfParens = (unaryExpression.bits & AstNode.ParenthesizedMASK) >> AstNode.ParenthesizedSHIFT;\r\n		if (numberOfParens > 0) {\r\n			manageOpeningParenthesizedExpression(unaryExpression, numberOfParens);\r\n		}\r\n\r\n		/*\r\n		 * Print the operator\r\n		 */\r\n		int operator;\r\n		switch((unaryExpression.bits & AstNode.OperatorMASK) >> AstNode.OperatorSHIFT) {\r\n			case OperatorIds.PLUS:\r\n				operator = ITerminalSymbols.TokenNamePLUS;\r\n				break;\r\n			case OperatorIds.MINUS:\r\n				operator = ITerminalSymbols.TokenNameMINUS;\r\n				break;\r\n			case OperatorIds.TWIDDLE:\r\n				operator = ITerminalSymbols.TokenNameTWIDDLE;\r\n				break;\r\n			default:\r\n				operator = ITerminalSymbols.TokenNameNOT;\r\n		}\r\n\r\n		if (operator == ITerminalSymbols.TokenNameMINUS) {\r\n			this.scribe.printNextToken(operator, true);\r\n		} else {\r\n			this.scribe.printNextToken(operator, this.preferences.insert_space_before_unary_operator);\r\n		}\r\n		if (this.preferences.insert_space_after_unary_operator) {\r\n			this.scribe.space();\r\n		}\r\n		unaryExpression.expression.traverse(this, scope);\r\n\r\n		if (numberOfParens > 0) {\r\n			manageClosingParenthesizedExpression(unaryExpression, numberOfParens);\r\n		}\r\n		return false;\r\n	}\r\n\r\n	/**\r\n	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#visit(org.eclipse.jdt.internal.compiler.ast.WhileStatement, org.eclipse.jdt.internal.compiler.lookup.BlockScope)\r\n	 */\r\n	public boolean visit(WhileStatement whileStatement, BlockScope scope) {\r\n\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNamewhile);\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameLPAREN, this.preferences.insert_space_before_while_condition);\r\n		\r\n		if (this.preferences.insert_space_in_while_condition) {\r\n			this.scribe.space();\r\n		}\r\n		whileStatement.condition.traverse(this, scope);\r\n		\r\n		this.scribe.printNextToken(ITerminalSymbols.TokenNameRPAREN, this.preferences.insert_space_in_while_condition);\r\n		\r\n		final Statement action = whileStatement.action;\r\n		if (action != null) {\r\n			if (action instanceof Block) {\r\n				action.traverse(this, scope);\r\n			} else {\r\n				this.scribe.printNewLine();\r\n				this.scribe.indent();\r\n				action.traverse(this, scope);\r\n				this.scribe.unIndent();\r\n			}\r\n			if (action instanceof Expression) {\r\n				this.scribe.printNextToken(ITerminalSymbols.TokenNameSEMICOLON, this.preferences.insert_space_before_semicolon);\r\n				this.scribe.printTrailingComment();\r\n			} else if (action instanceof Block) {\r\n				this.scribe.printTrailingComment();\r\n			}		\r\n		} else {\r\n			this.scribe.indent();\r\n			/*\r\n			 * This is an empty statement\r\n			 */\r\n			formatEmptyStatement(); \r\n			this.scribe.unIndent();\r\n		}\r\n\r\n		return false;\r\n	}\r\n}',1),(5,'dtm3.png','sdfasdf','sdfasdf',2),(6,'dtm4.png','sdfds','asfdsd',3);
/*!40000 ALTER TABLE `ms_dtModel` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Dumping data for table `ms_dtModel_tasks`
--

LOCK TABLES `ms_dtModel_tasks` WRITE;
/*!40000 ALTER TABLE `ms_dtModel_tasks` DISABLE KEYS */;
INSERT INTO `ms_dtModel_tasks` VALUES (3,4,2),(4,5,2),(5,5,3),(6,6,2),(7,6,3);
/*!40000 ALTER TABLE `ms_dtModel_tasks` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Dumping data for table `ms_question`
--

LOCK TABLES `ms_question` WRITE;
/*!40000 ALTER TABLE `ms_question` DISABLE KEYS */;
INSERT INTO `ms_question` VALUES (5,'How does the model classify the folowing observation?',1),(6,'What code smell is decision tree model refering to?',2),(7,'How difficult was the task?',3),(8,'The above classification tree is:',1);
/*!40000 ALTER TABLE `ms_question` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Dumping data for table `ms_task`
--

LOCK TABLES `ms_task` WRITE;
/*!40000 ALTER TABLE `ms_task` DISABLE KEYS */;
INSERT INTO `ms_task` VALUES (2,'Code Correlation','CC',2),(3,'Identify','ID',1);
/*!40000 ALTER TABLE `ms_task` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Dumping data for table `ms_task_questions`
--

LOCK TABLES `ms_task_questions` WRITE;
/*!40000 ALTER TABLE `ms_task_questions` DISABLE KEYS */;
INSERT INTO `ms_task_questions` VALUES (6,2,8),(7,3,6);
/*!40000 ALTER TABLE `ms_task_questions` ENABLE KEYS */;
UNLOCK TABLES;
/*!40103 SET TIME_ZONE=@OLD_TIME_ZONE */;

/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;

-- Dump completed on 2019-11-20 13:14:39
