-- MySQL dump 10.13  Distrib 5.7.23, for Linux (x86_64)
--
-- Host: christianorossini.mysql.pythonanywhere-services.com    Database: christianorossin$masterquestdb
-- ------------------------------------------------------
-- Server version	5.6.40-log

/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!40101 SET NAMES utf8 */;
/*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */;
/*!40103 SET TIME_ZONE='+00:00' */;
/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;

--
-- Dumping data for table `auth_group`
--

LOCK TABLES `auth_group` WRITE;
/*!40000 ALTER TABLE `auth_group` DISABLE KEYS */;
/*!40000 ALTER TABLE `auth_group` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Dumping data for table `auth_group_permissions`
--

LOCK TABLES `auth_group_permissions` WRITE;
/*!40000 ALTER TABLE `auth_group_permissions` DISABLE KEYS */;
/*!40000 ALTER TABLE `auth_group_permissions` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Dumping data for table `auth_permission`
--

LOCK TABLES `auth_permission` WRITE;
/*!40000 ALTER TABLE `auth_permission` DISABLE KEYS */;
INSERT INTO `auth_permission` VALUES (1,'Can add log entry',1,'add_logentry'),(2,'Can change log entry',1,'change_logentry'),(3,'Can delete log entry',1,'delete_logentry'),(4,'Can view log entry',1,'view_logentry'),(5,'Can add permission',2,'add_permission'),(6,'Can change permission',2,'change_permission'),(7,'Can delete permission',2,'delete_permission'),(8,'Can view permission',2,'view_permission'),(9,'Can add group',3,'add_group'),(10,'Can change group',3,'change_group'),(11,'Can delete group',3,'delete_group'),(12,'Can view group',3,'view_group'),(13,'Can add user',4,'add_user'),(14,'Can change user',4,'change_user'),(15,'Can delete user',4,'delete_user'),(16,'Can view user',4,'view_user'),(17,'Can add content type',5,'add_contenttype'),(18,'Can change content type',5,'change_contenttype'),(19,'Can delete content type',5,'delete_contenttype'),(20,'Can view content type',5,'view_contenttype'),(21,'Can add session',6,'add_session'),(22,'Can change session',6,'change_session'),(23,'Can delete session',6,'delete_session'),(24,'Can view session',6,'view_session'),(25,'Can add answer',7,'add_answer'),(26,'Can change answer',7,'change_answer'),(27,'Can delete answer',7,'delete_answer'),(28,'Can view answer',7,'view_answer'),(29,'Can add invite control',8,'add_invitecontrol'),(30,'Can change invite control',8,'change_invitecontrol'),(31,'Can delete invite control',8,'delete_invitecontrol'),(32,'Can view invite control',8,'view_invitecontrol'),(33,'Can add participant',9,'add_participant'),(34,'Can change participant',9,'change_participant'),(35,'Can delete participant',9,'delete_participant'),(36,'Can view participant',9,'view_participant'),(37,'Can add questionnaire',10,'add_questionnaire'),(38,'Can change questionnaire',10,'change_questionnaire'),(39,'Can delete questionnaire',10,'delete_questionnaire'),(40,'Can view questionnaire',10,'view_questionnaire'),(41,'Can add task',11,'add_task'),(42,'Can change task',11,'change_task'),(43,'Can delete task',11,'delete_task'),(44,'Can view task',11,'view_task'),(45,'Can add dt model',12,'add_dtmodel'),(46,'Can change dt model',12,'change_dtmodel'),(47,'Can delete dt model',12,'delete_dtmodel'),(48,'Can view dt model',12,'view_dtmodel'),(49,'Can add answer task id',13,'add_answertaskid'),(50,'Can change answer task id',13,'change_answertaskid'),(51,'Can delete answer task id',13,'delete_answertaskid'),(52,'Can view answer task id',13,'view_answertaskid'),(53,'Can add latin square',14,'add_latinsquare'),(54,'Can change latin square',14,'change_latinsquare'),(55,'Can delete latin square',14,'delete_latinsquare'),(56,'Can view latin square',14,'view_latinsquare');
/*!40000 ALTER TABLE `auth_permission` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Dumping data for table `auth_user`
--

LOCK TABLES `auth_user` WRITE;
/*!40000 ALTER TABLE `auth_user` DISABLE KEYS */;
/*!40000 ALTER TABLE `auth_user` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Dumping data for table `auth_user_groups`
--

LOCK TABLES `auth_user_groups` WRITE;
/*!40000 ALTER TABLE `auth_user_groups` DISABLE KEYS */;
/*!40000 ALTER TABLE `auth_user_groups` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Dumping data for table `auth_user_user_permissions`
--

LOCK TABLES `auth_user_user_permissions` WRITE;
/*!40000 ALTER TABLE `auth_user_user_permissions` DISABLE KEYS */;
/*!40000 ALTER TABLE `auth_user_user_permissions` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Dumping data for table `django_admin_log`
--

LOCK TABLES `django_admin_log` WRITE;
/*!40000 ALTER TABLE `django_admin_log` DISABLE KEYS */;
/*!40000 ALTER TABLE `django_admin_log` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Dumping data for table `django_content_type`
--

LOCK TABLES `django_content_type` WRITE;
/*!40000 ALTER TABLE `django_content_type` DISABLE KEYS */;
INSERT INTO `django_content_type` VALUES (1,'admin','logentry'),(3,'auth','group'),(2,'auth','permission'),(4,'auth','user'),(5,'contenttypes','contenttype'),(7,'questionnaire','answer'),(13,'questionnaire','answertaskid'),(12,'questionnaire','dtmodel'),(8,'questionnaire','invitecontrol'),(14,'questionnaire','latinsquare'),(9,'questionnaire','participant'),(10,'questionnaire','questionnaire'),(11,'questionnaire','task'),(6,'sessions','session');
/*!40000 ALTER TABLE `django_content_type` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Dumping data for table `django_migrations`
--

LOCK TABLES `django_migrations` WRITE;
/*!40000 ALTER TABLE `django_migrations` DISABLE KEYS */;
INSERT INTO `django_migrations` VALUES (1,'contenttypes','0001_initial','2019-12-18 18:00:00.138216'),(2,'auth','0001_initial','2019-12-18 18:01:06.015825'),(3,'admin','0001_initial','2019-12-18 18:01:25.604116'),(4,'admin','0002_logentry_remove_auto_add','2019-12-18 18:01:25.703903'),(5,'admin','0003_logentry_add_action_flag_choices','2019-12-18 18:01:25.724011'),(6,'contenttypes','0002_remove_content_type_name','2019-12-18 18:01:25.824667'),(7,'auth','0002_alter_permission_name_max_length','2019-12-18 18:01:25.876258'),(8,'auth','0003_alter_user_email_max_length','2019-12-18 18:01:25.966910'),(9,'auth','0004_alter_user_username_opts','2019-12-18 18:01:25.979755'),(10,'auth','0005_alter_user_last_login_null','2019-12-18 18:01:26.025229'),(11,'auth','0006_require_contenttypes_0002','2019-12-18 18:01:26.030401'),(12,'auth','0007_alter_validators_add_error_messages','2019-12-18 18:01:26.042370'),(13,'auth','0008_alter_user_username_max_length','2019-12-18 18:01:26.089116'),(14,'auth','0009_alter_user_last_name_max_length','2019-12-18 18:01:26.140562'),(15,'auth','0010_alter_group_name_max_length','2019-12-18 18:01:26.184640'),(16,'auth','0011_update_proxy_permissions','2019-12-18 18:01:26.199905'),(17,'questionnaire','0001_initial','2019-12-18 18:01:46.487217'),(18,'questionnaire','0002_auto_20191021_2348','2019-12-18 18:03:32.771013'),(19,'questionnaire','0003_auto_20191022_0335','2019-12-18 18:03:33.575131'),(20,'questionnaire','0004_auto_20191022_1538','2019-12-18 18:03:33.723240'),(21,'questionnaire','0005_auto_20191024_1306','2019-12-18 18:04:10.898251'),(22,'questionnaire','0006_auto_20191026_1325','2019-12-18 18:05:06.509336'),(23,'questionnaire','0007_auto_20191026_1340','2019-12-18 18:05:07.696941'),(24,'questionnaire','0008_auto_20191026_1342','2019-12-18 18:05:08.053559'),(25,'questionnaire','0009_auto_20191028_1253','2019-12-18 18:05:08.085926'),(26,'questionnaire','0010_task_shortname','2019-12-18 18:05:15.769714'),(27,'questionnaire','0011_auto_20191028_2211','2019-12-18 18:05:15.820072'),(28,'questionnaire','0012_auto_20191029_1406','2019-12-18 18:05:38.307844'),(29,'questionnaire','0013_auto_20191029_1412','2019-12-18 18:05:38.399306'),(30,'questionnaire','0014_auto_20191029_1523','2019-12-18 18:05:45.046213'),(31,'questionnaire','0015_auto_20191029_1739','2019-12-18 18:05:45.189656'),(32,'questionnaire','0016_auto_20191030_0043','2019-12-18 18:06:17.997918'),(33,'questionnaire','0017_task_sequencenumber','2019-12-18 18:06:24.189389'),(34,'questionnaire','0018_auto_20191030_1458','2019-12-18 18:06:24.218838'),(35,'questionnaire','0019_auto_20191031_1509','2019-12-18 18:06:24.398119'),(36,'questionnaire','0020_auto_20191101_1529','2019-12-18 18:06:24.423252'),(37,'questionnaire','0021_auto_20191101_1545','2019-12-18 18:06:31.846870'),(38,'questionnaire','0022_auto_20191104_1154','2019-12-18 18:06:31.986907'),(39,'questionnaire','0023_auto_20191106_0252','2019-12-18 18:06:44.115035'),(40,'questionnaire','0024_participant_mlbackground','2019-12-18 18:06:49.742816'),(41,'questionnaire','0025_auto_20191107_0339','2019-12-18 18:06:49.861588'),(42,'questionnaire','0026_auto_20191107_0537','2019-12-18 18:07:21.665284'),(43,'questionnaire','0027_auto_20191111_1212','2019-12-18 18:07:41.131413'),(44,'questionnaire','0028_auto_20191112_0321','2019-12-18 18:08:21.062901'),(45,'questionnaire','0029_remove_answer_secondstoanswer','2019-12-18 18:08:21.334932'),(46,'questionnaire','0030_remove_dtmodel_modeltreepath','2019-12-18 18:08:21.503045'),(47,'questionnaire','0031_auto_20191112_0422','2019-12-18 18:08:21.542815'),(48,'questionnaire','0032_auto_20191123_1927','2019-12-18 18:08:21.858739'),(49,'questionnaire','0033_auto_20191124_1613','2019-12-18 18:08:57.232865'),(50,'questionnaire','0034_auto_20191124_1648','2019-12-18 18:08:57.254888'),(51,'questionnaire','0035_auto_20191124_2032','2019-12-18 18:09:03.142723'),(52,'questionnaire','0036_auto_20191125_1431','2019-12-18 18:09:33.237529'),(53,'questionnaire','0037_auto_20191125_1434','2019-12-18 18:09:33.294625'),(54,'questionnaire','0038_auto_20191125_1440','2019-12-18 18:09:40.642850'),(55,'questionnaire','0039_auto_20191126_1458','2019-12-18 18:09:40.724892'),(56,'questionnaire','0040_auto_20191204_1508','2019-12-18 18:10:06.707185'),(57,'questionnaire','0041_auto_20191205_0320','2019-12-18 18:10:55.118619'),(58,'questionnaire','0042_remove_answer_dtmodel','2019-12-18 18:10:55.262725'),(59,'questionnaire','0043_auto_20191207_1245','2019-12-18 18:11:21.100291'),(60,'questionnaire','0044_auto_20191207_1757','2019-12-18 18:11:21.214262'),(61,'questionnaire','0045_auto_20191207_1807','2019-12-18 18:11:21.275924'),(62,'questionnaire','0046_auto_20191207_1845','2019-12-18 18:11:25.606231'),(63,'questionnaire','0047_answer_secondstoanswer','2019-12-18 18:11:30.698507'),(64,'questionnaire','0048_dtmodel_dtnodes','2019-12-18 18:11:36.738534'),(65,'questionnaire','0049_answer_isdt','2019-12-18 18:11:43.529032'),(66,'questionnaire','0050_auto_20191212_1145','2019-12-18 18:11:43.798693'),(67,'questionnaire','0051_auto_20191218_1538','2019-12-18 18:11:52.784466'),(68,'questionnaire','0052_auto_20191218_1719','2019-12-18 18:11:52.924229'),(69,'sessions','0001_initial','2019-12-18 18:12:06.026411'),(70,'questionnaire','0053_auto_20191219_1730','2019-12-30 03:07:13.373810'),(71,'questionnaire','0054_auto_20191219_1732','2019-12-30 03:07:13.394418'),(72,'questionnaire','0055_auto_20191224_1926','2019-12-30 03:07:22.545904'),(73,'questionnaire','0056_auto_20191224_2133','2019-12-30 03:10:48.448190'),(74,'questionnaire','0057_auto_20191224_2235','2019-12-30 03:10:50.026646'),(75,'questionnaire','0058_auto_20191230_0259','2019-12-30 03:10:50.073842'),(76,'questionnaire','0059_task_isdummy','2020-01-02 08:07:07.960366'),(77,'questionnaire','0060_auto_20200107_1702','2020-01-08 01:18:05.648437'),(78,'questionnaire','0061_auto_20200107_1707','2020-01-08 01:18:07.736694'),(79,'questionnaire','0062_auto_20200109_1240','2020-01-10 14:28:52.806922'),(80,'questionnaire','0063_auto_20200110_0323','2020-01-10 14:28:52.830253'),(81,'questionnaire','0064_auto_20200110_1356','2020-01-10 14:28:52.842721');
/*!40000 ALTER TABLE `django_migrations` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Dumping data for table `django_session`
--

LOCK TABLES `django_session` WRITE;
/*!40000 ALTER TABLE `django_session` DISABLE KEYS */;
INSERT INTO `django_session` VALUES ('0w9d3zdcoynt280d5aontzma143m1oa0','Nzg4OGZlYTY5YThmYzRmMGQyN2YwYjQ3MTJmODE1OTA4OTJmYzU2NTp7fQ==','2020-01-25 14:54:45.927277'),('0yzd9dajme3w9b5sgmgq1wimyfaewzzb','Nzg4OGZlYTY5YThmYzRmMGQyN2YwYjQ3MTJmODE1OTA4OTJmYzU2NTp7fQ==','2020-01-17 23:06:24.844395'),('2z7vjfi2jksgfudwj9qtwbvyh203cu3o','Nzg4OGZlYTY5YThmYzRmMGQyN2YwYjQ3MTJmODE1OTA4OTJmYzU2NTp7fQ==','2020-01-10 17:18:59.353075'),('39tvxluwsu1wxjco79qqtgyqm272cg7y','Nzg4OGZlYTY5YThmYzRmMGQyN2YwYjQ3MTJmODE1OTA4OTJmYzU2NTp7fQ==','2020-01-17 14:32:57.548653'),('3d3nex6yi3ywzsr0jbg1ieqqj62bpn0x','NGE3MDllY2MzMDE4NzNkMDk4NjgxOTE4N2YzMzM1YjAyMjQ4YTQzMzp7ImxhdGluU3F1YXJlSWQiOjIyLCJwYXJ0aWNpcGFudElkIjoiNjA5MDEzMDJhNSIsImN1cnJlbnRSb3ciOjEsImN1cnJlbnRUYXNrSWQiOjEzLCJ0YXNrc0xpc3QiOlsxNCwzLDEzLDExLDcsNCwxMiw2LDgsMTYsNSwxNV19','2020-01-24 13:31:41.317827'),('3hu4mmkokwiml5z5p3tl56pzm426gp6r','N2ZhYzdmZWE3OGI1YzM5NDEzZmU3Yzg5NWNiNjhhZjYyYzA2OTA5MTp7ImxhdGluU3F1YXJlSWQiOjM4LCJwYXJ0aWNpcGFudElkIjoiMTBjMDFkNTgwNiIsImN1cnJlbnRSb3ciOjEsImN1cnJlbnRUYXNrSWQiOjE1LCJ0YXNrc0xpc3QiOlsxMSwzLDQsMTQsNywxMyw1LDYsMTUsMTIsOCwxNl19','2020-01-25 14:54:42.729757'),('3y0lm4fa3q36opt5rysfteknx9q8bb4w','Nzg4OGZlYTY5YThmYzRmMGQyN2YwYjQ3MTJmODE1OTA4OTJmYzU2NTp7fQ==','2020-01-25 14:32:03.263408'),('4e0n6uv0rxdhxm05kvgm308ytx6507ur','Nzg4OGZlYTY5YThmYzRmMGQyN2YwYjQ3MTJmODE1OTA4OTJmYzU2NTp7fQ==','2020-01-24 01:21:11.634061'),('5765jtw7pdj181njwevebu99atelxr71','MGI2N2FiN2M5ZTIxNTYwNzVmNDgwMjEwZWQ1NGJmNWMwOGY4ZDlmZTp7ImxhdGluU3F1YXJlSWQiOjEwLCJwYXJ0aWNpcGFudElkIjoiOTQyM2IzNDI3YyIsImN1cnJlbnRSb3ciOjEsImN1cnJlbnRUYXNrSWQiOjMsInRhc2tzTGlzdCI6WzMsMTEsNyw0LDE0LDEzLDE1LDgsMTIsMTYsNiw1XX0=','2020-01-24 18:48:15.911993'),('5lcvsqlnto2wo44wowoi8c5hrw4b3boy','Nzg4OGZlYTY5YThmYzRmMGQyN2YwYjQ3MTJmODE1OTA4OTJmYzU2NTp7fQ==','2020-01-15 03:02:57.277164'),('7gejv6fjl3akhnosslwdfjwfwisvpnbr','Nzg4OGZlYTY5YThmYzRmMGQyN2YwYjQ3MTJmODE1OTA4OTJmYzU2NTp7fQ==','2020-01-25 16:02:22.261859'),('appqvspygkilfx530jw8zfs5g0dsytqr','Nzg4OGZlYTY5YThmYzRmMGQyN2YwYjQ3MTJmODE1OTA4OTJmYzU2NTp7fQ==','2020-01-13 21:22:21.166244'),('ce6p655lflumhlpi4pf3q15p4la1d6ck','MTdmYjRiYmUzOTA4ODE2NjNkZGNjZTQxOTQ2NjM4MzFkZDBmOWMyMzp7ImxhdGluU3F1YXJlSWQiOjIyLCJwYXJ0aWNpcGFudElkIjoiZGM2NzgxZDM0MyIsImN1cnJlbnRSb3ciOjAsImN1cnJlbnRUYXNrSWQiOjE0LCJ0YXNrc0xpc3QiOlsxNCwzLDEzLDExLDcsNCwxMiw2LDgsMTYsNSwxNV19','2020-01-24 15:35:27.345404'),('cny7n2mmbw3azoi4v1xywbfvf0ybyen7','OWNmMDZlN2M5Zjk0NGExNjYwZjAzMjIwMzBiMDI5MjFmYjgyNzRjNDp7ImxhdGluU3F1YXJlSWQiOjIwLCJwYXJ0aWNpcGFudElkIjoiM2NiOTFiOWQzZSIsImN1cnJlbnRSb3ciOjAsImN1cnJlbnRUYXNrSWQiOjQsInRhc2tzTGlzdCI6WzQsMTQsNywzLDExLDEzLDEyLDYsMTYsNSw4LDE1XX0=','2020-01-23 23:57:29.712833'),('cz6eby88fl6v8hgjfomctzql0b4g4buv','ODYyNmIyNTc0MDY5Yzc0ODVkMjY4ODlhNjM1OWZmZDNhYWE4NmRjMDp7ImxhdGluU3F1YXJlSWQiOjE5LCJwYXJ0aWNpcGFudElkIjoiMjUyZDUyZmM2NCIsImN1cnJlbnRSb3ciOjAsImN1cnJlbnRUYXNrSWQiOjMsInRhc2tzTGlzdCI6WzMsMTQsNCwxMyw3LDExLDgsMTIsNSwxNSw2LDE2XX0=','2020-01-17 20:26:15.416938'),('drnleefbm00j42h545cxoawi82hq7pmy','ZTkxNTM3OTFlZDcwOGFlOWE4Y2U3ZTI0ODQ2NjcxYjJjMzIwODAxMTp7ImxhdGluU3F1YXJlSWQiOjE5LCJwYXJ0aWNpcGFudElkIjoiYzQyYWZkMmU3YSIsImN1cnJlbnRSb3ciOjEsImN1cnJlbnRUYXNrSWQiOjMsInRhc2tzTGlzdCI6WzMsMTQsNCwxMyw3LDExLDgsMTIsNSwxNSw2LDE2XX0=','2020-01-17 13:56:05.746643'),('duc71silmu9qrfehnf16sydk2if6n0gm','Y2IwMTc4NTM3ODVlMGIyYWMzZGViNDg4Y2RlNjA4OWMyOTM3NmZmODp7ImxhdGluU3F1YXJlSWQiOjMsInBhcnRpY2lwYW50SWQiOiIwYmFlNzA1MDU2IiwiY3VycmVudFJvdyI6MCwiY3VycmVudFRhc2tJZCI6NywidGFza3NMaXN0IjpbNyw5LDMsMTEsNCw4LDYsMTAsNSwxMl19','2019-12-19 22:07:05.494296'),('e7gwch87ew91q4h89hv2h8fdjfr6tapp','NGYxNjViZGQzZWE0NWY2ZDQwM2Q4YzI4ZTViYzZlYTczODkxMzA1YTp7ImxhdGluU3F1YXJlSWQiOjE2LCJwYXJ0aWNpcGFudElkIjoiMzdjNGVlM2MxOCIsImN1cnJlbnRSb3ciOjAsImN1cnJlbnRUYXNrSWQiOjEzLCJ0YXNrc0xpc3QiOlsxMywxMSw0LDMsNywxNCw4LDE2LDYsNSwxMiwxNV19','2020-01-23 23:36:37.414513'),('e9b5u5ze7mwl55osnd75nf9vegs29igl','ZjBiZDBmM2I4OTJhNWI0ZDczMjRlNTQxNzgwNGJjZTI3Zjc3MGRmZDp7ImxhdGluU3F1YXJlSWQiOjM2LCJwYXJ0aWNpcGFudElkIjoiMWFmYTQxOTI2MSIsImN1cnJlbnRSb3ciOjEsImN1cnJlbnRUYXNrSWQiOjMsInRhc2tzTGlzdCI6WzcsNCwxNCwxMywzLDExLDE2LDEyLDE1LDgsNSw2XX0=','2020-01-25 15:31:18.053660'),('eoqahachgg6t50hmg0wxw3ors4m9q1ux','NWYxNDZkYWY4MWQ4M2NlMTU0M2UyMjM5MmM3MGViMzhjZjRkZDI2MDp7ImxhdGluU3F1YXJlSWQiOjM4LCJwYXJ0aWNpcGFudElkIjoiMTk3NTg5YjJhZiIsImN1cnJlbnRSb3ciOjAsImN1cnJlbnRUYXNrSWQiOjMsInRhc2tzTGlzdCI6WzExLDMsNCwxNCw3LDEzLDUsNiwxNSwxMiw4LDE2XX0=','2020-01-25 15:48:09.224948'),('fcs8u2igw383x38snsdybhxh8g6kn25t','YTY3ZDNhNDcwMGY3M2MyYmIyZTA5MmQ2ODEwMGU3ZTFiNDA0NDM2NDp7ImxhdGluU3F1YXJlSWQiOjM0LCJwYXJ0aWNpcGFudElkIjoiMWE2ODJlY2ZkZCIsImN1cnJlbnRSb3ciOjAsImN1cnJlbnRUYXNrSWQiOjQsInRhc2tzTGlzdCI6WzMsMTMsNCwxNCwxMSw3LDgsMTYsNiw1LDE1LDEyXX0=','2020-01-25 14:39:41.505225'),('gfk3kbqibav5s8beim6yee6j4joqvmu7','Nzg4OGZlYTY5YThmYzRmMGQyN2YwYjQ3MTJmODE1OTA4OTJmYzU2NTp7fQ==','2019-12-30 04:19:21.562077'),('guq437gjxxves6lnenqnl7es2pj9cff1','OTM2MTFkOTk2MWE0MjkxZGZlZWZjODQzOTI4Nzc2MjdkNmQxZTMzZDp7ImxhdGluU3F1YXJlSWQiOjE3LCJwYXJ0aWNpcGFudElkIjoiNTQwZTI1ZGQ3ZCIsImN1cnJlbnRSb3ciOjEsImN1cnJlbnRUYXNrSWQiOjcsInRhc2tzTGlzdCI6WzcsMTEsNCwxMywxNCwzLDE1LDUsMTIsNiwxNiw4XX0=','2020-01-16 01:12:39.925177'),('gy0iv9ua4ji7t2ln4opmd6khbimxyan4','Nzg4OGZlYTY5YThmYzRmMGQyN2YwYjQ3MTJmODE1OTA4OTJmYzU2NTp7fQ==','2020-01-25 14:38:53.153916'),('hb2i0l6rnjnrcr3ubdzbx559xpuqhxt8','YTAwMmJmZDJkMWNhMmI1OWRjZWY0ZTM0YTZlNzhmZWRkZDU5MzkzNzp7ImxhdGluU3F1YXJlSWQiOjIzLCJwYXJ0aWNpcGFudElkIjoiY2RhZWIyYTc2MyIsImN1cnJlbnRSb3ciOjAsImN1cnJlbnRUYXNrSWQiOjMsInRhc2tzTGlzdCI6WzMsMTQsNCwxMSw3LDEzLDgsMTUsMTYsMTIsNSw2XX0=','2020-01-24 18:17:55.487454'),('i5uymkz9nqntxv6de5q2wm1sf99kdgv0','Nzg4OGZlYTY5YThmYzRmMGQyN2YwYjQ3MTJmODE1OTA4OTJmYzU2NTp7fQ==','2020-01-25 15:15:30.445221'),('ie0j19mjry57jsfzo3o23wda98kjygdz','Nzg4OGZlYTY5YThmYzRmMGQyN2YwYjQ3MTJmODE1OTA4OTJmYzU2NTp7fQ==','2020-01-16 17:06:36.585770'),('ijk8zri6tu4767lpmmxfnhmeya7hno79','NTVlNWZiMGRhMThmN2U2YmVjODFhNzQ3MzkzMTZmOGQ0ZGI2NjI5NTp7ImxhdGluU3F1YXJlSWQiOjM5LCJwYXJ0aWNpcGFudElkIjoiZTg4MWE3MzQ5ZSIsImN1cnJlbnRSb3ciOjAsImN1cnJlbnRUYXNrSWQiOjExLCJ0YXNrc0xpc3QiOlsxMSw0LDMsMTMsMTQsNyw2LDE2LDE1LDgsMTIsNV19','2020-01-25 15:55:13.760959'),('iozgktyyyzzsmeiydvsjdmas1ij7wi1k','Nzg4OGZlYTY5YThmYzRmMGQyN2YwYjQ3MTJmODE1OTA4OTJmYzU2NTp7fQ==','2020-02-01 13:33:09.611081'),('ivulcuohevrvcdj0l9zpc3aagqg6lko3','Nzg4OGZlYTY5YThmYzRmMGQyN2YwYjQ3MTJmODE1OTA4OTJmYzU2NTp7fQ==','2020-01-13 18:28:35.889673'),('j2qp10ppmrs6fbfc13wruz059us867kk','Nzg4OGZlYTY5YThmYzRmMGQyN2YwYjQ3MTJmODE1OTA4OTJmYzU2NTp7fQ==','2020-01-25 14:54:43.758212'),('ju4g8cyohpr0412jg59yvkntfyyokmgl','ZTA4MzVjNmYxODEzM2M2YjBhMWRlYWI2MGZlY2Q2YjIxNDhhODMxNDp7ImxhdGluU3F1YXJlSWQiOjIwLCJwYXJ0aWNpcGFudElkIjoiMmQwMzZmZTM0ZiIsImN1cnJlbnRSb3ciOjAsImN1cnJlbnRUYXNrSWQiOjQsInRhc2tzTGlzdCI6WzQsMTQsNywzLDExLDEzLDEyLDYsMTYsNSw4LDE1XX0=','2020-01-25 07:04:22.104333'),('juennlov1twfe7d0vlz1p5vr3xw2yyxi','Nzg4OGZlYTY5YThmYzRmMGQyN2YwYjQ3MTJmODE1OTA4OTJmYzU2NTp7fQ==','2020-01-25 14:20:37.020290'),('k2g9fk1zxgke6vy9yh0vrlce5zfbuly5','ZTkwZmIwOTIzYmI2NjAzMWQ4NGI0YjU3ODE3MjA4YmVmYTVkODhlNjp7ImxhdGluU3F1YXJlSWQiOjIsInBhcnRpY2lwYW50SWQiOiJhZjY3NzJhNDFjIiwiY3VycmVudFJvdyI6MCwiY3VycmVudFRhc2tJZCI6NiwidGFza3NMaXN0IjpbMTEsNCw3LDMsOSw2LDEwLDgsMTIsNV19','2019-12-18 20:20:33.022828'),('kbfz8zvr8sbyczpgaymhent3xpmgxzoj','Nzg4OGZlYTY5YThmYzRmMGQyN2YwYjQ3MTJmODE1OTA4OTJmYzU2NTp7fQ==','2020-01-14 21:39:47.542768'),('l6xroz6dbak7ow6out8y08on9c9n86nw','Nzg4OGZlYTY5YThmYzRmMGQyN2YwYjQ3MTJmODE1OTA4OTJmYzU2NTp7fQ==','2020-01-11 03:33:50.882989'),('lcv1jp9e96e26qj97719siwk43xpi6i3','Nzg4OGZlYTY5YThmYzRmMGQyN2YwYjQ3MTJmODE1OTA4OTJmYzU2NTp7fQ==','2020-01-25 15:01:56.514864'),('lge7jmidtiyen7tai99nuh0vilwb1xd6','Nzg4OGZlYTY5YThmYzRmMGQyN2YwYjQ3MTJmODE1OTA4OTJmYzU2NTp7fQ==','2020-01-02 09:32:59.569688'),('lgennqtxgg5w285za24wra3uenyxvsjl','MTFhNGExNmM3YTIyOTVmOTM5MzlmNGRiNjk1MTVlYTZkYzU2Mzc5OTp7ImxhdGluU3F1YXJlSWQiOjIsInBhcnRpY2lwYW50SWQiOiJlNGE3MTE0MzEzIiwiY3VycmVudFJvdyI6MSwiY3VycmVudFRhc2tJZCI6MTAsInRhc2tzTGlzdCI6WzExLDQsNywzLDksNiwxMCw4LDEyLDVdfQ==','2019-12-18 22:18:42.571378'),('mg2exi23vdn88syhhbpobmpw7byd2ygr','ZWQwZjg0NzljMDY4NzFiYWVmODlhYzMwNmY5ZTkwYjMzMzZiYWIwZDp7ImxhdGluU3F1YXJlSWQiOjEwLCJwYXJ0aWNpcGFudElkIjoiYTRiNzc5ZDMxOCIsImN1cnJlbnRSb3ciOjEsImN1cnJlbnRUYXNrSWQiOjMsInRhc2tzTGlzdCI6WzMsMTEsNyw0LDE0LDEzLDE1LDgsMTIsMTYsNiw1XX0=','2020-01-26 00:07:48.693415'),('mskkk47c9b1my4aknb56o9xmd27coj4f','Nzg4OGZlYTY5YThmYzRmMGQyN2YwYjQ3MTJmODE1OTA4OTJmYzU2NTp7fQ==','2020-01-24 01:49:22.056338'),('nith6ahffsem1kdm8dch14gugio77lqt','Nzg4OGZlYTY5YThmYzRmMGQyN2YwYjQ3MTJmODE1OTA4OTJmYzU2NTp7fQ==','2020-01-10 17:54:30.678093'),('nj6fzzchqxultmpw46ull4n8gbzi3rq1','Nzg4OGZlYTY5YThmYzRmMGQyN2YwYjQ3MTJmODE1OTA4OTJmYzU2NTp7fQ==','2020-01-02 21:22:31.361056'),('odehotgl1pb714vmsvs6rmsn5g62gv30','YzRmOTllMzUwNzdiYjdjMjgxMTEyNDAxZWJkOGVmNWJjMWU1NDI2NTp7ImxhdGluU3F1YXJlSWQiOjMzLCJwYXJ0aWNpcGFudElkIjoiNDAwMTk4ZjM3ZSIsImN1cnJlbnRSb3ciOjAsImN1cnJlbnRUYXNrSWQiOjUsInRhc2tzTGlzdCI6WzE0LDEzLDExLDQsNywzLDE2LDgsNSw2LDE1LDEyXX0=','2020-01-25 14:49:35.623680'),('p3dtdnlkci9jd2aq333q4hogkfxw2tt7','MTA3Mzk3YzFkZmE4YmU1Mzg3NzNjYzhmMDM3YTU1ZThkOTc4M2IxNzp7ImxhdGluU3F1YXJlSWQiOjMzLCJwYXJ0aWNpcGFudElkIjoiNjhkZDdlNTZjZSIsImN1cnJlbnRSb3ciOjEsImN1cnJlbnRUYXNrSWQiOjcsInRhc2tzTGlzdCI6WzE0LDEzLDExLDQsNywzLDE2LDgsNSw2LDE1LDEyXX0=','2020-01-25 14:37:12.246421'),('pf5ul2256ueohgaz0u0fmjn61sqzymmp','OTliZGU3ODQyZGYxMzg4YjJlNjJlY2U2ZTQxODk3NjYxOGM1MjNiYjp7ImxhdGluU3F1YXJlSWQiOjUsInBhcnRpY2lwYW50SWQiOiJiNzk0ZTBlYzJjIiwiY3VycmVudFJvdyI6MCwiY3VycmVudFRhc2tJZCI6OSwidGFza3NMaXN0IjpbMyw3LDksMTEsMTQsNCwxMywxNiwxMCwxMiw1LDYsMTUsOF19','2020-01-03 16:09:41.131560'),('q0dtidhgvuccwottjgw53x0y1a8jgr1r','Nzg4OGZlYTY5YThmYzRmMGQyN2YwYjQ3MTJmODE1OTA4OTJmYzU2NTp7fQ==','2020-01-13 19:21:11.339748'),('q6axkumqrbhvxeeigqsmv876todd3ys3','YjczNWIwZWQ1NWEyZmUzNDZhZjIyOGIyNWRjNDFlZjExMGExYmI3ODp7ImxhdGluU3F1YXJlSWQiOjM5LCJwYXJ0aWNpcGFudElkIjoiZmVjNmE4YTMwOSIsImN1cnJlbnRSb3ciOjEsImN1cnJlbnRUYXNrSWQiOjExLCJ0YXNrc0xpc3QiOlsxMSw0LDMsMTMsMTQsNyw2LDE2LDE1LDgsMTIsNV19','2020-01-25 19:52:16.387508'),('qoke1uy09ammbcs6924h7fnvanvtvb04','MDYwNDM5MDIxNDk0OGY5ZGMxMzc4OWZmZjFkZWUwM2Y4ODdkMDY2Yzp7ImxhdGluU3F1YXJlSWQiOjYsInBhcnRpY2lwYW50SWQiOiJiZjY2NmQ5NmZhIiwiY3VycmVudFJvdyI6MSwiY3VycmVudFRhc2tJZCI6OCwidGFza3NMaXN0IjpbMTMsOSwxMSwxNCw3LDMsNCw4LDE2LDE1LDEyLDUsMTAsNl19','2020-01-08 02:22:16.269231'),('r1y5dub3l32es58x7k2h9huj9ycz0nq6','OWQyMzk3ZGQ4YWUxMWE0NWNhYzMwMjBmNWM1MTZkNzNmMTBkM2Y3NTp7ImxhdGluU3F1YXJlSWQiOjMwLCJwYXJ0aWNpcGFudElkIjoiM2Q5ZjhlODk0NiIsImN1cnJlbnRSb3ciOjAsImN1cnJlbnRUYXNrSWQiOjcsInRhc2tzTGlzdCI6WzMsMTQsMTEsNCwxMyw3LDgsNiwxNiw1LDEyLDE1XX0=','2020-01-25 14:12:19.443230'),('re0bgd7vwhv0tmt0hd58jmh0x63lh42o','MzU0OTBhNTA2YTc1ZGE2OWE1NGRjZjYzYmQwZTZhMWU1Y2YxMjQwZTp7ImxhdGluU3F1YXJlSWQiOjEwLCJwYXJ0aWNpcGFudElkIjoiMmQyZWUzNGJkMiIsImN1cnJlbnRSb3ciOjEsImN1cnJlbnRUYXNrSWQiOjcsInRhc2tzTGlzdCI6WzMsMTEsNyw0LDE0LDEzLDE1LDgsMTIsMTYsNiw1XX0=','2020-01-10 16:51:25.011257'),('rsdjhwk1xvz1geydt6javunujrxnvf64','MDFlOTFkNzhlYjMwYmQ0ZTQ0YTM2ZjAwODgxOThiMzMwZTNjZGIwNzp7ImxhdGluU3F1YXJlSWQiOjE2LCJwYXJ0aWNpcGFudElkIjoiNGM5YmQ2OTU4MCIsImN1cnJlbnRSb3ciOjAsImN1cnJlbnRUYXNrSWQiOjEzLCJ0YXNrc0xpc3QiOlsxMywxMSw0LDMsNywxNCw4LDE2LDYsNSwxMiwxNV19','2020-01-24 23:23:08.158626'),('rsmtepsej6m209ptkz14xsi3vasov5oo','Nzg4OGZlYTY5YThmYzRmMGQyN2YwYjQ3MTJmODE1OTA4OTJmYzU2NTp7fQ==','2020-01-25 14:55:32.168665'),('sfsz9x00cfecje8bosdi3zxzl2n1emzn','Nzg4OGZlYTY5YThmYzRmMGQyN2YwYjQ3MTJmODE1OTA4OTJmYzU2NTp7fQ==','2020-01-25 14:27:02.073966'),('spzcy490nxw89nnz7uavn0xbhf3k8lgs','NjQ3ODNiZTBlZjc4YmM0MzE1M2ViZWU1MjJlMTU0ZjEyN2ZjNjdhOTp7ImxhdGluU3F1YXJlSWQiOjEwLCJwYXJ0aWNpcGFudElkIjoiNTg2NWU4ZTQyNyIsImN1cnJlbnRSb3ciOjEsImN1cnJlbnRUYXNrSWQiOjMsInRhc2tzTGlzdCI6WzMsMTEsNyw0LDE0LDEzLDE1LDgsMTIsMTYsNiw1XX0=','2020-01-23 22:50:42.726242'),('u0lupacj84khosl3rmxrp9l519jkeeop','Nzg4OGZlYTY5YThmYzRmMGQyN2YwYjQ3MTJmODE1OTA4OTJmYzU2NTp7fQ==','2020-01-25 14:43:27.535578'),('u1wfewsh29bbpm8y1pxsnuiy6bzciqdw','ZjRiM2NiMmFmMTkwNWZjMDNlNjJjNGM1MzE3MjU3NDE2ZmNlNWZhMDp7ImxhdGluU3F1YXJlSWQiOjksInBhcnRpY2lwYW50SWQiOiI4ZGU0MGNjNjY2IiwiY3VycmVudFJvdyI6MCwiY3VycmVudFRhc2tJZCI6NywidGFza3NMaXN0IjpbNyw0LDMsMTQsMTEsMTMsNiwxNiwxNSw4LDUsMTJdfQ==','2020-01-10 16:05:08.491697'),('u6xtknza140ibcwzbg6ywvkh9hid50do','Nzg4OGZlYTY5YThmYzRmMGQyN2YwYjQ3MTJmODE1OTA4OTJmYzU2NTp7fQ==','2020-01-25 14:09:25.247430'),('v3p6jy4v12tf5e15i8bgwngbckiboz7s','Mzk0NDdkMjQ0NTM3NTg2MDZlMTg4ZTAyYTEzZjQxZWE0MjA4YTEzNDp7ImxhdGluU3F1YXJlSWQiOjM1LCJwYXJ0aWNpcGFudElkIjoiZjUwYmNjZTIyNiIsImN1cnJlbnRSb3ciOjAsImN1cnJlbnRUYXNrSWQiOjE0LCJ0YXNrc0xpc3QiOlsxMywxMSw0LDMsNywxNCwxNSwxNiw2LDUsMTIsOF19','2020-01-25 14:54:45.561289'),('vfg2j6i1at0lk4iqyaewfmqutp3x2rup','YzA4M2M0ZGM5NTg5Njg4MTlmZmNiMzFjZDk5NzAzN2YzYjgwNzcwYTp7ImxhdGluU3F1YXJlSWQiOjM1LCJwYXJ0aWNpcGFudElkIjoiZTc4NDFlNGZlZCIsImN1cnJlbnRSb3ciOjEsImN1cnJlbnRUYXNrSWQiOjcsInRhc2tzTGlzdCI6WzEzLDExLDQsMyw3LDE0LDE1LDE2LDYsNSwxMiw4XX0=','2020-01-25 14:52:08.564660'),('w2wuygrylqr3dwygxsiv0u6wppjfcgtg','Nzg4OGZlYTY5YThmYzRmMGQyN2YwYjQ3MTJmODE1OTA4OTJmYzU2NTp7fQ==','2020-01-15 16:39:51.114221'),('wa7vwd8ogxjljq5jw05qvg1l3e83akw2','NWY5MzdhODZjZjk1MDE3ODdjYzgzNzI5YTgzNGFjZGY0NjcwYzJhNzp7ImxhdGluU3F1YXJlSWQiOjYsInBhcnRpY2lwYW50SWQiOiIxM2NjMGMzOGE5IiwiY3VycmVudFJvdyI6MCwiY3VycmVudFRhc2tJZCI6MTMsInRhc2tzTGlzdCI6WzEzLDksMTEsMTQsNywzLDQsOCwxNiwxNSwxMiw1LDEwLDZdfQ==','2020-01-07 13:44:31.935327'),('x25tp9tqynqhq65uijlovmek2gguazgn','ZjQ2MWUzNDQzOWM3ZTRjNjIzNDNmNDUxMDQ2NDc2ZDdhNzBkZmUxMzp7ImxhdGluU3F1YXJlSWQiOjEyLCJwYXJ0aWNpcGFudElkIjoiMzU3ZDE4MWI0NSIsImN1cnJlbnRSb3ciOjAsImN1cnJlbnRUYXNrSWQiOjEzLCJ0YXNrc0xpc3QiOlsxMyw0LDcsMTEsMywxNCw4LDE2LDE1LDEyLDUsNl19','2020-01-10 18:37:47.033024'),('xx1hzcss0eqothc1mv8qhnryyc0y9lke','Nzg4OGZlYTY5YThmYzRmMGQyN2YwYjQ3MTJmODE1OTA4OTJmYzU2NTp7fQ==','2020-01-25 14:49:47.639139'),('y9vm3o6jqupy8p789lhnot77nghsf5xb','NDUzZTUyNDdkNzU1YzQ5MWU5MTVhNDVlMzFlZDYwMjhlMzM3YjQ1MDp7ImxhdGluU3F1YXJlSWQiOjE2LCJwYXJ0aWNpcGFudElkIjoiNjEzNmU1YzI3MyIsImN1cnJlbnRSb3ciOjAsImN1cnJlbnRUYXNrSWQiOjEzLCJ0YXNrc0xpc3QiOlsxMywxMSw0LDMsNywxNCw4LDE2LDYsNSwxMiwxNV19','2020-01-15 03:40:06.401603'),('z3f9gz4kecyuwn5upp4z2mk9yclwqf3c','NjNkNzk3YTUwYTkyMzNmZWVkMmQxMzA5M2IxMGM1N2ZmMGU4ZjY4ODp7ImxhdGluU3F1YXJlSWQiOjI3LCJwYXJ0aWNpcGFudElkIjoiMGI1OWJmY2Y1NyIsImN1cnJlbnRSb3ciOjEsImN1cnJlbnRUYXNrSWQiOjMsInRhc2tzTGlzdCI6WzQsNywxMSwxNCwzLDEzLDE2LDgsNiwxMiw1LDE1XX0=','2020-01-25 14:51:35.983414'),('z67yo6xaeul5m6msr9ukepfoaynun5io','YWRhYzJmODhmNDYzNDNjYTY0OGI3Zjg1ZThjNjY1Zjk4YTg2Y2ViNjp7ImxhdGluU3F1YXJlSWQiOjE3LCJwYXJ0aWNpcGFudElkIjoiOGUyZGIzY2ViYiIsImN1cnJlbnRSb3ciOjAsImN1cnJlbnRUYXNrSWQiOjcsInRhc2tzTGlzdCI6WzcsMTEsNCwxMywxNCwzLDE1LDUsMTIsNiwxNiw4XX0=','2020-01-15 20:26:44.070504'),('zbhpcfq1b28bl0wykqv3hrndobngz33e','YjhmNTA3ODQyMTI4YTE2YWM5Mjc1NTI3NWI4MzM1M2M2ODg2YTNhMjp7ImxhdGluU3F1YXJlSWQiOjE2LCJwYXJ0aWNpcGFudElkIjoiZDViMGUxZGIwMSIsImN1cnJlbnRSb3ciOjAsImN1cnJlbnRUYXNrSWQiOjEzLCJ0YXNrc0xpc3QiOlsxMywxMSw0LDMsNywxNCw4LDE2LDYsNSwxMiwxNV19','2020-01-28 03:21:28.223931'),('ztzvhaivd5git8t2omna8gsi4uxjx7mu','ZTk5NzYyOTJlMTA2YjExZGY1MGE0YzljNjEwMjBhMDhkNWY4NjYwZDp7ImxhdGluU3F1YXJlSWQiOjIwLCJwYXJ0aWNpcGFudElkIjoiNzZmMGJiOTk1ZiIsImN1cnJlbnRSb3ciOjAsImN1cnJlbnRUYXNrSWQiOjcsInRhc2tzTGlzdCI6WzQsMTQsNywzLDExLDEzLDEyLDYsMTYsNSw4LDE1XX0=','2020-01-21 19:43:38.118499');
/*!40000 ALTER TABLE `django_session` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Dumping data for table `ms_answer`
--

LOCK TABLES `ms_answer` WRITE;
/*!40000 ALTER TABLE `ms_answer` DISABLE KEYS */;
INSERT INTO `ms_answer` VALUES (100,15,3,665.76,0),(101,15,11,182.37,0),(102,16,3,119.14,1),(103,16,11,169.35,1),(104,16,7,250.75,1),(105,16,4,235.66,1),(106,16,14,47.85,1),(107,16,13,146.06,1),(108,17,14,123.08,0),(109,16,15,40.97,0),(110,16,8,42.01,0),(111,16,12,78.03,0),(112,17,3,219.97,0),(113,16,16,115.34,0),(114,17,4,105.1,0),(115,16,6,68.97,0),(116,17,11,128.57,0),(117,16,5,142.71,0),(118,17,13,53.48,0),(119,17,7,276.41,0),(120,17,5,566.21,1),(121,17,12,238.87,1),(122,17,8,417.36,1),(123,17,15,192.91,1),(124,17,16,214.65,1),(125,17,6,163.44,1),(126,18,14,61.44,1),(127,18,3,92.27,1),(128,18,4,203.81,1),(129,18,11,464.67,1),(130,18,13,74.98,1),(131,18,7,56.76,1),(132,18,5,71.9,0),(133,18,12,103.19,0),(134,18,8,101.16,0),(135,18,15,74.96,0),(136,18,16,32.73,0),(137,18,6,22.79,0),(138,21,14,125.4,0),(139,21,7,729.32,0),(140,21,4,264.6,0),(141,21,3,407.24,0),(142,21,11,672.42,0),(143,21,13,74,0),(144,21,12,981.37,1),(145,21,8,621.59,1),(146,21,15,352.48,1),(147,21,16,153.04,1),(148,21,5,383.63,1),(149,21,6,183.67,1),(150,22,14,247.99,1),(151,22,7,359.49,1),(152,22,4,194.87,1),(153,22,3,239.27,1),(154,22,11,981.75,1),(155,22,13,50.63,1),(156,22,12,86.96,0),(157,22,8,29.1,0),(158,22,15,27.43,0),(159,23,14,776.24,1),(160,22,16,133.06,0),(161,22,5,60.62,0),(162,22,6,83.45,0),(163,23,11,477.52,1),(164,23,4,231.23,1),(165,23,7,1239.82,1),(166,23,13,297.61,1),(167,23,3,282.57,1),(168,23,8,143.38,0),(169,23,6,229.04,0),(170,23,15,26.61,0),(171,23,12,66.7,0),(172,23,5,298.46,0),(173,23,16,35.92,0),(174,24,14,177.53,0),(175,24,11,225.39,0),(176,24,4,112.89,0),(177,24,7,414.61,0),(178,24,13,37.68,0),(179,24,3,134.45,0),(180,24,8,396.42,1),(181,24,6,429.67,1),(182,24,15,842.52,1),(183,24,12,527.65,1),(184,24,5,1458.43,1),(185,24,16,595.62,1),(186,25,4,114.81,0),(187,25,14,83.19,0),(188,25,3,76.85,0),(189,25,7,205.19,0),(190,25,11,173.91,0),(191,25,13,25.52,0),(192,25,5,477.74,1),(193,25,8,81.67,1),(194,25,6,57.28,1),(195,25,16,89.5,1),(196,25,12,40.64,1),(197,25,15,143.85,1),(198,26,4,234.12,1),(199,26,14,129.4,1),(200,26,3,193.09,1),(201,26,7,388.12,1),(202,26,11,328.6,1),(203,26,13,87.08,1),(204,26,5,119.02,0),(205,26,8,51.64,0),(206,26,6,57.84,0),(207,26,16,30.72,0),(208,26,12,58.18,0),(209,26,15,31.02,0),(210,28,13,314.11,0),(211,28,11,95.45,0),(212,28,4,284.98,0),(213,28,3,949.33,0),(214,28,7,385.25,0),(215,28,14,91.38,0),(216,28,8,1113.42,1),(217,28,16,292.77,1),(218,28,6,2383.73,1),(219,28,5,1844.87,1),(220,28,12,1525.97,1),(221,28,15,830.75,1),(222,31,4,268.57,1),(223,31,7,199.14,1),(224,31,11,383.86,1),(225,31,14,54.67,1),(226,31,3,643.19,1),(227,31,13,56,1),(228,31,8,78.94,0),(229,31,5,352.18,0),(230,31,6,86.93,0),(231,31,12,190.65,0),(232,31,16,76.06,0),(233,31,15,25.13,0),(234,32,4,828.5,0),(235,32,7,383.39,0),(236,32,11,110.61,0),(237,32,14,59.93,0),(238,32,3,341.03,0),(239,32,13,52.32,0),(240,32,8,323.97,1),(241,32,5,630.21,1),(242,32,6,245.56,1),(243,32,12,212.07,1),(244,32,16,133.16,1),(245,32,15,124.88,1),(246,36,4,81.5,0),(247,36,14,39.86,0),(248,36,7,94.84,0),(249,36,3,78.55,0),(250,36,11,16.59,0),(251,36,13,17.23,0),(252,36,12,156.82,1),(253,36,6,35.65,1),(254,36,16,46.02,1),(255,36,5,78.03,1),(256,36,8,46.51,1),(257,36,15,31.02,1),(258,37,4,2908.42,1),(259,37,14,699.65,1),(260,41,4,482.82,1),(261,42,4,57.62,0),(262,42,7,246.96,0),(263,42,14,122.48,0),(264,41,7,1487.71,1),(265,42,3,186.54,0),(266,42,13,104.86,0),(267,42,11,64.69,0),(268,42,12,141.7,1),(269,41,14,538.88,1),(270,42,8,329.57,1),(271,41,3,413.39,1),(272,42,16,195.41,1),(273,42,15,96.37,1),(274,41,13,98.69,1),(275,42,6,545.18,1),(276,42,5,515.91,1),(277,41,11,1185.9,1),(278,41,12,192.97,0),(279,41,8,164,0),(280,41,16,40.64,0),(281,41,15,29.18,0),(282,41,6,109.12,0),(283,41,5,1008.79,0),(284,43,14,132.09,0),(285,43,3,175.09,0),(286,50,4,273.29,0),(287,49,3,449.31,0),(288,52,4,340.55,0),(289,50,14,214.17,0),(290,53,4,608.64,1),(291,49,14,358.8,0),(292,52,11,411.39,0),(293,52,14,88.48,0),(294,49,4,250.34,0),(295,50,11,499.26,0),(296,51,4,982.15,1),(297,52,13,269.07,0),(298,53,11,659.39,1),(299,52,7,84.59,0),(300,49,11,564.83,0),(301,52,3,359.2,0),(302,53,14,613.82,1),(303,50,7,1036.91,0),(304,52,12,369.13,1),(305,53,13,205.64,1),(306,54,3,1965.59,1),(307,57,4,801.93,1),(308,49,7,828.54,0),(309,51,14,1332.94,1),(310,52,5,289.24,1),(311,50,3,376.56,0),(312,50,13,44.99,0),(313,49,13,161.81,0),(314,53,7,363.67,1),(315,55,3,2099.04,0),(316,54,11,397.24,1),(317,50,16,321.69,1),(318,51,11,450.54,1),(319,53,3,263.16,1),(320,57,7,472.49,1),(321,63,3,509.9,0),(322,53,12,138.83,0),(323,68,3,392.71,0),(324,54,13,306.49,1),(325,63,14,172.54,0),(326,71,14,413.37,1),(327,52,15,668.46,1),(328,53,5,140.04,0),(329,62,3,907.04,1),(330,53,15,31.16,0),(331,50,12,406.27,1),(332,55,11,620.83,0),(333,71,13,204.68,1),(334,53,6,112.21,0),(335,62,14,188.08,1),(336,53,16,69.64,0),(337,68,13,376.01,0),(338,50,8,189.01,1),(339,53,8,70.77,0),(340,63,11,443,0),(341,62,11,123.22,1),(342,54,7,529.82,1),(343,62,4,93.06,1),(344,55,13,320.29,0),(345,52,6,495.37,1),(346,51,7,754.04,1),(347,63,4,125.17,0),(348,62,13,26.17,1),(349,56,4,2565.57,0),(350,50,15,222.6,1),(351,63,13,107.72,0),(352,57,11,873.37,1),(353,52,16,146.2,1),(354,54,14,281.12,1),(355,68,4,328.1,0),(356,57,14,231.3,1),(357,54,4,120.39,1),(358,49,8,1078.12,1),(359,50,5,322.38,1),(360,72,14,610.75,0),(361,52,8,359.93,1),(362,74,3,421.99,0),(363,74,13,66.4,0),(364,54,8,259.74,0),(365,57,3,266.05,1),(366,71,11,998.55,1),(367,72,13,308.43,0),(368,54,6,102.81,0),(369,74,4,146.35,0),(370,54,15,46.8,0),(371,63,7,690.35,0),(372,51,3,775,1),(373,74,14,62.13,0),(374,55,7,893.37,0),(375,50,6,507.04,1),(376,74,11,73.49,0),(377,54,5,142.52,0),(378,51,13,113.74,1),(379,57,13,317.73,1),(380,68,7,728.36,0),(381,54,12,89.17,0),(382,55,14,137.55,0),(383,63,8,226.03,1),(384,74,7,153.39,0),(385,73,3,1257.8,1),(386,68,14,94.23,0),(387,49,15,694.89,1),(388,51,16,157.65,0),(389,63,6,78.85,1),(390,75,13,649.08,0),(391,57,16,210.56,0),(392,80,13,306.53,0),(393,72,11,465.09,0),(394,54,16,173.12,0),(395,51,12,111.94,0),(396,76,13,663.11,1),(397,74,8,158.94,1),(398,74,16,31.09,1),(399,57,8,102.36,0),(400,68,11,204.61,0),(401,63,16,141.94,1),(402,49,16,209.08,1),(403,71,4,650.58,1),(404,51,8,166.53,0),(405,74,6,137.57,1),(406,80,4,261.21,0),(407,51,15,84,0),(408,56,7,1446.72,0),(409,74,5,86.38,1),(410,72,4,329.91,0),(411,57,6,263.16,0),(412,80,7,121.51,0),(413,78,7,799.61,1),(414,55,4,530.25,0),(415,74,15,68.72,1),(416,79,13,761.74,1),(417,74,12,39.27,1),(418,71,7,294.69,1),(419,80,14,85.19,0),(420,73,13,575.03,1),(421,81,11,63.1,0),(422,68,12,408.38,1),(423,80,3,92.58,0),(424,49,12,478.68,1),(425,75,11,637.39,0),(426,81,3,119.98,0),(427,51,5,328.04,0),(428,80,11,70.15,0),(429,71,3,231.78,1),(430,51,6,62.17,0),(431,57,12,351.24,0),(432,76,11,673.13,1),(433,79,4,287.1,1),(434,56,11,437.43,0),(435,81,4,133.16,0),(436,81,14,106.13,0),(437,71,16,170.36,0),(438,63,5,754.51,1),(439,75,4,292.73,0),(440,76,4,225.51,1),(441,80,5,312.68,1),(442,68,5,462.78,1),(443,57,5,274.12,0),(444,55,8,620.46,1),(445,49,5,422.64,1),(446,81,7,207.63,0),(447,71,8,203.81,0),(448,79,7,351.79,1),(449,57,15,94.47,0),(450,80,15,123.17,1),(451,81,13,44.75,0),(452,63,12,252.29,1),(453,80,12,61.96,1),(454,76,3,230.58,1),(455,56,14,437.17,0),(456,75,3,312.69,0),(457,55,6,219.57,1),(458,80,6,86.46,1),(459,81,5,132.67,1),(460,79,14,216.15,1),(461,80,16,52.77,1),(462,81,6,122.87,1),(463,63,15,250.22,1),(464,76,7,195.51,1),(465,80,8,74.12,1),(466,79,3,94.8,1),(467,68,16,417.49,1),(468,49,6,403.12,1),(469,55,15,215.89,1),(470,68,8,110.04,1),(471,79,11,156.22,1),(472,68,15,106.04,1),(473,77,7,2224.97,0),(474,68,6,186.61,1),(475,79,5,554.57,0),(476,79,15,67.33,0),(477,79,12,107.13,0),(478,79,6,48.6,0),(479,79,16,135.34,0),(480,79,8,73.78,0),(481,77,4,910.86,0),(482,77,14,147.28,0),(483,77,13,772.8,0),(484,82,11,15.58,1),(485,55,5,3442.04,1),(486,55,12,451.39,1),(487,55,16,81.34,1),(488,89,4,866.17,1),(489,89,14,144.8,1),(490,89,7,323.66,1),(491,89,3,457.08,1),(492,89,11,195.75,1),(493,89,13,414.8,1),(494,89,12,195.5,0),(495,89,6,627.69,0),(496,89,16,134.8,0),(497,89,5,400.57,0),(498,89,8,313.97,0),(499,89,15,195.24,0);
/*!40000 ALTER TABLE `ms_answer` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Dumping data for table `ms_answerTaskID`
--

LOCK TABLES `ms_answerTaskID` WRITE;
/*!40000 ALTER TABLE `ms_answerTaskID` DISABLE KEYS */;
INSERT INTO `ms_answerTaskID` VALUES (100,2,'Grande quantidade métodos.\r\nGrande quantidade de dados.\r\nMétodos tratando partes muitos distintas.',''),(101,2,'Uma quantidade considerável de parâmetros.\r\nA maioria dos parâmetros recebidos poderiam ser recebido de uma forma mais simples.',''),(102,2,'The class is big and have too much code and variables','none'),(103,1,'It does have a long parameter list, could be avoided, but most of them are used in the new segment.','Helped me to see the number of statements, inputs, etc, since it has too many lines.'),(104,1,'The child class uses few methods from parent.','Helped me to identify why it was a refused bequest and leaded me to search the reason it was a bad smell'),(105,-1,'It does too much in just one method, could be avoided, spliting it in different functions, but it does what it says in method: get dependencies','helped me to identify where to search'),(106,-2,'The method just have three lines','none'),(107,-1,'Doesn\'t seem like it is a GOD class, it has few lines and three functions.','made me think about the cohesion between the methods implemented in this class'),(108,-2,'The method has only 3 lines of code and performs only 3 tasks related to the same context.',''),(109,-2,'doesn\'t have a long list of parameters.',''),(110,2,'The class is really long and implements too much for just one class',''),(111,1,'It receives a lot of information and returns a function with a lot of parameters too, so, it looks like a bad smell',''),(112,1,'The class has one clear responsibility \"scanning a directory for files/directories which match certain criteria\". However, the class is a little big (much of the lines are comments, though).',''),(113,-1,'It is just a class to compile snippets, it uses other classes in the process, doesn\'t implement them.',''),(114,2,'The method is complex and could be \"broken\" into at least two more methods. One for the \"we first search for the dependency in cache\" part, and another for the \"get module descriptor\" part.',''),(115,2,'It is a long method, could be avoided by splitting some excerpts in functions.',''),(116,1,'The parameter list is a little big and some parameters could be encapsulated in objects. Though, 7 parameters with small names do not actually harm readability.',''),(117,2,'The child class uses almost nothing from parent.',''),(118,-2,'The class is small and has a clear purpose.',''),(119,2,'Many methods provided by the parent class are never used by the child class.',''),(120,2,'Most of the methods from the parent class are never used by the child class.','Not much. The child class has a low DIT, but it could have redefined all inherited methods or could have not used none of methods.'),(121,2,'There are 7 parameters, where a few of them are from user-defined classes, making the list harder to comprehend.','Not much. The low number of declarative statements says nothing to me about a long parameter list. From my point of view, a method with no declarative statements and few parameters is perfectly possible.'),(122,1,'The class is bigger than it could be, that\'s for sure. However, this is a scanner for a compiler. It has to be somewhat big, due to the inevitable large amount of switches required, each one with an inevitable large amount of cases required.','Both metrics state that the class is complex, which is true.'),(123,-2,'The method has no parameters at all.','Not much. That\'s exactly the case mentioned in one of my prior tasks.'),(124,-1,'This class simply has a constructor. The constructor has a high number of parameters, though.','Not much, since I don\'t agree with the decision tree output.'),(125,2,'Some of the work on this method could definitely be extracted to other methods.','The decision tree output was based on the large number of source lines, which seems correct for this method.'),(126,-2,'Poucas linhas de código.\r\nMétodo consizo.','A quantidade de linhas de código.\r\nA quantidade de elementos que o método processa.'),(127,2,'Muitos dados armazenados.\r\nBastante métodos.\r\nMétodos processando abstrações distintas.','Quantidade de linhas.'),(128,1,'Muitas linhas de códigos.\r\nMuitos dados sendo processados em apenas um método.','Linhas de códigos.'),(129,1,'Quantidade considerável de parâmetros.','Número de declarações'),(130,-2,'Poucas linhas de código.\r\nMétodos tratam poucas abstrações.','Linhas de código.'),(131,1,'Pouco uso dos métodos herdados.','Métodos herdados em uso.'),(132,1,'Pouco uso de métodos herdados.',''),(133,-1,'A necessidade dos parâmetros.',''),(134,2,'Quantidade de linhas de códigos.\r\nGrande quantidade de dados sendo processadas.\r\nMuitas métodos distintos.',''),(135,-2,'Poucos parâmetros.\r\nAtributos adquirido no método.',''),(136,-2,'Poucos métodos.\r\nPoucas linhas de código.',''),(137,2,'Muitas linhas de código.\r\nMuitos dados e abstrações sendo processadas.',''),(138,-2,'O método é muito curto para ser classificado como longo, possui apenas três linhas de código.',''),(139,2,'Apenas 2 dos 17 métodos que são herdados da classe pai são utilizados na classe filha. Apenas métodos getters e setters estão acessíveis na herança.',''),(140,2,'O método é grande e complexo.',''),(141,-1,'A classe não centraliza diferentes funcionalidades. É muito grande, porém possui muita documentação. Possui muitas instâncias de variáveis, porém parecem necessárias ao domínio da classe.',''),(142,-1,'Sete não parece um número muito grande para parâmetros de um método.',''),(143,-2,'A classe é bem pequena e não centraliza funcionalidades.',''),(144,-1,'Sete não parece um número grande para uma lista de parâmetros. Além do mais não sei se há a possibilidade de diminuir esse número, pois o método apenas cria uma instância da super classe.','A árvore não deu insights para a minha decisão. Uma coisa que me deixou confuso foi o nó: Declarative Statements < 3, então Smelly Code?? Parece ir contra o conceito do Long Parameter List.'),(145,1,'A classe é muito grande, apensar de não aparentar implementar diferentes responsabilidades do sistema.','As métricas presentes na árvore, são interessantes de se considerar na avaliação do Code Smell. O nó: Percent Lack of Cohesion in Methods <= 31% apresenta informação útil.'),(146,-2,'O método execute() não possui parâmetros.','A árvore não auxilia na decisão, dado que a análise visual do método já indica que ele não possui parâmetros.'),(147,-2,'A classe é bem pequena e não centraliza diferente responsabilidades.','A árvore aumenta a confiança da decisão, pois tem um ramo onde: Lines With Source Code < 612, então Not Smelly Code.'),(148,2,'Poucos elementos da classe pai são utilizados na classe filha.','A árvore não possui informação útil que auxilie na decisão tomada.'),(149,2,'O método é grande e complexo.','Os nós da árvore possuem métricas relacionadas a Long Method que devem ser considerados, porém os valores presentes na árvores não são decisivos para guiar uma decisão.'),(150,-2,'The code is tiny, only three lines of code, to be classified as long method. Its a false positive?','None.'),(151,-2,'The class presented does not override the methods inherited.','None.'),(152,1,'The size of the method is directly related to the project. Then, I can\'t strongly agree with that. But, for me, the code is too long.','Looking at the code was better for me than looking at the tree.'),(153,1,'The class has high cohesion.','The DT help me to know that the class has a high cohesion without knowing the system.'),(154,1,'The method has a long parameter list.','That methods with more than 7 parameters are smelly.'),(155,-2,'For me, the class is not a smell.','None;'),(156,-1,'Not is clear that is a smelly class because idk the size of methods of the project.',''),(157,1,'I agree that the class is smelly.',''),(158,-2,'The class has a low number of parameters.',''),(159,-2,'The eval () method has only 3 lines, so it is not a code smell. How many lines does the initScriptRunner () method has? Is this information important? If the initScriptRunner () method does what it should do, I think it\'s not a very important one.','In this case, nothing. Forgive me if I misunderstood the numbers of the tree.'),(160,-1,'I\'m not sure about the response above because I haven\'t access to the class Complier.',''),(161,-2,'I can\'t see any overriding methods.',''),(162,1,'For me, the class characterizes as a long method, but I do not have certain.',''),(163,2,'In my opinion, seven arguments (six primitives and one object) is a code smell. I believe that if there is a real world abstraction for the six primitive arguments, then they should become one or two objects.','The decision tree didn\'t help me in this case, but I can see its usefulness.'),(164,2,'146 lines without any comment? Agree strongly.','In this case, the decision tree is perfect.'),(165,-2,'There is one @Override only.','In this case, there is no direct relationship.'),(166,-2,'in my view, it\'s a simple class.','why this source code has more than 612 lines? I did not understand.'),(167,2,'This example is totally different from the previous one. In this case, I believe the class has many responsibilities.','In this case, its ok.'),(168,2,'This class is very large and its methods are also very large. There is a great chance of being a god class.',''),(169,2,'I believe that lines 34 39 and 42 could join line 24. Also, 217 lines are too many lines for just one method.',''),(170,-2,'it makes no sense',''),(171,1,'I don\'t know if it\'s a code smell because the parameter list has objects and not just primitive types.',''),(172,1,'((StreamMessage)_message).readBoolean();\r\n((StreamMessage)_message).readByte()\r\n((StreamMessage)_message).readBytes(value);\r\n(StreamMessage)_message).readChar()\r\n...\r\nI think this could be improved',''),(173,-1,'In my view, it\'s a simple class.',''),(174,-2,'The method is only 3 lines long.',''),(175,2,'There are seven parameters in this method. \r\nBased on their names, it seems that they should belong to an object, than, passing every one of them as a parameter instead of passing an object containing them, seems to be a smell.',''),(176,2,'This method has 143 lines long. \r\nBased on its name, is a \'get\' method, but, as a \'get\' method, it does a lot of work and its huge.\r\nIt should be divided in smaller tasks, it would make easier to read and to understand.',''),(177,1,'Do not uses a few parent methods on its toString',''),(178,-2,'Small class, only used to evaluate and check a value.',''),(179,1,'It seems a huge class with many variables and methods, but it seems that its a library class for file system purposes and all the functionalities seems to be placed right where they should be.',''),(180,2,'Almost 3k lines. No Class should have that size.','In this particular case, the decision tree did not help me. But was good to see the rules.'),(181,2,'Method is 215 lines long.\r\nThe name of the method is \'check\'. And it really does a lot of checks, but looks like its doing too much checks, those could be separeted in small tasks and use O.O features instead of too many ifs.','The comment code ratio was a interesting thing to see.'),(182,-2,'The method in question has zero parameters.','The decision tree isn\'t about long parameter lists.'),(183,2,'Seven parameters is too much parameters.\r\nSome could be avoidable.','None'),(184,1,'Just a few methods are not used','The tree helped me to think about the depth of the inheritance'),(185,-2,'Simple class with only one method','The tree is wrong.'),(186,2,'The method has 146 lines, so it is too long.',''),(187,-2,'It has only few lines of code.',''),(188,2,'In fact it centralizes too much methods and responsibilities.',''),(189,2,'Only few parts of the parent class are used.',''),(190,2,'It seems that the parameter plugin could be avoidable.',''),(191,-2,'It does not seem a good class',''),(192,2,'It seems that a lot of the parent class is redefined or not used.','I was a kind of confuse if number of physical lines are related with only the lines of the parent, used in the child class.'),(193,2,'Lack of cohesion among the methods.','The base values in the tree helped to quickly decide about the smell.'),(194,2,'Too many lines of code in a single method.','The base values.'),(195,2,'Despite of not being long, it seems there is not cohesion between the methods.','Base values, mainly about the lack of cohesion.'),(196,2,'Too much parameters','The base values for declarative statements.'),(197,2,'It seems the parameters come from elsewhere not explicitly pointed, and there is many comments.','The base values.'),(198,2,'Based on the high number of lines in the method, it was easy to identify the Long Method smell.','Since this is a simple smell, only looking to the number of  LOC on the source code was enough to decide if it was a Long Method. The decision tree helped me in understanding the metrics used to define the Long Method.'),(199,-2,'The method has only three LOC.','Since this is a simple smell, only looking to the number of  LOC on the source code was enough to decide if it was a Long Method. The decision tree helped me in understanding the metrics used to define the Long Method.'),(200,2,'The class is dealing with many responsibilities and it is too long.','The node related to \"Percent Lack of Cohesion in Methods\" was not easy to understand in terms of code behavior. Based on the tree, the first node was key to define if it was a God Class.'),(201,1,'Based on the high number of physical lines and DIT > 2.','An easier understanding of the problem based on the two nodes that define the smell.'),(202,2,'There is a high number of parameters used on the method.','It was confusing. The first node in my interpretation was True, then by the tree, it should not be a smell code. However, when we look at the code, there is a Long Parameter List due to the high number of parameters used on the method.'),(203,-2,'The class has only 68 LOC and a few methods that do not encapsulate so many logic.','Based on the first node, we can tell easily that this is not a god class.'),(204,-1,'It appears that the child class is not redefining so many methods of the parent.',''),(205,2,'Yes. The class is both too long as well as has too many responsibilities that should be implemented in other classes.',''),(206,1,'Appear to be a long method. But to be sure, it would be interesting to know the average lines of code of this software system. Maybe this is a common number LOC for the methods.',''),(207,-2,'The class is only defining a few constructors.',''),(208,-1,'These parameters are needed to call the super method.',''),(209,-2,'There is no parameter being called.',''),(210,-2,'A classe faz apenas uma operação de avaliação, logo não poderia ser uma God Class.',''),(211,2,'A classe contém sete parâmetros e deve dificultar a avaliação de cada um.',''),(212,2,'O nome do método não condiz com as atividades que são realizadas, além de ser um método extenso.',''),(213,1,'Acredito que as atividades das classes envolvem a responsabilidade de busca arquivos por determinados critérios. Mas observo que existem métodos muito extensos e encadeamentos de condições, o que pode induzir a outro code smell.',''),(214,2,'A classe em questão utiliza poucos recursos da classe pai.',''),(215,-2,'O método é bastante curto e tem uma responsabilidade definida, mas acredito que o nome poderia deixar mais clara essa responsabilidade.',''),(216,2,'A classe apresenta alta coesão entre os métodos e apresenta muitas linhas de código.','Após visualizar a árvore de revisão, percebi que cada método é utilizado pelo menos três vezes na mesma classe, misturando as responsabilidade.'),(217,-2,'A classe é bastante curta e apresenta um único método.','Após análise da árvore de decisão, ficou fácil indicar que não era um code  smell.'),(218,2,'O método possui muitas verificações e responsabilidades que poderiam ser divididas em outros métodos.','Verificando a árvore de decisão, percebe-se que o método possui muitas linhas de código fonte, sendo que uma pequena parte são comentários.'),(219,2,'A herança não faz sentido, já que a classe abaixo da hierarquia utiliza apenas um atributo e apenas um método da herança. Conclui-se que realmente trata-se do bad smell referido.','A árvore de decisão ajudou a definir como o bad smell referido através da verificação de linhas de código física e a profundidade da árvore de herança.'),(220,-1,'O método possui muitos parâmetros e dificulta a leitura do código.','Verificando a árvore de decisão, existe uma inconsistência já que o destaque em laranja deveria ir até o nó Taxa de Comentário no Código.'),(221,-2,'O método em questão não possui parâmetros, logo não deveria ser classificado como Long Parameter List.','árvore de decisão ajudou a confirmar que o código é ruim, analisando a quantidade de entradas e taxa de comentários no código.'),(222,1,'Me parece longo, mas não muito. Me falta contexto para tomar a decisão com maior certeza.','Mais um efeito psicológico na tomada de decisão. Um pouco mais de confiança no que tinha em mente.'),(223,-2,'Não me pareceu que a classe redefine muitos métodos da classe pai. Na verdade ela possui muitos métodos novos.','Nenhum'),(224,2,'Não apenas pelo tamanho de parâmetros, mas pelo que o nome de alguns, este método parece uma gambiarra, métodos deveriam ser extraídos ou consultados.  Por exemplo, está sendo passado um booleano \"delete\" e uma string de plugins.','Nenhuma. Na verdade a árvore não apresentea explicitamente \"parâmetros\" como critério de decisão.'),(225,-2,'Obviamente o método não é longo','Nenhum.'),(226,2,'\"Class for scanning a directory for files/directories which match certain\r\ncriteria.\"  No entanto, a preparação de dados critérios de verificação sugerem a oportunidade de diferentes classes.','Percent Lack of Cohesion in Methods'),(227,-2,'Não faz sentido considerando a definição','A árvore fez um tratamento errado'),(228,2,'O tamanho me  assustou. Não cheguei a olhar em profundidade.',''),(229,2,'Devido à definição \"2\" de Refused Bequest',''),(230,2,'O nome genérico do método (check) já sugere que não vem coisa boa... existem muitos testes com vários operadores relacionais para diferentes finalidades, poderiam ser métodos distintos.',''),(231,-1,'Parece-me que os parâmetros são pertinentes o contexto de se criar um arquivo (se for isto que deve ser feito), exceto pelo \"progress\"',''),(232,-2,'Classe pequena, poucos métodos. Parece até incompleta.',''),(233,-2,'Não vi nenhuma lista de parametros longa.',''),(234,2,'It\'s possible extract methods to separate responsibilities from method getDependency.',''),(235,1,'Agree slightly, the QpidActivationSpec fits on item 2 but define more data and methods, is extension of ConnectionFactoryProperties and implements ActivationSpec.',''),(236,2,'It\'s possible reduce number of parameters to one if create a class called BenchmarkConfiguration with necessary data.',''),(237,-2,'Does not fit any of the items.',''),(238,1,'Mayabe to create utility classes to reduce the different responsibilities of the DirectoryScanner class and reduce the complexity.',''),(239,-2,'Does not fit either item.',''),(240,2,'Mayabe to create utility classes to reduce the different responsibilities of the DirectoryScanner class and reduce the complexity.','Possibility create utility class with methods not use class instance variable (it\'s possible view by decision tree).'),(241,-1,'1. The class NOT redefining most of the inherited methods\r\n2. Not used methods and data from parents because in this case is one extension','This metric of number of physical lines is affected by lines with \"{\" in another line'),(242,2,'The number of lines is affected by lines with \"{\". It\'s possible extract methods from \"check\".','The choose by shown decision tree is based only number of lines, this is bad.'),(243,2,'It\'s possible reduce to one the number of params, creating a class with configuration data.','Why not the number of parameters?'),(244,-2,'Does not fit either item.','Did not help'),(245,-2,'In shown code not have methods with long params list.','Did not help. Why not the number of parameters?'),(246,2,'Method seems to be very long!',''),(247,-2,'Very small',''),(248,-1,'It does not seem redefining inherited methods',''),(249,1,'Seems to be very long, maybe god class, but I\'m not sure',''),(250,2,'Too many parameters',''),(251,-1,'Too short to be god class',''),(252,-1,'not too many parameters','helped'),(253,2,'too long','helped to see lines'),(254,-1,'too short','I do not have experience with cohesion'),(255,1,'Depth of Inheritance','Helped to see depth of Inheritance'),(256,1,'too long','I do not have experience with cohesion'),(257,-1,'do not see may parameters','did not help too much'),(258,1,'My choice is more related to the Cyclomatic Complexity because I don\'t think that the number of source code lines is decisive to classify this smell into a long method.','In this case, I don\'t agree with the path of the decision tree for the classification in smelly code.'),(259,-2,'The method is too small in lines of code.','A value of the number of lines with source code considered small.'),(260,2,'too many line codes; lots of code descision structures and calls that can be refatctored to smaller methods','made the decision more objective (saves time)'),(261,2,'This is doing far too much. This should be broken down into smaller functions that each can be tested and verified.',''),(262,-2,'This class only overrides one method (toString), so it\'s not that problem. This is saying that it\'s bad to extend a class but then not use most of its base class internals, and I disagree with that. This class specifically looks like it\'s a true extension of the base class, and just trusts the uses for the base class to do its job without interfering.',''),(263,-2,'It\'s definitely not too long. It _might_ be doing too much, but at the end of the day, this is pretty clean to me: It initializes the script runner, executes a particular script, and then returns the evaluated value.',''),(264,-1,'classes seem to be in thesame project, maybe they have wrong hierarchy but \r\n\r\n1 - all methods on parent class are gets and sets and many are used in subclass\r\n2 - by just looking to these two classes it is not possible to infer if other classes are just using the parent methods (parent class is not abstract)\r\n3 - by just looking to these two classes it is not possible to infer if other children classes are not using the parent methods','the rule in decision tree seems too simple (maybe result in a false positive in an automated tool) but it was useful to review the design of two classes that eventually were not going to be reviewed at all (or at least not reviewed with full attention)'),(265,-1,'I do think that this class could be broken into a few different classes, or at least have some of the configuration be done in separate classes, but at the end of the day this class does just have one, singular responsibility (to search a directory), so it can hardly be called a god class.',''),(266,-2,'I don\'t understand the analysis here at all, honestly; this is a very specific class doing a specific thing, with one instance variable and three methods. It\'s possible the parent class is massive and is a god class, but I can\'t see that here.',''),(267,2,'Long parameter lists can always be avoided with encapsulation at worst or something like a builder if necessary. This is no exception.',''),(268,2,'I believe most of these parameters could be encapsulated in a configuration object.','I disagree with the path here, heavily. I think that a low number of declarative statements is not inherently smelly. I also believe that 8 is far too high of a number to be smelly.'),(269,-2,'method seems simple','none, the decision tree evaluated to wrong node?'),(270,-1,'Similar to the previous god class example, I disagree that this is a god class. This is just a large class that needs refactoring.','The decision tree points to a lack of cohesion as the reason this is classified as a god class. I agree that a lack of cohesion can certainly be smelly, but this class is just an uncohesive mess, not really a god class; it still has one responsibility, it just does it poorly.'),(271,2,'too many lines in class; could use child classes or use utility classes','made the analysis easier; the rule was objective'),(272,-2,'This doesn\'t make a lot of sense again. While there\'s definitely some smelliness here (why not use the `initializeParser` method in the ctor when it\'s literally the same code?), this is not a god class at all.','This must be calculating this class having low cohesion based on its base class, because 100% of this classes methods use 100% of its properties, if you don\'t count the base class.'),(273,-2,'There are literally no parameters in this method, how could it have a long parameter list?','I highly disagree on a comment-to-code ratio being smelly by itself, and especially if it\'s used in the long parameter list classification. Some of the best code I\'ve ever worked in had no comments, and some of the worst code I\'ve ever worked in was commented like crazy (the comments were just out of date).'),(274,-2,'not seems a god class, too small','do not seem applicable'),(275,1,'I agree that this method is too long, and particular this method has a high degree of cyclomatic complexity (something that the decision tree does think about, but didn\'t get to in this case). It\'s doing too much.','I think there are some valid scenarios for long methods that aren\'t necessarily smelly, although they\'re fewer and further between. I think this was a pretty accurate line to follow, even if I don\'t necessarily agree with some of the other paths (comment to code ratio)'),(276,-2,'This seems like a valid use case for inheritance to me. I like the rule of \"is a\" vs \"has a\". QpidRAStreamMessage IS a QpidRAMessage, and QpidRAMessage IS a message.','While I personally prefer composition over inheritance, there are valid use cases for inheritance; this seems like a valid one. I disagree in labeling all inheritance chains as smelly.'),(277,1,'not possible to conclude long param list just looking the number of parameters (7 seems the maximum recommended)','the comment code ratio rule changed my initial perception and pojnted that maybe the param list is really too long and (the params use) not well documented'),(278,-1,'7 seems the maximum allowed; also 3 of them are already classes/objects (not native types) which may indicate that the initial long param list was already refactored (passing the objects instead of their attributes in order to reduce param list)',''),(279,2,'extremely long class; maybe it could be refactored into smaller utility classes (or use some smaller ones)',''),(280,-2,'looks a simple class',''),(281,-2,'no params',''),(282,2,'the method could be refactored into smaller ones; many TODOs may indicate that the method size will increase and it will get harder to read',''),(283,-1,'the children does not seem to be redefining but using as stream (casting to StreamMessage) a declared parent property (message); but most of logging code could be in parent like this (it would reduce the number of lines of both parent and child)\r\n\r\n// declared in parent class\r\nprotected void trace(final String methodName, final String name, final short value) {\r\n	if (_log.isTraceEnabled())\r\n	{\r\n		_log.trace(methodName + \"(\" + name != null ? (name + \", \"):\"\" + value + \")\");\r\n	}\r\n}\r\n\r\n// declared in parent or child\r\nprivate void trace(final String methodName, final short value) {\r\n	trace(methodName, null, value);\r\n}',''),(284,1,'The function calls several decoupled functions that can affect the output, and only the last function actually returns a value. It makes it easy to break this code',''),(285,2,'The class implements 3 interfaces, which means it behaves at least in 3! ways. It also has nearly 900 lines, understandingly there are a lot of comments, it is hard to understand what the class does',''),(286,2,'Este método esta fazendo mais de uma coisa',''),(287,2,'Por mais que centralizar as funcionalidades de um sistema pareça, muitas vezes, ser uma boa solução pra facilitar a manutenção, não é bem assim. Ao fazer isso, o código passa a ficar muito maior, mais suscetível a bugs e tende a ter uma difícil compreensão por parte de terceiros. Sendo assim, centralizar muitas funções com diferentes responsabilidades é uma má prática.',''),(288,2,'146 lines for one method... Depending on the rest of the project, it might be better to extract more methods out of this single one.',''),(289,2,'Comentários desnecessários',''),(290,2,'O código tem muitas condicionas e chama muitos outros métodos, além de invocar outros objetos, oque acaba deixando muita responsabilidade em cima do mesmo método','neste caso o numero de linhas não caracteriza um Bad Smell e sim a quantidade de tarefas atribuídas a ele, logo, neste caso, não foi de MUITA ajuda.'),(291,2,'Um método que deveria apenas retornar verdadeiro ou falso executar outras chamadas dentro dele não é uma prática interessante.',''),(292,-1,'All parameters are being used normally along the method',''),(293,-2,'the comment spacing still annoying',''),(294,2,'O código exibido possui muitos indícios de um bad smell: muitas variáveis temporárias, muitas estruturas de decisão encadeadas, responsabilidades diferentes dentro do mesmo método (search, get)',''),(295,1,'O código apresenta linhas de códigos semelhantes',''),(296,2,'the method is too long, there\'s a few parts that could be split into other methods, also, the \"Try/Catch\" covers the entire method','Lines with source code'),(297,-1,'Simple class. \r\nget, set and a self-Exception methods.',''),(298,1,'Sem dúvida este método tem um lista de parâmetros muito e extensa porém não acredito que, de acordo com o nível de responsabilidade dado a este método, teria como reduzir estes parâmetros','no número de Statements do código'),(299,2,'could\'t find any calls for the Parent class with Ctrl-F',''),(300,2,'Não existe uma regra específica para determinar quantos parâmetros são considerados \"muitos\", mas uma chamada com 7 parâmetros possui vários problemas: \r\nÉ difícil fazer a chamada do método e passar os parâmetros na ordem correta\r\nÉ difícil interpretar o que o método realmente faz (Clean Code)\r\nO método possui parâmetros booleanos',''),(301,2,'I counted 34 methods, some of them for different data manipulation (some for Strings, other for Files).\r\nDefinitely possible to extract some classes from this one.',''),(302,-2,'O código contem poucas linhas e uma tarefa simples para este método, oque não caracteriza um Code Smell','Não ajudou'),(303,2,'A classe filha herda todos os métodos da classe pai, porém muitos deles não estão sendo implementados.',''),(304,-2,'it has > 3 statements, and every single of them are used.','The second layer of the Decision tree.'),(305,-2,'A pesar de ser um Code Smell, não se caracteriza pela quantidade de responsabilidades e sim pela quantidade de comentários de poluem o código, mais atrapalhando que ajudando','Não ajudou'),(306,-1,'Even though the code is extremely lengthy due to the several lines of comments, I haven\'t been able to find any class that concentrates many variables.','The amount of lines in the code.'),(307,2,'Principalmente em relação ao número de linhas do código. Dessa forma, o código realiza muitas operações, deixando-o até um pouco complexo.','Número de linhas e Complexidade ciclomática'),(308,2,'No código em questão, a classe filho não utiliza nenhum método ou atributo da classe pai, portanto não há necessidade de herança.',''),(309,-1,'although the method is composed only by 3 lines of code wich is composed by other methods we, don\'t know the complexity of those, it could be a long method but it doesn\'t seem to be','Lines with source code'),(310,-2,'overall it uses the parent class methods and data','DIT is fewer than 2'),(311,2,'Existem muitas informações na classe. Onde a classe está assumindo mais de uma responsabilidade',''),(312,-2,'A classe possui apenas uma responsabilidade',''),(313,-1,'A classe analisada possui apenas 3 métodos implementados com uma responsabilidade em comum: tratar valor.',''),(314,-1,'Neste caso, a parcela de métodos sobrescritos na classe filho agem como uma interface','Não muito'),(315,1,'The class has a lot of methods only for instance variables, format directories and include/exclude results in the scanned directories.',''),(316,2,'The list of parameters is very long and some of these parameters are used only once, possibiliting the creation of another separate function to use them.','All of the highlighted nodes helped.'),(317,-2,'A classe assumi apenas uma responsabilidade','Neste caso, nem ajuda e nem atrapalha'),(318,2,'great part of the parameters are just giving its values to object\'s attributes,  those parameters should be replaced with the following object','Numbers of declarative lines of code and declative statements'),(319,1,'Além dos citados na descrição, a quantidade de comentários polui o código, atrapalhando na legibilidade','Pouco'),(320,2,'Principalmente a falta do uso de métodos da classe pai.','Não muito.'),(321,2,'Muito código, muitos métodos, muitas variáveis.',''),(322,2,'Um grande número de parâmetros, oque caracteriza uma responsabilidade muito grande dada ao método',''),(323,2,'Is too much complex, has too much line codes and variables.',''),(324,-2,'This class is not complex or is centralizing the system at all.','The lack of methods cohesion. They are coherent and even used by each other.'),(325,-2,'Short and simple method.',''),(326,-2,'This method has only 5 lines with source code and 8 lines with comments.','I ran the tree from the root to a leaf with \"no smelly code\".'),(327,1,'useless comments in the code, to much declarations','following the glossary until the comments section'),(328,-2,'Ao meu ver, o código não apresenta Code Smell',''),(329,1,'Have very if on the code, very extensive paramets','decrease quantity of the ifs'),(330,-2,'Não apresenta Code Smell',''),(331,-2,'Pela seguindo a árvore de decisão, o código está totalmente correto','Ajudou bastante'),(332,-1,'There are some variables in the code that are used only once, but since it\'s a class for tests, seems ok',''),(333,-1,'This class has only 14 lines with source code.','I ran the tree from the root to a leaf with \"no smelly code\".'),(334,2,'Método longo e com muitas responsabilidades',''),(335,1,'good number of lines','good code'),(336,1,'Uma lista de Parâmetros muito grande no método CodeSnippetCompiler',''),(337,-1,'Its simple, only a few lines and straight to the point.',''),(338,2,'Totalmente sem coerência esse alfabeto feito em 26 array','Ajudou bastante'),(339,-2,'Lista grande de responsabilidades para uma só classe',''),(340,-1,'It has a lot of parameters but i think all of them are unavoidable.',''),(341,-1,'very number of parameters, very methods equals names','decreased number of parameters'),(342,2,'The child class uses almost none of the inherited methods.','The depth of inheritance tree.'),(343,-1,'conditions very long on if','small conditions'),(344,-2,'The class has just the necessary methods and no extra variables. Everything fits with its responsibility.',''),(345,2,'huge \"if\" decisions recurrency, TODO comments','again, just following glossary definitions and intuition'),(346,2,'the child class is using only a few methods of the parent class and most of them are just get/set','number of pysical lines'),(347,2,'Big method with a lot of decisions.',''),(348,1,'good code','good code'),(349,2,'eu acredito que esse código apresenta o code smell LONG METHOD, pois no método apresentado, muitas funções que poderiam ser separadas em outros métodos.',''),(350,2,'Todos os métodos respeitam o número de parâmetros dado pela árvore de decisão','Ajudou bastante'),(351,-2,'Simple class with simple boolean methods.',''),(352,1,'Acredito que o problema em si, não seja o uso elevado de parâmetros e sim as declarações excessivas para os parâmetros recebidos, para instanciar outra classe.','não muito'),(353,-2,'The class is cohesive, from the comments it cleary looks like just parse and compile snippets.','the tree didn\'t helped much.'),(354,-1,'The code has a small amount of lines of code and they seem intertwined.','It didn\'t help this time.'),(355,2,'Has only one big method who does everything.',''),(356,-2,'Não acredito que o método é muito longo e nem que tenta fazer muito.','não ajudou em nada, discordo da árvore.'),(357,2,'The code is very lengthy and complex, trying to do many things at once.','The highlighted nodes helped majoritarily, but the other nodes also helped.'),(358,1,'A quantidade de linhas, mesmo não sendo um fator totalmente determinando para o smell de god class, mostra o quanto o código está ruim. Uma classe com 3200 linhas não é algo bom de se fazer (nem mesmo para o dono do código)','Nesse caso, o smell é tão escandaloso, que a árvore de decisão sugere uma forma ineficiente de verificar se é smell ou não: Percent Lack of Cohesion Methods'),(359,-2,'O código esta escrito de forma correta','Ajudou bastante'),(360,1,'The method result is based just on getValue function, but it also run two others functions.',''),(361,-1,'huge class but quite well commented. I guess this is to be expected from a Scanner class...','couldn\'t quite understand the \"Percent Lack of Cohesion in Methods\" metric'),(362,2,'Having a huge class increase immensely the difficulty in code maintenance and debbugin. \r\n\r\nif you have some sort of error in this class you would really have problems solving it because you would not know where it is',''),(363,-2,'this class just evaluate values and return then.',''),(364,2,'Saying this class is lengthy is an absolute understatement. This class is so big and complex and full of methods and if statements that it is simply impossible to say that it couldn\'t be separated in many other classes.',''),(365,2,'Uso elevado de instâncias.','Porcentagem de Falta de Coesão nos Métodos.'),(366,1,'This really code have many parameters...','It was very important and helped to identify the problem of the code.'),(367,-1,'Basically, the class execute the methods that\'s supposed to do.',''),(368,2,'This method is too large, filled with if statements. It surely could be reduced.',''),(369,2,'this class have a lot of if and else statements and tries to do too much',''),(370,-2,'This method doesn\'t even have a parameter list.',''),(371,2,'It doesnt use  the methods and data of the parent.',''),(372,2,'The class does everything just like a code made with structured programming','Lines with source code'),(373,-2,'this method just evaluate a value',''),(374,2,'There\'s almost no use of any method of ConnectionFactoryProperties from child class',''),(375,-2,'O código esta correto','Ajudou bastante'),(376,2,'int seeds, int depth, int threads, int maxPerHost, long topN could have been put inside an object',''),(377,2,'The child class uses almost none of the parent class methods.',''),(378,-2,'It\'s a simple class with a few methods','nothing'),(379,-2,'O código não implementa várias coisas, nem tende a ser complexo.','Discordo da árvore'),(380,2,'The child class has to use more methods and data of his parent class.',''),(381,2,'This method has a huge list of parameters just to return the same method from de parent class passim the same parameters.',''),(382,-2,'The code has a small method with no parameters list.',''),(383,2,'Too much code.','Very useful way to identify godclasses.'),(384,-1,',',''),(385,2,'Nesse caso a classe possuí muito mais funções no sistema do que realmente era necessário(large class) , podendo futuramente gerar um problema de legibilidade para quem for fazer manutenção do código','A árvore me mostrou que basicamente a god class tem muitas linhas e métodos implementados e que basicamente isso se configura um smell'),(386,-2,'The method go straight to the point.',''),(387,-2,'Aparentemente, a classe não possui parâmetros.','A árvore não se adequou ao código em questão, pois direcionou para um caminho onde a justificativa foi linhas de declarative code > 3, mas o código analisado não possui nenhuma'),(388,-2,'the code is simple with a few methods',''),(389,2,'Too much code.','Simple way to identify long methods.'),(390,2,'por ter muitas responsabilidades, a classe passa a ser mais complexa e consequentemente acumula maiores chances de concentrar bugs no sistema, e que são de difícil localização.',''),(391,1,'Acredito que o código possui um número razoável de instâncias, no entanto não possui um grande número de responsabilidades diferentes.',''),(392,-2,'O código em questão não apresenta uma classe complexa, mas sim uma classe simples.',''),(393,1,'Some parameters of the function are used to integrate the returned object, so instead pass all this variables the developer can pass the object.',''),(394,-1,'This class only has many instance variables, but is not centralizing processing or trying to do many things simultaneously.',''),(395,2,'The method is useless, all the parameters are being returned it doesn\'t even make sense like WHY WOULD YOU DO THAT????',''),(396,-2,'The main class must share responsibility with the other classes.','The code is less than 612 lines.'),(397,2,'the class is big and trying to do too much','Percent Lack of Cohesion in Methods helped making my decision'),(398,-2,'this class is fine.','Lines with Source Code helped with my decision'),(399,2,'Possui um elevado número de responsabilidades, além disso, por ser muito longo torna o código bastante complexo.',''),(400,-1,'This method has a long list of parameters but its all used.',''),(401,-2,'Few lines.','Super useful.'),(402,-2,'O código analisado não possui o smell god class, pois seus métodos têm responsabilidades em comum','A árvore de decisão se baseou na quantidade de linhas (num primeiro momento), para julgar o smell, mas o código só possui 66 linhas e a árvore julgou ter mais de 612'),(403,2,'This code have 146 lines with source code.','Walking through the tree, I arrived at a node with \"smelly code\".'),(404,2,'This is a giant class with too much responsibility to handle (some of them are ridiculous)',''),(405,-2,'the method is doing what it is supposed to do','Lines with Source Code and Comment to Code Ratio'),(406,2,'É realmente um \'Long Method\', porque o método está muito grande.Contudo, esse código poderia ter sido dividido em mais métodos.Como por exemplo, um método específico para fazer as verificações.',''),(407,-2,'It doesn\'t even have parameters',''),(408,2,'eu acredite que esse código apresenta o code smell REFUSED BEQUEST, pois a subclasse herda apenas métodos para resgatar variáveis da superclasse, não herdando, portanto, nenhum atributo da superclasse.',''),(409,-1,',','.'),(410,1,'The method do a lot of things that\'s not supposed to do.',''),(411,-1,'Apesar de ter muitas linhas, possui comentários sucintos, facilitando a compreensão do código.',''),(412,-2,'Não se verifica a redefinição de métodos.',''),(413,-2,'Não foram observados muitos métodos herdados que foram redefinidos na subclasse.','.'),(414,2,'There\'s a lot of conditions wrapped in functions, error messages mixed with logical code and everything seems messy.',''),(415,-2,'Declarative Statements is not long','Declarative Statements'),(416,-2,'It says that the smell was classified as GOD CLASS, but I don\'t think that the class is doing several different things. The smell I would classified would be about comments, there is too much comments unecessaraly.','No. The first statement of the decision tree is set wrong, it says that the code doesn\'t have less than 612 lines of source code, but it does.'),(417,2,'some of the paramether could have been passed as objects','Declarative Statements'),(418,1,'The code has more than 265 lines of source code and the DIT is greater than 2.','Walking through the tree, I arrived at a node with \"smelly code\".'),(419,-2,'Não apresenta nenhuma das características mencionadas.',''),(420,-2,'A classe faz algumas implementações e possuí um número razoavel de metodos além de não ter em sua implementação aspectos que classifiquem um god class (large class)','Me ajudou levemente na decisão na questão de smelly'),(421,2,'No construtor da classe observamos uma longa lista de parâmetros, o que classifica a classe com presença do smell descrito.',''),(422,-2,'All parameters are used.','The tree was a good help to find the answer.'),(423,2,'Código complexo, pelo fato de que apresenta uma grande extensão.',''),(424,2,'Além de ter muitos parâmetros, incluindo parâmetros booleanos, ao analisar o retorno da função, pode-se ver que a criação da função não era necessária.','Não há declarative statements no código analisado, algo que a árvore usou para decidir se é um smell ou não'),(425,1,'o método benchmark está recebendo muitos parâmetros, são necessários, porém eles poderiam ser substituídos por uma chamada a um objeto.',''),(426,2,'A classe possui muitos métodos longos e que lidam com uma responsabilidade grande. Isso pode dificultar a manutenção do código e será suscetível a bugs.',''),(427,2,'the child class uses just a few methods from the parent class',''),(428,2,'Apresenta,realmente, um vários parâmetros que poderiam ser condensados em uma classe, para evitar essa extensão dos parâmetros.',''),(429,1,'This class have 892 lines with source code!','walking through the tree, I arrived at a node with \"smelly code\"'),(430,-2,'all the data needed is included on the array list',''),(431,-1,'Possui um elevado número de parâmetros, no entanto, todos os parâmetros estão sendo usados.',''),(432,1,'Have a group of parameters that\r\nnaturally go together - Data Clumps.\r\nHave many temporary variables.','it didn\'t help much'),(433,2,'The amount of switch statement to gather data from numerous classes with different interfaces.','The tree is right but it doesn\'t help me with the analysis.'),(434,-2,'eu acredito que apesar do método apresentado possuir vários parâmetros, não possui alguma forma de evitá-los, e portanto, não considero que esse código possua o code smell LONG PARAMETER LIST.',''),(435,2,'O método é bastante longo e lida com bastante responsabilidade. Possui vários condicionais e muitas variáveis locais.',''),(436,-2,'O método é bastante simples, não possui parâmetros e apenas executa uma ação e retorna um valor. Não encontramos um long method nesta questão.',''),(437,-2,'Few lines of source code.',''),(438,-1,'The DIT is only 1.','Ive based my decision on the tree, very useful.'),(439,2,'o método é muito longo e está fazendo mais do que devia. No try a \"get module descriptor\" e a \"search for the dependency\" poderiam ser substituidas por consultas a métodos.',''),(440,2,'Many conditionals','Cyclomatic Complexity > 16'),(441,-2,'Não apresenta o smell sugerido','Ajudou, já que fez com que pudesse ser visto a ausência das condições que a tornariam um smell.'),(442,-2,'The DIT is only 1 and according to the tree it must be greater than 2 to be smelly.','The tree was essential to find the answer.'),(443,2,'Apesar de herdar da classe pai, a classe filho não utiliza quase nenhum dos métodos do pai.',''),(444,2,'There\'s too much methods, some of them with a lot of switch cases, ifs and \"elses\" that are too big.','The metric about lines'),(445,2,'A classe filha herda apenas 1 método da classe pai','A árvore tomou a decisão errada ao julgar a DIT < 2 = False, visto que, no caso analisado, a DIT = 1;'),(446,-2,'A sublcasse não redefine a maioria dos métodos herdados da classe pai.',''),(447,2,'This code have 3252 lines of source code.',''),(448,2,'It also could be classified as a GOD CLASS.','The first statement says that the code has less than 265 physical lines, but it is not. Thus, the tree didn\'t help in this case.'),(449,-2,'Não acredito que possui uma lista longa de parâmetros',''),(450,-2,'Não apresenta um longos parâmetros.','Não ajudou . pois não tinha relação com o smell citado.'),(451,-2,'A classe não lida com grandes responsabilidades, só possui alguns métodos para realização de ações específicas.',''),(452,-2,'It has less than 3 lines of declarative code.','Ive based my decision on the tree.'),(453,2,'Apresenta muitos parâmetros','Não ajudou, porque não tem relação com o smell citado.'),(454,2,'Many functions (duties) in the main class','Lines with Source Code > 621'),(455,-2,'eu acredito que esse código não apresenta o code smell LONG METHOD, pois esse método não apresentar um grande número de funcionalidades.',''),(456,2,'O código é enorme, está lidando com várias responsabilidades diferentes,  desde remove, add até a realização de buscas no sistema. A classe possui muitos métodos que poderiam ser alocados em outras classes.',''),(457,1,'The \"try\" block has some conditions chains that can make the code difficult to read.','The metric about the lines with source code'),(458,2,'Apresenta o smell citado','Não ajudou, porque não tinha relação com o smell citado.'),(459,-2,'A subclasse não redefine muitos métodos da classe pai.','A profundidade árvore de herança não condiz  com um smelly code'),(460,-2,'This code has no smell.','The decision tree says that the code has less than 61 lines and the says that has less than 71. It is confusing, not helpful.'),(461,-2,'Não é uma god class','Não ajudou, porque não tinha relação com o smell.'),(462,2,'O método lida com muitas responsabilidades ao mesmo tempo. Possui vários condicionais para lidar com múltiplas escolhas.','Ajudou, pois a partir da quantidade de linhas do código fonte, podemos concluir que o método está lidando com muita coisa ao mesmo tempo.'),(463,-2,'The method has no parameters.','Very easy way to identify the smell.'),(464,1,'The superclass only has one child','it didn\'t help much'),(465,2,'Apresenta todas as condições que faz com que seja uma god class','Ajudou,porque as condições mostraram que realmente era uma god class'),(466,2,'Yes, the class is doing too much indeed.','Also, could say that there is A LOT of comments.'),(467,-2,'According to the decision tree, a code isnt a GOD CLASS if has less than 612 line codes.','The decision tree helps me.'),(468,2,'Apesar das responsabilidades serem semelhantes, o método está realizando muitas tarefas, com muitas estruturas de decisão encadeadas e variáveis recebendo null, além de muitas declarações de variáveis temporárias.','A árvore levou em consideração apenas a quantidade de linhas para definir o smell'),(469,1,'The method has some chained \"try/catch\" blocks.','The metrics give me some highlights about where I need to look to search for the smells.'),(470,2,'The code is a GOD CLASS because has more than 612 line codes.','The decision tree.'),(471,1,'The classification is right, but I can\'t see how we could reduce the number os parameters.','The tree is right and helpfull.'),(472,2,'Has too much parameters, and some parameters are not used.','.'),(473,2,'A classe herda os métodos e variáveis da classe pai, mas usa alguns poucos métodos, e apenas no método toString',''),(474,1,'Has too many code lines, can be coded with less.','.'),(475,-1,'I would say the the java code should be classified as Duplicated Code. The part \"_log.trace(\"writeChar(\" + value + \")\");\"',''),(476,2,'The number of try/catch could be condensed.',''),(477,2,'blockSize and bufferSize could be only one parameter like size, and then specify the types of sizes.',''),(478,2,'The method doing way too much.',''),(479,2,'The class diverges with what it is doing.',''),(480,2,'the class is way too complex, indeed.',''),(481,1,'É possível criar um outro método para pegar o \"module descriptor\" e outro para procurar a dependência no cache, deixando o método principal mais enxuto.',''),(482,1,'O método faz mais do que a descrição diz que ele faz.',''),(483,-2,'A classe cuida apenas de uma única condição',''),(484,2,'v','m'),(485,2,'The child class seems to use none of the methods of first class.','Depth of Inheritance Tree (DIT)'),(486,1,'It\'s really a long parameter list, but since the method is small, don\'t look like a big deal.','Number of declarative Lines of Code and Declarative Statements'),(487,-2,'All the methods are concise and the class serves for one responsibility only.','None'),(488,1,'The length and complexity of this method bothered me a little. In particular, I have noticed two commented code blocks (starting at lines 29 and 54) that could be extracted to new methods.','This decision tree gave me the impression of ignoring complexity when deciding on the method\'s smelliness. Particularly, I disagree with that, because some long methods are not smelly at all. They may be long and, still, easy to read and understand.'),(489,-2,'This method is just as short/simple as a method can be.','I suppose this is a catch, because the decision tree does not match the code I have analyzed.'),(490,2,'I did not see most of the parent class\' methods (e.g. setUseLocalTx and isUseLocalTx) being used in the child class. Thus, I would say that extending ConnectionFactoryProperties with QpidActivationSpec was unnecessary.','Honestly, I found this particular decision tree useless.'),(491,2,'Besides being too large, this class seems one of those all-in-one classes. Data is managed, processed, and verified, all in a single class.','The lack of cohesion in methods is something I would not be able to compute visually. Thus, the decision tree was handy.'),(492,1,'I am not a fan of this code smell type, but I was convinced by the decision tree that the parameter list could be shortened.','The attempt to characterize the nature of method (via statements and inputs) was quite helpful to understand that the parameter list deserves a re-design.'),(493,-2,'Is this another trap? This class is short as hell and too simple to be a God Class.','Okay. I think I misunderstood the use of the decision tree to some extent. For some reason, I thought the highlighted path reflected the decision taken by the machine learning technique for stating that the code sample under analysis was smelly. However, now I got the understanding that the highlighted path is just a way of spotting the path that leads to a smelly code (which may or may not match the code sample under analysis). In this case, I would say the decision tree added little to the smelliness analysis.'),(494,-1,'Although I seems like some parameters (overwrite, bufferSize, and blockSize) are part of the same code unit (so, they could compose a single data object), this parameter list did not worry.',''),(495,-1,'I got a feeling that certain code parts (e.g. the code blocks in lines 34, 39, 42) repeat all over the method. It may be the case of extracting new methods, so that the code becomes clearer and less polluted.',''),(496,-2,'Besides being short and clear, this class seems to have a pretty clear purpose (i.e., to compile code snippets). Thus, I would not say that this class has a poor design or recommend spliting it into many.',''),(497,2,'Besides overriding a few methods of its parent class, the child class makes no use of too many parent methods (e.g., oversetObjectProperty, setShortProperty, and setStringProperty).',''),(498,2,'This is class is definitely too large and realizes too many responsibilities. Let us that the scanIdentifierOrKeyword and toString methods as examples. Besides targeting different concerns, both methods have class-level proportions!',''),(499,-2,'As far as I understand, the method has no parameters.','');
/*!40000 ALTER TABLE `ms_answerTaskID` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Dumping data for table `ms_dtModel`
--

LOCK TABLES `ms_dtModel` WRITE;
/*!40000 ALTER TABLE `ms_dtModel` DISABLE KEYS */;
INSERT INTO `ms_dtModel` VALUES (1,'dt3.png',2,3,'CountLineCode,PercentLackOfCohesion'),(2,'dt5.png',2,3,'CountLine,MaxInheritanceTree'),(4,'dt4.png',3,6,'CountLineCode,CountLineComment,Cyclomatic,RatioCommentToCode'),(5,'dt11.png',5,6,'CountInput,CountLineCodeDecl,CountStmtDecl,RatioCommentToCode'),(7,'dt8.png',2,3,'CountLineCode,PercentLackOfCohesion'),(8,'dt6.png',3,6,'CountLineCode,CountLineComment,Cyclomatic,RatioCommentToCode'),(9,'dt12.png',3,4,'CountInput,CountLineCodeDecl,CountStmtDecl,RatioCommentToCode'),(10,'dt7.png',2,3,'CountLine,MaxInheritanceTree');
/*!40000 ALTER TABLE `ms_dtModel` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Dumping data for table `ms_inviteControl`
--

LOCK TABLES `ms_inviteControl` WRITE;
/*!40000 ALTER TABLE `ms_inviteControl` DISABLE KEYS */;
/*!40000 ALTER TABLE `ms_inviteControl` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Dumping data for table `ms_latinSquare`
--

LOCK TABLES `ms_latinSquare` WRITE;
/*!40000 ALTER TABLE `ms_latinSquare` DISABLE KEYS */;
INSERT INTO `ms_latinSquare` VALUES (10,'3,11,7,4,14,13','15,8,12,16,6,5','0903fe3e42','a4b779d318'),(11,'14,3,4,11,13,7','5,12,8,15,16,6','a0dd7a3994','664df040ea'),(13,'14,7,4,3,11,13','12,8,15,16,5,6','902c0c14b5','1a97f9485c'),(14,'14,11,4,7,13,3','8,6,15,12,5,16','96c5de2c36','4bba6e8d73'),(15,'4,14,3,7,11,13','5,8,6,16,12,15','6e9cac4bf1','98ade17f7a'),(16,'13,11,4,3,7,14','8,16,6,5,12,15','d5b0e1db01','2eb53d5a3b'),(18,'4,7,11,14,3,13','8,5,6,12,16,15','bf322c7997','a4fdb1f70d'),(20,'4,14,7,3,11,13','12,6,16,5,8,15','3b27dce60f','a4d316213a'),(21,'4,7,14,3,13,11','12,8,16,15,6,5','3e86e694d5','396e223081'),(23,'3,14,4,11,7,13','8,15,16,12,5,6',NULL,'9247fa543f'),(24,'4,14,11,7,3,13','16,12,8,15,5,6','daaa615ee5','5793c0e432'),(25,'4,11,14,13,7,3','12,5,15,6,16,8','60047cd9d5','0ff9dc16b9'),(26,'3,11,13,7,14,4','8,6,15,5,12,16','037817b100','037667ebe6'),(27,'4,7,11,14,3,13','16,8,6,12,5,15','f040190ed3','0b59bfcf57'),(28,'13,14,7,4,3,11','5,16,15,6,12,8',NULL,'557577f31a'),(29,'13,11,4,7,3,14','8,5,16,6,15,12',NULL,'0d8948f831'),(30,'3,14,11,4,13,7','8,6,16,5,12,15','3d9f8e8946','ee2546ee15'),(31,'7,14,3,11,4,13','16,8,5,12,6,15','c7b28428c4','a6d8907a2a'),(32,'3,13,4,7,14,11','12,5,16,8,15,6','257658e6e1','1c4dbe7e05'),(33,'14,13,11,4,7,3','16,8,5,6,15,12','400198f37e','68dd7e56ce'),(34,'3,13,4,14,11,7','8,16,6,5,15,12','1a682ecfdd','aadeab9473'),(35,'13,11,4,3,7,14','15,16,6,5,12,8','f50bcce226','e7841e4fed'),(36,'7,4,14,13,3,11','16,12,15,8,5,6','e000dac3aa','1afa419261'),(37,'13,4,7,14,3,11','5,15,12,6,16,8','1773411064','39a8d13e23'),(38,'11,3,4,14,7,13','5,6,15,12,8,16','197589b2af','10c01d5806'),(39,'11,4,3,13,14,7','6,16,15,8,12,5','e881a7349e','fec6a8a309');
/*!40000 ALTER TABLE `ms_latinSquare` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Dumping data for table `ms_participant`
--

LOCK TABLES `ms_participant` WRITE;
/*!40000 ALTER TABLE `ms_participant` DISABLE KEYS */;
INSERT INTO `ms_participant` VALUES ('00ed9af0c7',1,1,'N',2,2,2,'A',1),('037667ebe6',2,2,'N',2,2,2,'A',2),('037817b100',0,0,'N',2,1,2,'A',0),('0903fe3e42',2,1,'B',2,3,2,'A',2),('0b59bfcf57',0,0,'N',2,2,2,'A',2),('0d8948f831',1,1,'N',2,2,2,'A',0),('0f2f682d31',2,2,'M',3,3,3,'B',10),('0ff9dc16b9',0,1,'N',2,1,1,'A',2),('10c01d5806',1,1,'B',2,3,2,'A',2),('1773411064',2,1,'B',2,0,1,'A',2),('197589b2af',1,4,'M',3,3,4,'B',80),('1a682ecfdd',1,1,'B',1,1,1,'A',0),('1a97f9485c',2,2,'B',3,3,3,'A',7),('1afa419261',1,0,'B',2,3,3,'A',0),('1c4dbe7e05',1,0,'N',2,2,1,'A',1),('252d52fc64',4,3,'B',4,3,4,'B',4),('257658e6e1',0,0,'N',2,2,2,'A',1),('2d036fe34f',3,0,'N',3,3,4,'B',10),('2d2ee34bd2',2,2,'B',3,3,3,'A',2),('2eb53d5a3b',2,3,'B',4,4,4,'B',3),('357d181b45',3,4,'B',1,3,4,'A',2),('35fb2aa767',3,2,'B',3,0,3,'I',7),('37c4ee3c18',3,0,'M',2,2,2,'B',0),('389f6fcf7c',3,3,'N',3,1,3,'I',3),('396e223081',3,3,'M',4,2,3,'I',8),('39a8d13e23',1,1,'B',2,3,2,'A',2),('3b27dce60f',1,3,'M',2,2,2,'A',5),('3cb91b9d3e',3,3,'M',4,4,4,'B',15),('3d9f8e8946',2,1,'B',2,2,2,'A',2),('3e86e694d5',3,3,'M',4,4,4,'B',15),('400198f37e',0,0,'N',2,2,2,'A',1),('4bba6e8d73',3,2,'B',3,3,3,'B',6),('4c9bd69580',3,4,'P',3,3,3,'A',8),('540e25dd7d',4,3,'M',4,4,4,'B',5),('557577f31a',1,1,'N',2,2,1,'A',2),('5793c0e432',1,0,'B',2,1,1,'A',2),('5865e8e427',3,2,'M',3,1,2,'I',18),('60047cd9d5',1,0,'B',3,1,3,'A',3),('60901302a5',3,3,'B',3,2,3,'A',5),('6136e5c273',3,3,'M',3,4,4,'A',4),('664df040ea',3,2,'B',3,3,3,'A',5),('68dd7e56ce',3,2,'B',2,2,3,'A',2),('6d61662d7e',2,3,'P',2,4,3,'B',0),('6e9cac4bf1',2,3,'M',3,3,3,'B',9),('76f0bb995f',4,3,'M',4,4,4,'B',5),('76f616c7f1',0,0,'B',1,1,1,'A',4),('8e2db3cebb',4,3,'M',4,4,4,'B',5),('902c0c14b5',2,2,'M',3,3,3,'B',5),('9247fa543f',1,0,'N',2,0,2,'A',1),('9423b3427c',3,3,'M',3,3,3,'B',10),('96c5de2c36',3,2,'P',3,3,3,'B',4),('97c0c0b97b',0,0,'N',2,2,2,'A',1),('98ade17f7a',2,2,'P',4,3,3,'A',10),('9b7cfa55fb',1,1,'N',2,2,2,'A',1),('9c64a54c89',3,3,'N',3,1,3,'I',8),('a0dd7a3994',2,2,'B',3,3,3,'A',2),('a4b779d318',1,1,'B',1,1,1,'A',0),('a4d316213a',0,0,'M',1,2,2,'A',1),('a4fdb1f70d',3,3,'B',3,3,3,'A',5),('a6d8907a2a',0,0,'N',2,2,2,'A',1),('aadeab9473',3,2,'B',3,2,2,'A',1),('bf322c7997',4,3,'P',3,2,3,'B',20),('c0a7182d77',3,2,'M',3,3,3,'A',6),('c42afd2e7a',3,3,'B',3,3,3,'B',12),('c7b28428c4',1,1,'N',2,2,1,'A',1),('c94ac3d0bf',1,1,'B',2,2,2,'A',1),('cdaeb2a763',2,2,'P',3,2,3,'B',8),('d5b0e1db01',3,4,'M',4,4,4,'A',20),('daaa615ee5',2,2,'N',2,1,2,'A',0),('dc6781d343',2,2,'B',3,1,3,'B',4),('e000dac3aa',1,1,'B',2,3,2,'A',2),('e7841e4fed',2,2,'N',2,2,2,'A',0),('e881a7349e',2,3,'B',3,3,3,'B',2),('ec73c54f3c',0,0,'B',0,0,0,'I',3),('ee2546ee15',0,0,'N',0,0,0,'A',3),('effbca811c',3,4,'B',1,3,4,'A',2),('f040190ed3',2,1,'N',2,2,2,'A',1),('f3fa9a7261',4,4,'N',4,0,4,'I',15),('f4ad4e4347',2,2,'M',3,4,3,'A',10),('f50bcce226',0,0,'B',2,1,2,'A',1),('fec6a8a309',2,2,'B',3,3,3,'B',2);
/*!40000 ALTER TABLE `ms_participant` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Dumping data for table `ms_questionnaire`
--

LOCK TABLES `ms_questionnaire` WRITE;
/*!40000 ALTER TABLE `ms_questionnaire` DISABLE KEYS */;
INSERT INTO `ms_questionnaire` VALUES (15,'2020-01-10 15:32:54.844801',NULL,'2d2ee34bd2'),(16,'2020-01-10 15:53:00.525442','2020-01-10 16:18:59.338721','0903fe3e42'),(17,'2020-01-10 16:08:41.932995','2020-01-10 16:54:30.644442','664df040ea'),(18,'2020-01-10 17:08:56.964156','2020-01-10 17:36:19.488927','a0dd7a3994'),(19,'2020-01-10 17:37:37.823894',NULL,'effbca811c'),(20,'2020-01-10 17:37:46.999814',NULL,'357d181b45'),(21,'2020-01-11 01:03:06.499981','2020-01-11 02:33:50.853543','1a97f9485c'),(22,'2020-01-13 16:46:17.188964','2020-01-13 17:28:35.869068','902c0c14b5'),(23,'2020-01-13 17:11:56.616914','2020-01-13 18:21:11.332411','96c5de2c36'),(24,'2020-01-13 18:46:57.227572','2020-01-13 20:22:21.149934','4bba6e8d73'),(25,'2020-01-14 20:12:57.103083','2020-01-14 20:39:47.512768','98ade17f7a'),(26,'2020-01-15 01:33:31.930647','2020-01-15 02:02:57.272333','6e9cac4bf1'),(27,'2020-01-15 02:40:06.339793',NULL,'6136e5c273'),(28,'2020-01-15 12:50:19.202769','2020-01-15 15:39:51.079722','2eb53d5a3b'),(29,'2020-01-15 19:26:44.020188',NULL,'8e2db3cebb'),(30,'2020-01-16 00:12:39.388241',NULL,'540e25dd7d'),(31,'2020-01-16 15:25:35.140770','2020-01-16 16:06:36.569651','bf322c7997'),(32,'2020-01-17 12:34:44.253719','2020-01-17 13:32:57.528752','a4fdb1f70d'),(33,'2020-01-17 12:56:05.684469',NULL,'c42afd2e7a'),(35,'2020-01-17 19:26:15.333054',NULL,'252d52fc64'),(36,'2020-01-17 21:53:51.036508','2020-01-17 22:06:24.795525','a4d316213a'),(37,'2020-01-21 17:43:15.875347',NULL,'76f0bb995f'),(38,'2020-01-23 21:50:42.536195',NULL,'5865e8e427'),(39,'2020-01-23 22:36:37.364764',NULL,'37c4ee3c18'),(40,'2020-01-23 22:57:29.672708',NULL,'3cb91b9d3e'),(41,'2020-01-23 23:11:53.656918','2020-01-24 00:49:22.028161','3e86e694d5'),(42,'2020-01-23 23:35:59.738236','2020-01-24 00:21:11.592785','396e223081'),(43,'2020-01-24 12:26:23.261262',NULL,'60901302a5'),(44,'2020-01-24 14:35:27.270875',NULL,'dc6781d343'),(45,'2020-01-24 17:17:55.356558',NULL,'cdaeb2a763'),(46,'2020-01-24 17:48:15.864799',NULL,'9423b3427c'),(47,'2020-01-24 22:23:08.102924',NULL,'4c9bd69580'),(48,'2020-01-25 06:04:22.036634',NULL,'2d036fe34f'),(49,'2020-01-25 12:10:37.681390','2020-01-25 13:55:32.154442','9247fa543f'),(50,'2020-01-25 12:11:55.511846','2020-01-25 13:27:02.066057','5793c0e432'),(51,'2020-01-25 12:13:00.228725','2020-01-25 13:43:27.321039','daaa615ee5'),(52,'2020-01-25 12:13:46.973454','2020-01-25 13:20:37.013956','0ff9dc16b9'),(53,'2020-01-25 12:14:00.214694','2020-01-25 13:09:25.225777','60047cd9d5'),(54,'2020-01-25 12:17:38.796463','2020-01-25 13:32:03.257559','037817b100'),(55,'2020-01-25 12:21:07.278386','2020-01-25 15:02:22.231431','037667ebe6'),(56,'2020-01-25 12:29:53.296947',NULL,'0b59bfcf57'),(57,'2020-01-25 12:38:15.546663','2020-01-25 13:49:47.633661','f040190ed3'),(58,'2020-01-25 12:39:57.008801',NULL,'00ed9af0c7'),(59,'2020-01-25 12:44:26.424926',NULL,'557577f31a'),(60,'2020-01-25 12:49:01.595155',NULL,'0d8948f831'),(61,'2020-01-25 12:49:27.241222',NULL,'9b7cfa55fb'),(62,'2020-01-25 12:49:41.075137',NULL,'3d9f8e8946'),(63,'2020-01-25 12:51:12.151820','2020-01-25 13:54:43.746327','ee2546ee15'),(65,'2020-01-25 12:51:56.490491',NULL,'c7b28428c4'),(66,'2020-01-25 12:55:09.979415',NULL,'a6d8907a2a'),(68,'2020-01-25 12:55:31.890455','2020-01-25 14:01:56.480845','1c4dbe7e05'),(69,'2020-01-25 12:55:36.138672',NULL,'257658e6e1'),(71,'2020-01-25 12:56:24.145098',NULL,'400198f37e'),(72,'2020-01-25 13:08:26.318398',NULL,'68dd7e56ce'),(73,'2020-01-25 13:08:51.749037',NULL,'1a682ecfdd'),(74,'2020-01-25 13:14:06.207261','2020-01-25 13:38:53.146027','aadeab9473'),(75,'2020-01-25 13:20:19.391134',NULL,'e7841e4fed'),(76,'2020-01-25 13:20:53.366152',NULL,'f50bcce226'),(77,'2020-01-25 13:23:27.891957',NULL,'1afa419261'),(78,'2020-01-25 13:24:45.957236',NULL,'e000dac3aa'),(79,'2020-01-25 13:26:02.081177','2020-01-25 14:15:30.424915','1773411064'),(80,'2020-01-25 13:26:20.069146','2020-01-25 13:54:45.905109','39a8d13e23'),(81,'2020-01-25 13:38:52.738071',NULL,'10c01d5806'),(82,'2020-01-25 14:47:46.912751',NULL,'197589b2af'),(83,'2020-01-25 14:55:13.728921',NULL,'e881a7349e'),(86,'2020-01-25 18:52:16.348214',NULL,'fec6a8a309'),(87,'2020-01-25 23:07:48.605540',NULL,'a4b779d318'),(88,'2020-01-28 02:21:28.066446',NULL,'d5b0e1db01'),(89,'2020-02-01 11:20:56.015298','2020-02-01 12:33:08.749442','3b27dce60f');
/*!40000 ALTER TABLE `ms_questionnaire` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Dumping data for table `ms_task`
--

LOCK TABLES `ms_task` WRITE;
/*!40000 ALTER TABLE `ms_task` DISABLE KEYS */;
INSERT INTO `ms_task` VALUES (3,'C','gc','/*\r\n *  Licensed to the Apache Software Foundation (ASF) under one or more\r\n *  contributor license agreements.  See the NOTICE file distributed with\r\n *  this work for additional information regarding copyright ownership.\r\n *  The ASF licenses this file to You under the Apache License, Version 2.0\r\n *  (the \"License\"); you may not use this file except in compliance with\r\n *  the License.  You may obtain a copy of the License at\r\n *\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n *  Unless required by applicable law or agreed to in writing, software\r\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\r\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n *  See the License for the specific language governing permissions and\r\n *  limitations under the License.\r\n *\r\n */\r\n\r\npackage org.apache.tools.ant;\r\n\r\nimport java.io.File;\r\nimport java.io.IOException;\r\nimport java.util.ArrayList;\r\nimport java.util.Arrays;\r\nimport java.util.HashMap;\r\nimport java.util.HashSet;\r\nimport java.util.Iterator;\r\nimport java.util.LinkedList;\r\nimport java.util.Map;\r\nimport java.util.Set;\r\nimport java.util.Vector;\r\n\r\nimport org.apache.tools.ant.taskdefs.condition.Os;\r\nimport org.apache.tools.ant.types.Resource;\r\nimport org.apache.tools.ant.types.ResourceFactory;\r\nimport org.apache.tools.ant.types.resources.FileResource;\r\nimport org.apache.tools.ant.types.selectors.FileSelector;\r\nimport org.apache.tools.ant.types.selectors.SelectorScanner;\r\nimport org.apache.tools.ant.types.selectors.SelectorUtils;\r\nimport org.apache.tools.ant.types.selectors.TokenizedPath;\r\nimport org.apache.tools.ant.types.selectors.TokenizedPattern;\r\nimport org.apache.tools.ant.util.CollectionUtils;\r\nimport org.apache.tools.ant.util.FileUtils;\r\nimport org.apache.tools.ant.util.SymbolicLinkUtils;\r\nimport org.apache.tools.ant.util.VectorSet;\r\n\r\n/**\r\n * Class for scanning a directory for files/directories which match certain\r\n * criteria.\r\n * <p>\r\n * These criteria consist of selectors and patterns which have been specified.\r\n * With the selectors you can select which files you want to have included.\r\n * Files which are not selected are excluded. With patterns you can include\r\n * or exclude files based on their filename.\r\n * <p>\r\n * The idea is simple. A given directory is recursively scanned for all files\r\n * and directories. Each file/directory is matched against a set of selectors,\r\n * including special support for matching against filenames with include and\r\n * and exclude patterns. Only files/directories which match at least one\r\n * pattern of the include pattern list or other file selector, and don\'t match\r\n * any pattern of the exclude pattern list or fail to match against a required\r\n * selector will be placed in the list of files/directories found.\r\n * <p>\r\n * When no list of include patterns is supplied, \"**\" will be used, which\r\n * means that everything will be matched. When no list of exclude patterns is\r\n * supplied, an empty list is used, such that nothing will be excluded. When\r\n * no selectors are supplied, none are applied.\r\n * <p>\r\n * The filename pattern matching is done as follows:\r\n * The name to be matched is split up in path segments. A path segment is the\r\n * name of a directory or file, which is bounded by\r\n * <code>File.separator</code> (\'/\' under UNIX, \'\\\' under Windows).\r\n * For example, \"abc/def/ghi/xyz.java\" is split up in the segments \"abc\",\r\n * \"def\",\"ghi\" and \"xyz.java\".\r\n * The same is done for the pattern against which should be matched.\r\n * <p>\r\n * The segments of the name and the pattern are then matched against each\r\n * other. When \'**\' is used for a path segment in the pattern, it matches\r\n * zero or more path segments of the name.\r\n * <p>\r\n * There is a special case regarding the use of <code>File.separator</code>s\r\n * at the beginning of the pattern and the string to match:<br>\r\n * When a pattern starts with a <code>File.separator</code>, the string\r\n * to match must also start with a <code>File.separator</code>.\r\n * When a pattern does not start with a <code>File.separator</code>, the\r\n * string to match may not start with a <code>File.separator</code>.\r\n * When one of these rules is not obeyed, the string will not\r\n * match.\r\n * <p>\r\n * When a name path segment is matched against a pattern path segment, the\r\n * following special characters can be used:<br>\r\n * \'*\' matches zero or more characters<br>\r\n * \'?\' matches one character.\r\n * <p>\r\n * Examples:\r\n * <p>\r\n * \"**\\*.class\" matches all .class files/dirs in a directory tree.\r\n * <p>\r\n * \"test\\a??.java\" matches all files/dirs which start with an \'a\', then two\r\n * more characters and then \".java\", in a directory called test.\r\n * <p>\r\n * \"**\" matches everything in a directory tree.\r\n * <p>\r\n * \"**\\test\\**\\XYZ*\" matches all files/dirs which start with \"XYZ\" and where\r\n * there is a parent directory called test (e.g. \"abc\\test\\def\\ghi\\XYZ123\").\r\n * <p>\r\n * Case sensitivity may be turned off if necessary. By default, it is\r\n * turned on.\r\n * <p>\r\n * Example of usage:\r\n * <pre>\r\n *   String[] includes = {\"**\\\\*.class\"};\r\n *   String[] excludes = {\"modules\\\\*\\\\**\"};\r\n *   ds.setIncludes(includes);\r\n *   ds.setExcludes(excludes);\r\n *   ds.setBasedir(new File(\"test\"));\r\n *   ds.setCaseSensitive(true);\r\n *   ds.scan();\r\n *\r\n *   System.out.println(\"FILES:\");\r\n *   String[] files = ds.getIncludedFiles();\r\n *   for (int i = 0; i < files.length; i++) {\r\n *     System.out.println(files[i]);\r\n *   }\r\n * </pre>\r\n * This will scan a directory called test for .class files, but excludes all\r\n * files in all proper subdirectories of a directory called \"modules\"\r\n *\r\n */\r\npublic class DirectoryScanner\r\n       implements FileScanner, SelectorScanner, ResourceFactory {\r\n\r\n    /** Is OpenVMS the operating system we\'re running on? */\r\n    private static final boolean ON_VMS = Os.isFamily(\"openvms\");\r\n\r\n    /**\r\n     * Patterns which should be excluded by default.\r\n     *\r\n     * <p>Note that you can now add patterns to the list of default\r\n     * excludes.  Added patterns will not become part of this array\r\n     * that has only been kept around for backwards compatibility\r\n     * reasons.</p>\r\n     *\r\n     * @deprecated since 1.6.x.\r\n     *             Use the {@link #getDefaultExcludes getDefaultExcludes}\r\n     *             method instead.\r\n     */\r\n    protected static final String[] DEFAULTEXCLUDES = {\r\n        // Miscellaneous typical temporary files\r\n        SelectorUtils.DEEP_TREE_MATCH + \"/*~\",\r\n        SelectorUtils.DEEP_TREE_MATCH + \"/#*#\",\r\n        SelectorUtils.DEEP_TREE_MATCH + \"/.#*\",\r\n        SelectorUtils.DEEP_TREE_MATCH + \"/%*%\",\r\n        SelectorUtils.DEEP_TREE_MATCH + \"/._*\",\r\n\r\n        // CVS\r\n        SelectorUtils.DEEP_TREE_MATCH + \"/CVS\",\r\n        SelectorUtils.DEEP_TREE_MATCH + \"/CVS/\" + SelectorUtils.DEEP_TREE_MATCH,\r\n        SelectorUtils.DEEP_TREE_MATCH + \"/.cvsignore\",\r\n\r\n        // SCCS\r\n        SelectorUtils.DEEP_TREE_MATCH + \"/SCCS\",\r\n        SelectorUtils.DEEP_TREE_MATCH + \"/SCCS/\" + SelectorUtils.DEEP_TREE_MATCH,\r\n\r\n        // Visual SourceSafe\r\n        SelectorUtils.DEEP_TREE_MATCH + \"/vssver.scc\",\r\n\r\n        // Subversion\r\n        SelectorUtils.DEEP_TREE_MATCH + \"/.svn\",\r\n        SelectorUtils.DEEP_TREE_MATCH + \"/.svn/\" + SelectorUtils.DEEP_TREE_MATCH,\r\n\r\n        // Git\r\n        SelectorUtils.DEEP_TREE_MATCH + \"/.git\",\r\n        SelectorUtils.DEEP_TREE_MATCH + \"/.git/\" + SelectorUtils.DEEP_TREE_MATCH,\r\n        SelectorUtils.DEEP_TREE_MATCH + \"/.gitattributes\",\r\n        SelectorUtils.DEEP_TREE_MATCH + \"/.gitignore\",\r\n        SelectorUtils.DEEP_TREE_MATCH + \"/.gitmodules\",\r\n\r\n        // Mercurial\r\n        SelectorUtils.DEEP_TREE_MATCH + \"/.hg\",\r\n        SelectorUtils.DEEP_TREE_MATCH + \"/.hg/\" + SelectorUtils.DEEP_TREE_MATCH,\r\n        SelectorUtils.DEEP_TREE_MATCH + \"/.hgignore\",\r\n        SelectorUtils.DEEP_TREE_MATCH + \"/.hgsub\",\r\n        SelectorUtils.DEEP_TREE_MATCH + \"/.hgsubstate\",\r\n        SelectorUtils.DEEP_TREE_MATCH + \"/.hgtags\",\r\n\r\n        // Bazaar\r\n        SelectorUtils.DEEP_TREE_MATCH + \"/.bzr\",\r\n        SelectorUtils.DEEP_TREE_MATCH + \"/.bzr/\" + SelectorUtils.DEEP_TREE_MATCH,\r\n        SelectorUtils.DEEP_TREE_MATCH + \"/.bzrignore\",\r\n\r\n        // Mac\r\n        SelectorUtils.DEEP_TREE_MATCH + \"/.DS_Store\"\r\n    };\r\n\r\n    /**\r\n     * default value for {@link #maxLevelsOfSymlinks maxLevelsOfSymlinks}\r\n     * @since Ant 1.8.0\r\n     */\r\n    public static final int MAX_LEVELS_OF_SYMLINKS = 5;\r\n    /**\r\n     * The end of the exception message if something that should be\r\n     * there doesn\'t exist.\r\n     */\r\n    public static final String DOES_NOT_EXIST_POSTFIX = \" does not exist.\";\r\n\r\n    /** Helper. */\r\n    private static final FileUtils FILE_UTILS = FileUtils.getFileUtils();\r\n\r\n    /** Helper. */\r\n    private static final SymbolicLinkUtils SYMLINK_UTILS =\r\n        SymbolicLinkUtils.getSymbolicLinkUtils();\r\n\r\n    /**\r\n     * Patterns which should be excluded by default.\r\n     *\r\n     * @see #addDefaultExcludes()\r\n     */\r\n    private static final Set defaultExcludes = new HashSet();\r\n    static {\r\n        resetDefaultExcludes();\r\n    }\r\n\r\n    // CheckStyle:VisibilityModifier OFF - bc\r\n\r\n    /** The base directory to be scanned. */\r\n    protected File basedir;\r\n\r\n    /** The patterns for the files to be included. */\r\n    protected String[] includes;\r\n\r\n    /** The patterns for the files to be excluded. */\r\n    protected String[] excludes;\r\n\r\n    /** Selectors that will filter which files are in our candidate list. */\r\n    protected FileSelector[] selectors = null;\r\n\r\n    /**\r\n     * The files which matched at least one include and no excludes\r\n     * and were selected.\r\n     */\r\n    protected Vector filesIncluded;\r\n\r\n    /** The files which did not match any includes or selectors. */\r\n    protected Vector filesNotIncluded;\r\n\r\n    /**\r\n     * The files which matched at least one include and at least\r\n     * one exclude.\r\n     */\r\n    protected Vector filesExcluded;\r\n\r\n    /**\r\n     * The directories which matched at least one include and no excludes\r\n     * and were selected.\r\n     */\r\n    protected Vector dirsIncluded;\r\n\r\n    /** The directories which were found and did not match any includes. */\r\n    protected Vector dirsNotIncluded;\r\n\r\n    /**\r\n     * The directories which matched at least one include and at least one\r\n     * exclude.\r\n     */\r\n    protected Vector dirsExcluded;\r\n\r\n    /**\r\n     * The files which matched at least one include and no excludes and\r\n     * which a selector discarded.\r\n     */\r\n    protected Vector filesDeselected;\r\n\r\n    /**\r\n     * The directories which matched at least one include and no excludes\r\n     * but which a selector discarded.\r\n     */\r\n    protected Vector dirsDeselected;\r\n\r\n    /** Whether or not our results were built by a slow scan. */\r\n    protected boolean haveSlowResults = false;\r\n\r\n    /**\r\n     * Whether or not the file system should be treated as a case sensitive\r\n     * one.\r\n     */\r\n    protected boolean isCaseSensitive = true;\r\n\r\n    /**\r\n     * Whether a missing base directory is an error.\r\n     * @since Ant 1.7.1\r\n     */\r\n    protected boolean errorOnMissingDir = true;\r\n\r\n    /**\r\n     * Whether or not symbolic links should be followed.\r\n     *\r\n     * @since Ant 1.5\r\n     */\r\n    private boolean followSymlinks = true;\r\n\r\n    /** Whether or not everything tested so far has been included. */\r\n    protected boolean everythingIncluded = true;\r\n\r\n    // CheckStyle:VisibilityModifier ON\r\n\r\n    /**\r\n     * List of all scanned directories.\r\n     *\r\n     * @since Ant 1.6\r\n     */\r\n    private Set scannedDirs = new HashSet();\r\n\r\n    /**\r\n     * Map of all include patterns that are full file names and don\'t\r\n     * contain any wildcards.\r\n     *\r\n     * <p>Maps pattern string to TokenizedPath.</p>\r\n     *\r\n     * <p>If this instance is not case sensitive, the file names get\r\n     * turned to upper case.</p>\r\n     *\r\n     * <p>Gets lazily initialized on the first invocation of\r\n     * isIncluded or isExcluded and cleared at the end of the scan\r\n     * method (cleared in clearCaches, actually).</p>\r\n     *\r\n     * @since Ant 1.8.0\r\n     */\r\n    private Map includeNonPatterns = new HashMap();\r\n\r\n    /**\r\n     * Map of all exclude patterns that are full file names and don\'t\r\n     * contain any wildcards.\r\n     *\r\n     * <p>Maps pattern string to TokenizedPath.</p>\r\n     *\r\n     * <p>If this instance is not case sensitive, the file names get\r\n     * turned to upper case.</p>\r\n     *\r\n     * <p>Gets lazily initialized on the first invocation of\r\n     * isIncluded or isExcluded and cleared at the end of the scan\r\n     * method (cleared in clearCaches, actually).</p>\r\n     *\r\n     * @since Ant 1.8.0\r\n     */\r\n    private Map excludeNonPatterns = new HashMap();\r\n\r\n    /**\r\n     * Array of all include patterns that contain wildcards.\r\n     *\r\n     * <p>Gets lazily initialized on the first invocation of\r\n     * isIncluded or isExcluded and cleared at the end of the scan\r\n     * method (cleared in clearCaches, actually).</p>\r\n     */\r\n    private TokenizedPattern[] includePatterns;\r\n\r\n    /**\r\n     * Array of all exclude patterns that contain wildcards.\r\n     *\r\n     * <p>Gets lazily initialized on the first invocation of\r\n     * isIncluded or isExcluded and cleared at the end of the scan\r\n     * method (cleared in clearCaches, actually).</p>\r\n     */\r\n    private TokenizedPattern[] excludePatterns;\r\n\r\n    /**\r\n     * Have the non-pattern sets and pattern arrays for in- and\r\n     * excludes been initialized?\r\n     *\r\n     * @since Ant 1.6.3\r\n     */\r\n    private boolean areNonPatternSetsReady = false;\r\n\r\n    /**\r\n     * Scanning flag.\r\n     *\r\n     * @since Ant 1.6.3\r\n     */\r\n    private boolean scanning = false;\r\n\r\n    /**\r\n     * Scanning lock.\r\n     *\r\n     * @since Ant 1.6.3\r\n     */\r\n    private Object scanLock = new Object();\r\n\r\n    /**\r\n     * Slow scanning flag.\r\n     *\r\n     * @since Ant 1.6.3\r\n     */\r\n    private boolean slowScanning = false;\r\n\r\n    /**\r\n     * Slow scanning lock.\r\n     *\r\n     * @since Ant 1.6.3\r\n     */\r\n    private Object slowScanLock = new Object();\r\n\r\n    /**\r\n     * Exception thrown during scan.\r\n     *\r\n     * @since Ant 1.6.3\r\n     */\r\n    private IllegalStateException illegal = null;\r\n\r\n    /**\r\n     * The maximum number of times a symbolic link may be followed\r\n     * during a scan.\r\n     *\r\n     * @since Ant 1.8.0\r\n     */\r\n    private int maxLevelsOfSymlinks = MAX_LEVELS_OF_SYMLINKS;\r\n\r\n\r\n    /**\r\n     * Absolute paths of all symlinks that haven\'t been followed but\r\n     * would have been if followsymlinks had been true or\r\n     * maxLevelsOfSymlinks had been higher.\r\n     *\r\n     * @since Ant 1.8.0\r\n     */\r\n    private Set/*<String>*/ notFollowedSymlinks = new HashSet();\r\n\r\n    /**\r\n     * Sole constructor.\r\n     */\r\n    public DirectoryScanner() {\r\n    }\r\n\r\n    /**\r\n     * Test whether or not a given path matches the start of a given\r\n     * pattern up to the first \"**\".\r\n     * <p>\r\n     * This is not a general purpose test and should only be used if you\r\n     * can live with false positives. For example, <code>pattern=**\\a</code>\r\n     * and <code>str=b</code> will yield <code>true</code>.\r\n     *\r\n     * @param pattern The pattern to match against. Must not be\r\n     *                <code>null</code>.\r\n     * @param str     The path to match, as a String. Must not be\r\n     *                <code>null</code>.\r\n     *\r\n     * @return whether or not a given path matches the start of a given\r\n     * pattern up to the first \"**\".\r\n     */\r\n    protected static boolean matchPatternStart(String pattern, String str) {\r\n        return SelectorUtils.matchPatternStart(pattern, str);\r\n    }\r\n\r\n    /**\r\n     * Test whether or not a given path matches the start of a given\r\n     * pattern up to the first \"**\".\r\n     * <p>\r\n     * This is not a general purpose test and should only be used if you\r\n     * can live with false positives. For example, <code>pattern=**\\a</code>\r\n     * and <code>str=b</code> will yield <code>true</code>.\r\n     *\r\n     * @param pattern The pattern to match against. Must not be\r\n     *                <code>null</code>.\r\n     * @param str     The path to match, as a String. Must not be\r\n     *                <code>null</code>.\r\n     * @param isCaseSensitive Whether or not matching should be performed\r\n     *                        case sensitively.\r\n     *\r\n     * @return whether or not a given path matches the start of a given\r\n     * pattern up to the first \"**\".\r\n     */\r\n    protected static boolean matchPatternStart(String pattern, String str,\r\n                                               boolean isCaseSensitive) {\r\n        return SelectorUtils.matchPatternStart(pattern, str, isCaseSensitive);\r\n    }\r\n\r\n    /**\r\n     * Test whether or not a given path matches a given pattern.\r\n     *\r\n     * @param pattern The pattern to match against. Must not be\r\n     *                <code>null</code>.\r\n     * @param str     The path to match, as a String. Must not be\r\n     *                <code>null</code>.\r\n     *\r\n     * @return <code>true</code> if the pattern matches against the string,\r\n     *         or <code>false</code> otherwise.\r\n     */\r\n    protected static boolean matchPath(String pattern, String str) {\r\n        return SelectorUtils.matchPath(pattern, str);\r\n    }\r\n\r\n    /**\r\n     * Test whether or not a given path matches a given pattern.\r\n     *\r\n     * @param pattern The pattern to match against. Must not be\r\n     *                <code>null</code>.\r\n     * @param str     The path to match, as a String. Must not be\r\n     *                <code>null</code>.\r\n     * @param isCaseSensitive Whether or not matching should be performed\r\n     *                        case sensitively.\r\n     *\r\n     * @return <code>true</code> if the pattern matches against the string,\r\n     *         or <code>false</code> otherwise.\r\n     */\r\n    protected static boolean matchPath(String pattern, String str,\r\n                                       boolean isCaseSensitive) {\r\n        return SelectorUtils.matchPath(pattern, str, isCaseSensitive);\r\n    }\r\n\r\n    /**\r\n     * Test whether or not a string matches against a pattern.\r\n     * The pattern may contain two special characters:<br>\r\n     * \'*\' means zero or more characters<br>\r\n     * \'?\' means one and only one character\r\n     *\r\n     * @param pattern The pattern to match against.\r\n     *                Must not be <code>null</code>.\r\n     * @param str     The string which must be matched against the pattern.\r\n     *                Must not be <code>null</code>.\r\n     *\r\n     * @return <code>true</code> if the string matches against the pattern,\r\n     *         or <code>false</code> otherwise.\r\n     */\r\n    public static boolean match(String pattern, String str) {\r\n        return SelectorUtils.match(pattern, str);\r\n    }\r\n\r\n    /**\r\n     * Test whether or not a string matches against a pattern.\r\n     * The pattern may contain two special characters:<br>\r\n     * \'*\' means zero or more characters<br>\r\n     * \'?\' means one and only one character\r\n     *\r\n     * @param pattern The pattern to match against.\r\n     *                Must not be <code>null</code>.\r\n     * @param str     The string which must be matched against the pattern.\r\n     *                Must not be <code>null</code>.\r\n     * @param isCaseSensitive Whether or not matching should be performed\r\n     *                        case sensitively.\r\n     *\r\n     *\r\n     * @return <code>true</code> if the string matches against the pattern,\r\n     *         or <code>false</code> otherwise.\r\n     */\r\n    protected static boolean match(String pattern, String str,\r\n                                   boolean isCaseSensitive) {\r\n        return SelectorUtils.match(pattern, str, isCaseSensitive);\r\n    }\r\n\r\n\r\n    /**\r\n     * Get the list of patterns that should be excluded by default.\r\n     *\r\n     * @return An array of <code>String</code> based on the current\r\n     *         contents of the <code>defaultExcludes</code>\r\n     *         <code>Set</code>.\r\n     *\r\n     * @since Ant 1.6\r\n     */\r\n    public static String[] getDefaultExcludes() {\r\n        synchronized (defaultExcludes) {\r\n            return (String[]) defaultExcludes.toArray(new String[defaultExcludes\r\n                                                                 .size()]);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Add a pattern to the default excludes unless it is already a\r\n     * default exclude.\r\n     *\r\n     * @param s   A string to add as an exclude pattern.\r\n     * @return    <code>true</code> if the string was added;\r\n     *            <code>false</code> if it already existed.\r\n     *\r\n     * @since Ant 1.6\r\n     */\r\n    public static boolean addDefaultExclude(String s) {\r\n        synchronized (defaultExcludes) {\r\n            return defaultExcludes.add(s);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Remove a string if it is a default exclude.\r\n     *\r\n     * @param s   The string to attempt to remove.\r\n     * @return    <code>true</code> if <code>s</code> was a default\r\n     *            exclude (and thus was removed);\r\n     *            <code>false</code> if <code>s</code> was not\r\n     *            in the default excludes list to begin with.\r\n     *\r\n     * @since Ant 1.6\r\n     */\r\n    public static boolean removeDefaultExclude(String s) {\r\n        synchronized (defaultExcludes) {\r\n            return defaultExcludes.remove(s);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Go back to the hardwired default exclude patterns.\r\n     *\r\n     * @since Ant 1.6\r\n     */\r\n    public static void resetDefaultExcludes() {\r\n        synchronized (defaultExcludes) {\r\n            defaultExcludes.clear();\r\n            for (int i = 0; i < DEFAULTEXCLUDES.length; i++) {\r\n                defaultExcludes.add(DEFAULTEXCLUDES[i]);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Set the base directory to be scanned. This is the directory which is\r\n     * scanned recursively. All \'/\' and \'\\\' characters are replaced by\r\n     * <code>File.separatorChar</code>, so the separator used need not match\r\n     * <code>File.separatorChar</code>.\r\n     *\r\n     * @param basedir The base directory to scan.\r\n     */\r\n    public void setBasedir(String basedir) {\r\n        setBasedir(basedir == null ? (File) null\r\n            : new File(basedir.replace(\'/\', File.separatorChar).replace(\r\n            \'\\\\\', File.separatorChar)));\r\n    }\r\n\r\n    /**\r\n     * Set the base directory to be scanned. This is the directory which is\r\n     * scanned recursively.\r\n     *\r\n     * @param basedir The base directory for scanning.\r\n     */\r\n    public synchronized void setBasedir(File basedir) {\r\n        this.basedir = basedir;\r\n    }\r\n\r\n    /**\r\n     * Return the base directory to be scanned.\r\n     * This is the directory which is scanned recursively.\r\n     *\r\n     * @return the base directory to be scanned.\r\n     */\r\n    public synchronized File getBasedir() {\r\n        return basedir;\r\n    }\r\n\r\n    /**\r\n     * Find out whether include exclude patterns are matched in a\r\n     * case sensitive way.\r\n     * @return whether or not the scanning is case sensitive.\r\n     * @since Ant 1.6\r\n     */\r\n    public synchronized boolean isCaseSensitive() {\r\n        return isCaseSensitive;\r\n    }\r\n\r\n    /**\r\n     * Set whether or not include and exclude patterns are matched\r\n     * in a case sensitive way.\r\n     *\r\n     * @param isCaseSensitive whether or not the file system should be\r\n     *                        regarded as a case sensitive one.\r\n     */\r\n    public synchronized void setCaseSensitive(boolean isCaseSensitive) {\r\n        this.isCaseSensitive = isCaseSensitive;\r\n    }\r\n\r\n    /**\r\n     * Sets whether or not a missing base directory is an error\r\n     *\r\n     * @param errorOnMissingDir whether or not a missing base directory\r\n     *                        is an error\r\n     * @since Ant 1.7.1\r\n     */\r\n    public void setErrorOnMissingDir(boolean errorOnMissingDir) {\r\n        this.errorOnMissingDir = errorOnMissingDir;\r\n    }\r\n\r\n    /**\r\n     * Get whether or not a DirectoryScanner follows symbolic links.\r\n     *\r\n     * @return flag indicating whether symbolic links should be followed.\r\n     *\r\n     * @since Ant 1.6\r\n     */\r\n    public synchronized boolean isFollowSymlinks() {\r\n        return followSymlinks;\r\n    }\r\n\r\n    /**\r\n     * Set whether or not symbolic links should be followed.\r\n     *\r\n     * @param followSymlinks whether or not symbolic links should be followed.\r\n     */\r\n    public synchronized void setFollowSymlinks(boolean followSymlinks) {\r\n        this.followSymlinks = followSymlinks;\r\n    }\r\n\r\n    /**\r\n     * The maximum number of times a symbolic link may be followed\r\n     * during a scan.\r\n     *\r\n     * @since Ant 1.8.0\r\n     */\r\n    public void setMaxLevelsOfSymlinks(int max) {\r\n        maxLevelsOfSymlinks = max;\r\n    }\r\n\r\n    /**\r\n     * Set the list of include patterns to use. All \'/\' and \'\\\' characters\r\n     * are replaced by <code>File.separatorChar</code>, so the separator used\r\n     * need not match <code>File.separatorChar</code>.\r\n     * <p>\r\n     * When a pattern ends with a \'/\' or \'\\\', \"**\" is appended.\r\n     *\r\n     * @param includes A list of include patterns.\r\n     *                 May be <code>null</code>, indicating that all files\r\n     *                 should be included. If a non-<code>null</code>\r\n     *                 list is given, all elements must be\r\n     *                 non-<code>null</code>.\r\n     */\r\n    public synchronized void setIncludes(String[] includes) {\r\n        if (includes == null) {\r\n            this.includes = null;\r\n        } else {\r\n            this.includes = new String[includes.length];\r\n            for (int i = 0; i < includes.length; i++) {\r\n                this.includes[i] = normalizePattern(includes[i]);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Set the list of exclude patterns to use. All \'/\' and \'\\\' characters\r\n     * are replaced by <code>File.separatorChar</code>, so the separator used\r\n     * need not match <code>File.separatorChar</code>.\r\n     * <p>\r\n     * When a pattern ends with a \'/\' or \'\\\', \"**\" is appended.\r\n     *\r\n     * @param excludes A list of exclude patterns.\r\n     *                 May be <code>null</code>, indicating that no files\r\n     *                 should be excluded. If a non-<code>null</code> list is\r\n     *                 given, all elements must be non-<code>null</code>.\r\n     */\r\n    public synchronized void setExcludes(String[] excludes) {\r\n        if (excludes == null) {\r\n            this.excludes = null;\r\n        } else {\r\n            this.excludes = new String[excludes.length];\r\n            for (int i = 0; i < excludes.length; i++) {\r\n                this.excludes[i] = normalizePattern(excludes[i]);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Add to the list of exclude patterns to use. All \'/\' and \'\\\'\r\n     * characters are replaced by <code>File.separatorChar</code>, so\r\n     * the separator used need not match <code>File.separatorChar</code>.\r\n     * <p>\r\n     * When a pattern ends with a \'/\' or \'\\\', \"**\" is appended.\r\n     *\r\n     * @param excludes A list of exclude patterns.\r\n     *                 May be <code>null</code>, in which case the\r\n     *                 exclude patterns don\'t get changed at all.\r\n     *\r\n     * @since Ant 1.6.3\r\n     */\r\n    public synchronized void addExcludes(String[] excludes) {\r\n        if (excludes != null && excludes.length > 0) {\r\n            if (this.excludes != null && this.excludes.length > 0) {\r\n                String[] tmp = new String[excludes.length\r\n                                          + this.excludes.length];\r\n                System.arraycopy(this.excludes, 0, tmp, 0,\r\n                                 this.excludes.length);\r\n                for (int i = 0; i < excludes.length; i++) {\r\n                    tmp[this.excludes.length + i] =\r\n                        normalizePattern(excludes[i]);\r\n                }\r\n                this.excludes = tmp;\r\n            } else {\r\n                setExcludes(excludes);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * All \'/\' and \'\\\' characters are replaced by\r\n     * <code>File.separatorChar</code>, so the separator used need not\r\n     * match <code>File.separatorChar</code>.\r\n     *\r\n     * <p> When a pattern ends with a \'/\' or \'\\\', \"**\" is appended.\r\n     *\r\n     * @since Ant 1.6.3\r\n     */\r\n    private static String normalizePattern(String p) {\r\n        String pattern = p.replace(\'/\', File.separatorChar)\r\n            .replace(\'\\\\\', File.separatorChar);\r\n        if (pattern.endsWith(File.separator)) {\r\n            pattern += SelectorUtils.DEEP_TREE_MATCH;\r\n        }\r\n        return pattern;\r\n    }\r\n\r\n    /**\r\n     * Set the selectors that will select the filelist.\r\n     *\r\n     * @param selectors specifies the selectors to be invoked on a scan.\r\n     */\r\n    public synchronized void setSelectors(FileSelector[] selectors) {\r\n        this.selectors = selectors;\r\n    }\r\n\r\n    /**\r\n     * Return whether or not the scanner has included all the files or\r\n     * directories it has come across so far.\r\n     *\r\n     * @return <code>true</code> if all files and directories which have\r\n     *         been found so far have been included.\r\n     */\r\n    public synchronized boolean isEverythingIncluded() {\r\n        return everythingIncluded;\r\n    }\r\n\r\n    /**\r\n     * Scan for files which match at least one include pattern and don\'t match\r\n     * any exclude patterns. If there are selectors then the files must pass\r\n     * muster there, as well.  Scans under basedir, if set; otherwise the\r\n     * include patterns without leading wildcards specify the absolute paths of\r\n     * the files that may be included.\r\n     *\r\n     * @exception IllegalStateException if the base directory was set\r\n     *            incorrectly (i.e. if it doesn\'t exist or isn\'t a directory).\r\n     */\r\n    public void scan() throws IllegalStateException {\r\n        synchronized (scanLock) {\r\n            if (scanning) {\r\n                while (scanning) {\r\n                    try {\r\n                        scanLock.wait();\r\n                    } catch (InterruptedException e) {\r\n                        continue;\r\n                    }\r\n                }\r\n                if (illegal != null) {\r\n                    throw illegal;\r\n                }\r\n                return;\r\n            }\r\n            scanning = true;\r\n        }\r\n        File savedBase = basedir;\r\n        try {\r\n            synchronized (this) {\r\n                illegal = null;\r\n                clearResults();\r\n\r\n                // set in/excludes to reasonable defaults if needed:\r\n                boolean nullIncludes = (includes == null);\r\n                includes = nullIncludes\r\n                    ? new String[] {SelectorUtils.DEEP_TREE_MATCH} : includes;\r\n                boolean nullExcludes = (excludes == null);\r\n                excludes = nullExcludes ? new String[0] : excludes;\r\n\r\n                if (basedir != null && !followSymlinks\r\n                    && SYMLINK_UTILS.isSymbolicLink(basedir)) {\r\n                    notFollowedSymlinks.add(basedir.getAbsolutePath());\r\n                    basedir = null;\r\n                }\r\n\r\n                if (basedir == null) {\r\n                    // if no basedir and no includes, nothing to do:\r\n                    if (nullIncludes) {\r\n                        return;\r\n                    }\r\n                } else {\r\n                    if (!basedir.exists()) {\r\n                        if (errorOnMissingDir) {\r\n                            illegal = new IllegalStateException(\"basedir \"\r\n                                                                + basedir\r\n                                                                + DOES_NOT_EXIST_POSTFIX);\r\n                        } else {\r\n                            // Nothing to do - basedir does not exist\r\n                            return;\r\n                        }\r\n                    } else if (!basedir.isDirectory()) {\r\n                        illegal = new IllegalStateException(\"basedir \"\r\n                                                            + basedir\r\n                                                            + \" is not a\"\r\n                                                            + \" directory.\");\r\n                    }\r\n                    if (illegal != null) {\r\n                        throw illegal;\r\n                    }\r\n                }\r\n                if (isIncluded(TokenizedPath.EMPTY_PATH)) {\r\n                    if (!isExcluded(TokenizedPath.EMPTY_PATH)) {\r\n                        if (isSelected(\"\", basedir)) {\r\n                            dirsIncluded.addElement(\"\");\r\n                        } else {\r\n                            dirsDeselected.addElement(\"\");\r\n                        }\r\n                    } else {\r\n                        dirsExcluded.addElement(\"\");\r\n                    }\r\n                } else {\r\n                    dirsNotIncluded.addElement(\"\");\r\n                }\r\n                checkIncludePatterns();\r\n                clearCaches();\r\n                includes = nullIncludes ? null : includes;\r\n                excludes = nullExcludes ? null : excludes;\r\n            }\r\n        } catch (IOException ex) {\r\n            throw new BuildException(ex);\r\n        } finally {\r\n            basedir = savedBase;\r\n            synchronized (scanLock) {\r\n                scanning = false;\r\n                scanLock.notifyAll();\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * This routine is actually checking all the include patterns in\r\n     * order to avoid scanning everything under base dir.\r\n     * @since Ant 1.6\r\n     */\r\n    private void checkIncludePatterns() {\r\n        ensureNonPatternSetsReady();\r\n        Map newroots = new HashMap();\r\n\r\n        // put in the newroots map the include patterns without\r\n        // wildcard tokens\r\n        for (int i = 0; i < includePatterns.length; i++) {\r\n            String pattern = includePatterns[i].toString();\r\n            if (!shouldSkipPattern(pattern)) {\r\n                newroots.put(includePatterns[i].rtrimWildcardTokens(),\r\n                             pattern);\r\n            }\r\n        }\r\n        for (Iterator iter = includeNonPatterns.entrySet().iterator();\r\n             iter.hasNext(); ) {\r\n            Map.Entry entry = (Map.Entry) iter.next();\r\n            String pattern = (String) entry.getKey();\r\n            if (!shouldSkipPattern(pattern)) {\r\n                newroots.put((TokenizedPath) entry.getValue(), pattern);\r\n            }\r\n        }\r\n\r\n        if (newroots.containsKey(TokenizedPath.EMPTY_PATH)\r\n            && basedir != null) {\r\n            // we are going to scan everything anyway\r\n            scandir(basedir, \"\", true);\r\n        } else {\r\n            // only scan directories that can include matched files or\r\n            // directories\r\n            Iterator it = newroots.entrySet().iterator();\r\n\r\n            File canonBase = null;\r\n            if (basedir != null) {\r\n                try {\r\n                    canonBase = basedir.getCanonicalFile();\r\n                } catch (IOException ex) {\r\n                    throw new BuildException(ex);\r\n                }\r\n            }\r\n            while (it.hasNext()) {\r\n                Map.Entry entry = (Map.Entry) it.next();\r\n                TokenizedPath currentPath = (TokenizedPath) entry.getKey();\r\n                String currentelement = currentPath.toString();\r\n                if (basedir == null\r\n                    && !FileUtils.isAbsolutePath(currentelement)) {\r\n                    continue;\r\n                }\r\n                File myfile = new File(basedir, currentelement);\r\n\r\n                if (myfile.exists()) {\r\n                    // may be on a case insensitive file system.  We want\r\n                    // the results to show what\'s really on the disk, so\r\n                    // we need to double check.\r\n                    try {\r\n                        String path = (basedir == null)\r\n                            ? myfile.getCanonicalPath()\r\n                            : FILE_UTILS.removeLeadingPath(canonBase,\r\n                                         myfile.getCanonicalFile());\r\n                        if (!path.equals(currentelement) || ON_VMS) {\r\n                            myfile = currentPath.findFile(basedir, true);\r\n                            if (myfile != null && basedir != null) {\r\n                                currentelement = FILE_UTILS.removeLeadingPath(\r\n                                    basedir, myfile);\r\n                                if (!currentPath.toString()\r\n                                    .equals(currentelement)) {\r\n                                    currentPath =\r\n                                        new TokenizedPath(currentelement);\r\n                                }\r\n                            }\r\n                        }\r\n                    } catch (IOException ex) {\r\n                        throw new BuildException(ex);\r\n                    }\r\n                }\r\n\r\n                if ((myfile == null || !myfile.exists()) && !isCaseSensitive()) {\r\n                    File f = currentPath.findFile(basedir, false);\r\n                    if (f != null && f.exists()) {\r\n                        // adapt currentelement to the case we\'ve\r\n                        // actually found\r\n                        currentelement = (basedir == null)\r\n                            ? f.getAbsolutePath()\r\n                            : FILE_UTILS.removeLeadingPath(basedir, f);\r\n                        myfile = f;\r\n                        currentPath = new TokenizedPath(currentelement);\r\n                    }\r\n                }\r\n\r\n                if (myfile != null && myfile.exists()) {\r\n                    if (!followSymlinks && currentPath.isSymlink(basedir)) {\r\n                        if (!isExcluded(currentPath)) {\r\n                            notFollowedSymlinks.add(myfile.getAbsolutePath());\r\n                        }\r\n                        continue;\r\n                    }\r\n                    if (myfile.isDirectory()) {\r\n                        if (isIncluded(currentPath)\r\n                            && currentelement.length() > 0) {\r\n                            accountForIncludedDir(currentPath, myfile, true);\r\n                        }  else {\r\n                            scandir(myfile, currentPath, true);\r\n                        }\r\n                    } else {\r\n                        String originalpattern = (String) entry.getValue();\r\n                        boolean included = isCaseSensitive()\r\n                            ? originalpattern.equals(currentelement)\r\n                            : originalpattern.equalsIgnoreCase(currentelement);\r\n                        if (included) {\r\n                            accountForIncludedFile(currentPath, myfile);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * true if the pattern specifies a relative path without basedir\r\n     * or an absolute path not inside basedir.\r\n     *\r\n     * @since Ant 1.8.0\r\n     */\r\n    private boolean shouldSkipPattern(String pattern) {\r\n        if (FileUtils.isAbsolutePath(pattern)) {\r\n            //skip abs. paths not under basedir, if set:\r\n            if (basedir != null\r\n                && !SelectorUtils.matchPatternStart(pattern,\r\n                                                    basedir.getAbsolutePath(),\r\n                                                    isCaseSensitive())) {\r\n                return true;\r\n            }\r\n        } else if (basedir == null) {\r\n            //skip non-abs. paths if basedir == null:\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Clear the result caches for a scan.\r\n     */\r\n    protected synchronized void clearResults() {\r\n        filesIncluded    = new VectorSet();\r\n        filesNotIncluded = new VectorSet();\r\n        filesExcluded    = new VectorSet();\r\n        filesDeselected  = new VectorSet();\r\n        dirsIncluded     = new VectorSet();\r\n        dirsNotIncluded  = new VectorSet();\r\n        dirsExcluded     = new VectorSet();\r\n        dirsDeselected   = new VectorSet();\r\n        everythingIncluded = (basedir != null);\r\n        scannedDirs.clear();\r\n        notFollowedSymlinks.clear();\r\n    }\r\n\r\n    /**\r\n     * Top level invocation for a slow scan. A slow scan builds up a full\r\n     * list of excluded/included files/directories, whereas a fast scan\r\n     * will only have full results for included files, as it ignores\r\n     * directories which can\'t possibly hold any included files/directories.\r\n     * <p>\r\n     * Returns immediately if a slow scan has already been completed.\r\n     */\r\n    protected void slowScan() {\r\n        synchronized (slowScanLock) {\r\n            if (haveSlowResults) {\r\n                return;\r\n            }\r\n            if (slowScanning) {\r\n                while (slowScanning) {\r\n                    try {\r\n                        slowScanLock.wait();\r\n                    } catch (InterruptedException e) {\r\n                        // Empty\r\n                    }\r\n                }\r\n                return;\r\n            }\r\n            slowScanning = true;\r\n        }\r\n        try {\r\n            synchronized (this) {\r\n\r\n                // set in/excludes to reasonable defaults if needed:\r\n                boolean nullIncludes = (includes == null);\r\n                includes = nullIncludes\r\n                    ? new String[] {SelectorUtils.DEEP_TREE_MATCH} : includes;\r\n                boolean nullExcludes = (excludes == null);\r\n                excludes = nullExcludes ? new String[0] : excludes;\r\n\r\n                String[] excl = new String[dirsExcluded.size()];\r\n                dirsExcluded.copyInto(excl);\r\n\r\n                String[] notIncl = new String[dirsNotIncluded.size()];\r\n                dirsNotIncluded.copyInto(notIncl);\r\n\r\n                ensureNonPatternSetsReady();\r\n\r\n                processSlowScan(excl);\r\n                processSlowScan(notIncl);\r\n                clearCaches();\r\n                includes = nullIncludes ? null : includes;\r\n                excludes = nullExcludes ? null : excludes;\r\n            }\r\n        } finally {\r\n            synchronized (slowScanLock) {\r\n                haveSlowResults = true;\r\n                slowScanning = false;\r\n                slowScanLock.notifyAll();\r\n            }\r\n        }\r\n    }\r\n\r\n    private void processSlowScan(String[] arr) {\r\n        for (int i = 0; i < arr.length; i++) {\r\n            TokenizedPath path  = new TokenizedPath(arr[i]);\r\n            if (!couldHoldIncluded(path) || contentsExcluded(path)) {\r\n                scandir(new File(basedir, arr[i]), path, false);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Scan the given directory for files and directories. Found files and\r\n     * directories are placed in their respective collections, based on the\r\n     * matching of includes, excludes, and the selectors.  When a directory\r\n     * is found, it is scanned recursively.\r\n     *\r\n     * @param dir   The directory to scan. Must not be <code>null</code>.\r\n     * @param vpath The path relative to the base directory (needed to\r\n     *              prevent problems with an absolute path when using\r\n     *              dir). Must not be <code>null</code>.\r\n     * @param fast  Whether or not this call is part of a fast scan.\r\n     *\r\n     * @see #filesIncluded\r\n     * @see #filesNotIncluded\r\n     * @see #filesExcluded\r\n     * @see #dirsIncluded\r\n     * @see #dirsNotIncluded\r\n     * @see #dirsExcluded\r\n     * @see #slowScan\r\n     */\r\n    protected void scandir(File dir, String vpath, boolean fast) {\r\n        scandir(dir, new TokenizedPath(vpath), fast);\r\n    }\r\n\r\n    /**\r\n     * Scan the given directory for files and directories. Found files and\r\n     * directories are placed in their respective collections, based on the\r\n     * matching of includes, excludes, and the selectors.  When a directory\r\n     * is found, it is scanned recursively.\r\n     *\r\n     * @param dir   The directory to scan. Must not be <code>null</code>.\r\n     * @param path The path relative to the base directory (needed to\r\n     *              prevent problems with an absolute path when using\r\n     *              dir). Must not be <code>null</code>.\r\n     * @param fast  Whether or not this call is part of a fast scan.\r\n     *\r\n     * @see #filesIncluded\r\n     * @see #filesNotIncluded\r\n     * @see #filesExcluded\r\n     * @see #dirsIncluded\r\n     * @see #dirsNotIncluded\r\n     * @see #dirsExcluded\r\n     * @see #slowScan\r\n     */\r\n    private void scandir(File dir, TokenizedPath path, boolean fast) {\r\n        if (dir == null) {\r\n            throw new BuildException(\"dir must not be null.\");\r\n        }\r\n        String[] newfiles = dir.list();\r\n        if (newfiles == null) {\r\n            if (!dir.exists()) {\r\n                throw new BuildException(dir + DOES_NOT_EXIST_POSTFIX);\r\n            } else if (!dir.isDirectory()) {\r\n                throw new BuildException(dir + \" is not a directory.\");\r\n            } else {\r\n                throw new BuildException(\"IO error scanning directory \'\"\r\n                                         + dir.getAbsolutePath() + \"\'\");\r\n            }\r\n        }\r\n        scandir(dir, path, fast, newfiles, new LinkedList());\r\n    }\r\n\r\n    private void scandir(File dir, TokenizedPath path, boolean fast,\r\n                         String[] newfiles, LinkedList directoryNamesFollowed) {\r\n        String vpath = path.toString();\r\n        if (vpath.length() > 0 && !vpath.endsWith(File.separator)) {\r\n            vpath += File.separator;\r\n        }\r\n\r\n        // avoid double scanning of directories, can only happen in fast mode\r\n        if (fast && hasBeenScanned(vpath)) {\r\n            return;\r\n        }\r\n        if (!followSymlinks) {\r\n            ArrayList noLinks = new ArrayList();\r\n            for (int i = 0; i < newfiles.length; i++) {\r\n                try {\r\n                    if (SYMLINK_UTILS.isSymbolicLink(dir, newfiles[i])) {\r\n                        String name = vpath + newfiles[i];\r\n                        File file = new File(dir, newfiles[i]);\r\n                        (file.isDirectory()\r\n                            ? dirsExcluded : filesExcluded).addElement(name);\r\n                        if (!isExcluded(name)) {\r\n                            notFollowedSymlinks.add(file.getAbsolutePath());\r\n                        }\r\n                    } else {\r\n                        noLinks.add(newfiles[i]);\r\n                    }\r\n                } catch (IOException ioe) {\r\n                    String msg = \"IOException caught while checking \"\r\n                        + \"for links, couldn\'t get canonical path!\";\r\n                    // will be caught and redirected to Ant\'s logging system\r\n                    System.err.println(msg);\r\n                    noLinks.add(newfiles[i]);\r\n                }\r\n            }\r\n            newfiles = (String[]) (noLinks.toArray(new String[noLinks.size()]));\r\n        } else {\r\n            directoryNamesFollowed.addFirst(dir.getName());\r\n        }\r\n\r\n        for (int i = 0; i < newfiles.length; i++) {\r\n            String name = vpath + newfiles[i];\r\n            TokenizedPath newPath = new TokenizedPath(path, newfiles[i]);\r\n            File file = new File(dir, newfiles[i]);\r\n            String[] children = file.list();\r\n            if (children == null || (children.length == 0 && file.isFile())) {\r\n                if (isIncluded(newPath)) {\r\n                    accountForIncludedFile(newPath, file);\r\n                } else {\r\n                    everythingIncluded = false;\r\n                    filesNotIncluded.addElement(name);\r\n                }\r\n            } else { // dir\r\n\r\n                if (followSymlinks\r\n                    && causesIllegalSymlinkLoop(newfiles[i], dir,\r\n                                                directoryNamesFollowed)) {\r\n                    // will be caught and redirected to Ant\'s logging system\r\n                    System.err.println(\"skipping symbolic link \"\r\n                                       + file.getAbsolutePath()\r\n                                       + \" -- too many levels of symbolic\"\r\n                                       + \" links.\");\r\n                    notFollowedSymlinks.add(file.getAbsolutePath());\r\n                    continue;\r\n                }\r\n\r\n                if (isIncluded(newPath)) {\r\n                    accountForIncludedDir(newPath, file, fast, children,\r\n                                          directoryNamesFollowed);\r\n                } else {\r\n                    everythingIncluded = false;\r\n                    dirsNotIncluded.addElement(name);\r\n                    if (fast && couldHoldIncluded(newPath)\r\n                        && !contentsExcluded(newPath)) {\r\n                        scandir(file, newPath, fast, children,\r\n                                directoryNamesFollowed);\r\n                    }\r\n                }\r\n                if (!fast) {\r\n                    scandir(file, newPath, fast, children, directoryNamesFollowed);\r\n                }\r\n            }\r\n        }\r\n\r\n        if (followSymlinks) {\r\n            directoryNamesFollowed.removeFirst();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Process included file.\r\n     * @param name  path of the file relative to the directory of the FileSet.\r\n     * @param file  included File.\r\n     */\r\n    private void accountForIncludedFile(TokenizedPath name, File file) {\r\n        processIncluded(name, file, filesIncluded, filesExcluded,\r\n                        filesDeselected);\r\n    }\r\n\r\n    /**\r\n     * Process included directory.\r\n     * @param name path of the directory relative to the directory of\r\n     *             the FileSet.\r\n     * @param file directory as File.\r\n     * @param fast whether to perform fast scans.\r\n     */\r\n    private void accountForIncludedDir(TokenizedPath name, File file,\r\n                                       boolean fast) {\r\n        processIncluded(name, file, dirsIncluded, dirsExcluded, dirsDeselected);\r\n        if (fast && couldHoldIncluded(name) && !contentsExcluded(name)) {\r\n            scandir(file, name, fast);\r\n        }\r\n    }\r\n\r\n    private void accountForIncludedDir(TokenizedPath name,\r\n                                       File file, boolean fast,\r\n                                       String[] children,\r\n                                       LinkedList directoryNamesFollowed) {\r\n        processIncluded(name, file, dirsIncluded, dirsExcluded, dirsDeselected);\r\n        if (fast && couldHoldIncluded(name) && !contentsExcluded(name)) {\r\n            scandir(file, name, fast, children, directoryNamesFollowed);\r\n        }\r\n    }\r\n\r\n    private void processIncluded(TokenizedPath path,\r\n                                 File file, Vector inc, Vector exc,\r\n                                 Vector des) {\r\n        String name = path.toString();\r\n        if (inc.contains(name) || exc.contains(name) || des.contains(name)) {\r\n            return;\r\n        }\r\n\r\n        boolean included = false;\r\n        if (isExcluded(path)) {\r\n            exc.add(name);\r\n        } else if (isSelected(name, file)) {\r\n            included = true;\r\n            inc.add(name);\r\n        } else {\r\n            des.add(name);\r\n        }\r\n        everythingIncluded &= included;\r\n    }\r\n\r\n    /**\r\n     * Test whether or not a name matches against at least one include\r\n     * pattern.\r\n     *\r\n     * @param name The name to match. Must not be <code>null</code>.\r\n     * @return <code>true</code> when the name matches against at least one\r\n     *         include pattern, or <code>false</code> otherwise.\r\n     */\r\n    protected boolean isIncluded(String name) {\r\n        return isIncluded(new TokenizedPath(name));\r\n    }\r\n\r\n    /**\r\n     * Test whether or not a name matches against at least one include\r\n     * pattern.\r\n     *\r\n     * @param name The name to match. Must not be <code>null</code>.\r\n     * @return <code>true</code> when the name matches against at least one\r\n     *         include pattern, or <code>false</code> otherwise.\r\n     */\r\n    private boolean isIncluded(TokenizedPath path) {\r\n        ensureNonPatternSetsReady();\r\n\r\n        if (isCaseSensitive()\r\n            ? includeNonPatterns.containsKey(path.toString())\r\n            : includeNonPatterns.containsKey(path.toString().toUpperCase())) {\r\n            return true;\r\n        }\r\n        for (int i = 0; i < includePatterns.length; i++) {\r\n            if (includePatterns[i].matchPath(path, isCaseSensitive())) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Test whether or not a name matches the start of at least one include\r\n     * pattern.\r\n     *\r\n     * @param name The name to match. Must not be <code>null</code>.\r\n     * @return <code>true</code> when the name matches against the start of at\r\n     *         least one include pattern, or <code>false</code> otherwise.\r\n     */\r\n    protected boolean couldHoldIncluded(String name) {\r\n        return couldHoldIncluded(new TokenizedPath(name));\r\n    }\r\n\r\n    /**\r\n     * Test whether or not a name matches the start of at least one include\r\n     * pattern.\r\n     *\r\n     * @param tokenizedName The name to match. Must not be <code>null</code>.\r\n     * @return <code>true</code> when the name matches against the start of at\r\n     *         least one include pattern, or <code>false</code> otherwise.\r\n     */\r\n    private boolean couldHoldIncluded(TokenizedPath tokenizedName) {\r\n        for (int i = 0; i < includePatterns.length; i++) {\r\n            if (couldHoldIncluded(tokenizedName, includePatterns[i])) {\r\n                return true;\r\n            }\r\n        }\r\n        for (Iterator iter = includeNonPatterns.values().iterator();\r\n             iter.hasNext(); ) {\r\n            if (couldHoldIncluded(tokenizedName,\r\n                                  ((TokenizedPath) iter.next()).toPattern())) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Test whether or not a name matches the start of the given\r\n     * include pattern.\r\n     *\r\n     * @param tokenizedName The name to match. Must not be <code>null</code>.\r\n     * @return <code>true</code> when the name matches against the start of the\r\n     *         include pattern, or <code>false</code> otherwise.\r\n     */\r\n    private boolean couldHoldIncluded(TokenizedPath tokenizedName,\r\n                                      TokenizedPattern tokenizedInclude) {\r\n        return tokenizedInclude.matchStartOf(tokenizedName, isCaseSensitive())\r\n            && isMorePowerfulThanExcludes(tokenizedName.toString())\r\n            && isDeeper(tokenizedInclude, tokenizedName);\r\n    }\r\n\r\n    /**\r\n     * Verify that a pattern specifies files deeper\r\n     * than the level of the specified file.\r\n     * @param pattern the pattern to check.\r\n     * @param name the name to check.\r\n     * @return whether the pattern is deeper than the name.\r\n     * @since Ant 1.6.3\r\n     */\r\n    private boolean isDeeper(TokenizedPattern pattern, TokenizedPath name) {\r\n        return pattern.containsPattern(SelectorUtils.DEEP_TREE_MATCH)\r\n            || pattern.depth() > name.depth();\r\n    }\r\n\r\n    /**\r\n     *  Find out whether one particular include pattern is more powerful\r\n     *  than all the excludes.\r\n     *  Note:  the power comparison is based on the length of the include pattern\r\n     *  and of the exclude patterns without the wildcards.\r\n     *  Ideally the comparison should be done based on the depth\r\n     *  of the match; that is to say how many file separators have been matched\r\n     *  before the first ** or the end of the pattern.\r\n     *\r\n     *  IMPORTANT : this function should return false \"with care\".\r\n     *\r\n     *  @param name the relative path to test.\r\n     *  @return true if there is no exclude pattern more powerful than\r\n     *  this include pattern.\r\n     *  @since Ant 1.6\r\n     */\r\n    private boolean isMorePowerfulThanExcludes(String name) {\r\n        final String soughtexclude =\r\n            name + File.separatorChar + SelectorUtils.DEEP_TREE_MATCH;\r\n        for (int counter = 0; counter < excludePatterns.length; counter++) {\r\n            if (excludePatterns[counter].toString().equals(soughtexclude))  {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Test whether all contents of the specified directory must be excluded.\r\n     * @param path the path to check.\r\n     * @return whether all the specified directory\'s contents are excluded.\r\n     */\r\n    /* package */ boolean contentsExcluded(TokenizedPath path) {\r\n        for (int i = 0; i < excludePatterns.length; i++) {\r\n            if (excludePatterns[i].endsWith(SelectorUtils.DEEP_TREE_MATCH)\r\n                && excludePatterns[i].withoutLastToken()\r\n                   .matchPath(path, isCaseSensitive())) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Test whether or not a name matches against at least one exclude\r\n     * pattern.\r\n     *\r\n     * @param name The name to match. Must not be <code>null</code>.\r\n     * @return <code>true</code> when the name matches against at least one\r\n     *         exclude pattern, or <code>false</code> otherwise.\r\n     */\r\n    protected boolean isExcluded(String name) {\r\n        return isExcluded(new TokenizedPath(name));\r\n    }\r\n\r\n    /**\r\n     * Test whether or not a name matches against at least one exclude\r\n     * pattern.\r\n     *\r\n     * @param name The name to match. Must not be <code>null</code>.\r\n     * @return <code>true</code> when the name matches against at least one\r\n     *         exclude pattern, or <code>false</code> otherwise.\r\n     */\r\n    private boolean isExcluded(TokenizedPath name) {\r\n        ensureNonPatternSetsReady();\r\n\r\n        if (isCaseSensitive()\r\n            ? excludeNonPatterns.containsKey(name.toString())\r\n            : excludeNonPatterns.containsKey(name.toString().toUpperCase())) {\r\n            return true;\r\n        }\r\n        for (int i = 0; i < excludePatterns.length; i++) {\r\n            if (excludePatterns[i].matchPath(name, isCaseSensitive())) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Test whether a file should be selected.\r\n     *\r\n     * @param name the filename to check for selecting.\r\n     * @param file the java.io.File object for this filename.\r\n     * @return <code>false</code> when the selectors says that the file\r\n     *         should not be selected, <code>true</code> otherwise.\r\n     */\r\n    protected boolean isSelected(String name, File file) {\r\n        if (selectors != null) {\r\n            for (int i = 0; i < selectors.length; i++) {\r\n                if (!selectors[i].isSelected(basedir, name, file)) {\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Return the names of the files which matched at least one of the\r\n     * include patterns and none of the exclude patterns.\r\n     * The names are relative to the base directory.\r\n     *\r\n     * @return the names of the files which matched at least one of the\r\n     *         include patterns and none of the exclude patterns.\r\n     */\r\n    public String[] getIncludedFiles() {\r\n        String[] files;\r\n        synchronized (this) {\r\n            if (filesIncluded == null) {\r\n                throw new IllegalStateException(\"Must call scan() first\");\r\n            }\r\n            files = new String[filesIncluded.size()];\r\n            filesIncluded.copyInto(files);\r\n        }\r\n        Arrays.sort(files);\r\n        return files;\r\n    }\r\n\r\n    /**\r\n     * Return the count of included files.\r\n     * @return <code>int</code>.\r\n     * @since Ant 1.6.3\r\n     */\r\n    public synchronized int getIncludedFilesCount() {\r\n        if (filesIncluded == null) {\r\n            throw new IllegalStateException(\"Must call scan() first\");\r\n        }\r\n        return filesIncluded.size();\r\n    }\r\n\r\n    /**\r\n     * Return the names of the files which matched none of the include\r\n     * patterns. The names are relative to the base directory. This involves\r\n     * performing a slow scan if one has not already been completed.\r\n     *\r\n     * @return the names of the files which matched none of the include\r\n     *         patterns.\r\n     *\r\n     * @see #slowScan\r\n     */\r\n    public synchronized String[] getNotIncludedFiles() {\r\n        slowScan();\r\n        String[] files = new String[filesNotIncluded.size()];\r\n        filesNotIncluded.copyInto(files);\r\n        return files;\r\n    }\r\n\r\n    /**\r\n     * Return the names of the files which matched at least one of the\r\n     * include patterns and at least one of the exclude patterns.\r\n     * The names are relative to the base directory. This involves\r\n     * performing a slow scan if one has not already been completed.\r\n     *\r\n     * @return the names of the files which matched at least one of the\r\n     *         include patterns and at least one of the exclude patterns.\r\n     *\r\n     * @see #slowScan\r\n     */\r\n    public synchronized String[] getExcludedFiles() {\r\n        slowScan();\r\n        String[] files = new String[filesExcluded.size()];\r\n        filesExcluded.copyInto(files);\r\n        return files;\r\n    }\r\n\r\n    /**\r\n     * <p>Return the names of the files which were selected out and\r\n     * therefore not ultimately included.</p>\r\n     *\r\n     * <p>The names are relative to the base directory. This involves\r\n     * performing a slow scan if one has not already been completed.</p>\r\n     *\r\n     * @return the names of the files which were deselected.\r\n     *\r\n     * @see #slowScan\r\n     */\r\n    public synchronized String[] getDeselectedFiles() {\r\n        slowScan();\r\n        String[] files = new String[filesDeselected.size()];\r\n        filesDeselected.copyInto(files);\r\n        return files;\r\n    }\r\n\r\n    /**\r\n     * Return the names of the directories which matched at least one of the\r\n     * include patterns and none of the exclude patterns.\r\n     * The names are relative to the base directory.\r\n     *\r\n     * @return the names of the directories which matched at least one of the\r\n     * include patterns and none of the exclude patterns.\r\n     */\r\n    public String[] getIncludedDirectories() {\r\n        String[] directories;\r\n        synchronized (this) {\r\n            if (dirsIncluded == null) {\r\n                throw new IllegalStateException(\"Must call scan() first\");\r\n            }\r\n            directories = new String[dirsIncluded.size()];\r\n            dirsIncluded.copyInto(directories);\r\n        }\r\n        Arrays.sort(directories);\r\n        return directories;\r\n    }\r\n\r\n    /**\r\n     * Return the count of included directories.\r\n     * @return <code>int</code>.\r\n     * @since Ant 1.6.3\r\n     */\r\n    public synchronized int getIncludedDirsCount() {\r\n        if (dirsIncluded == null) {\r\n            throw new IllegalStateException(\"Must call scan() first\");\r\n        }\r\n        return dirsIncluded.size();\r\n    }\r\n\r\n    /**\r\n     * Return the names of the directories which matched none of the include\r\n     * patterns. The names are relative to the base directory. This involves\r\n     * performing a slow scan if one has not already been completed.\r\n     *\r\n     * @return the names of the directories which matched none of the include\r\n     * patterns.\r\n     *\r\n     * @see #slowScan\r\n     */\r\n    public synchronized String[] getNotIncludedDirectories() {\r\n        slowScan();\r\n        String[] directories = new String[dirsNotIncluded.size()];\r\n        dirsNotIncluded.copyInto(directories);\r\n        return directories;\r\n    }\r\n\r\n    /**\r\n     * Return the names of the directories which matched at least one of the\r\n     * include patterns and at least one of the exclude patterns.\r\n     * The names are relative to the base directory. This involves\r\n     * performing a slow scan if one has not already been completed.\r\n     *\r\n     * @return the names of the directories which matched at least one of the\r\n     * include patterns and at least one of the exclude patterns.\r\n     *\r\n     * @see #slowScan\r\n     */\r\n    public synchronized String[] getExcludedDirectories() {\r\n        slowScan();\r\n        String[] directories = new String[dirsExcluded.size()];\r\n        dirsExcluded.copyInto(directories);\r\n        return directories;\r\n    }\r\n\r\n    /**\r\n     * <p>Return the names of the directories which were selected out and\r\n     * therefore not ultimately included.</p>\r\n     *\r\n     * <p>The names are relative to the base directory. This involves\r\n     * performing a slow scan if one has not already been completed.</p>\r\n     *\r\n     * @return the names of the directories which were deselected.\r\n     *\r\n     * @see #slowScan\r\n     */\r\n    public synchronized String[] getDeselectedDirectories() {\r\n        slowScan();\r\n        String[] directories = new String[dirsDeselected.size()];\r\n        dirsDeselected.copyInto(directories);\r\n        return directories;\r\n    }\r\n\r\n    /**\r\n     * Absolute paths of all symbolic links that haven\'t been followed\r\n     * but would have been followed had followsymlinks been true or\r\n     * maxLevelsOfSymlinks been bigger.\r\n     *\r\n     * @since Ant 1.8.0\r\n     */\r\n    public synchronized String[] getNotFollowedSymlinks() {\r\n        String[] links;\r\n        synchronized (this) {\r\n            links = (String[]) notFollowedSymlinks\r\n                .toArray(new String[notFollowedSymlinks.size()]);\r\n        }\r\n        Arrays.sort(links);\r\n        return links;\r\n    }\r\n\r\n    /**\r\n     * Add default exclusions to the current exclusions set.\r\n     */\r\n    public synchronized void addDefaultExcludes() {\r\n        int excludesLength = excludes == null ? 0 : excludes.length;\r\n        String[] newExcludes;\r\n        String[] defaultExcludesTemp = getDefaultExcludes();\r\n        newExcludes = new String[excludesLength + defaultExcludesTemp.length];\r\n        if (excludesLength > 0) {\r\n            System.arraycopy(excludes, 0, newExcludes, 0, excludesLength);\r\n        }\r\n        for (int i = 0; i < defaultExcludesTemp.length; i++) {\r\n            newExcludes[i + excludesLength] =\r\n                defaultExcludesTemp[i].replace(\'/\', File.separatorChar)\r\n                .replace(\'\\\\\', File.separatorChar);\r\n        }\r\n        excludes = newExcludes;\r\n    }\r\n\r\n    /**\r\n     * Get the named resource.\r\n     * @param name path name of the file relative to the dir attribute.\r\n     *\r\n     * @return the resource with the given name.\r\n     * @since Ant 1.5.2\r\n     */\r\n    public synchronized Resource getResource(String name) {\r\n        return new FileResource(basedir, name);\r\n    }\r\n\r\n    /**\r\n     * Has the directory with the given path relative to the base\r\n     * directory already been scanned?\r\n     *\r\n     * <p>Registers the given directory as scanned as a side effect.</p>\r\n     *\r\n     * @since Ant 1.6\r\n     */\r\n    private boolean hasBeenScanned(String vpath) {\r\n        return !scannedDirs.add(vpath);\r\n    }\r\n\r\n    /**\r\n     * This method is of interest for testing purposes.  The returned\r\n     * Set is live and should not be modified.\r\n     * @return the Set of relative directory names that have been scanned.\r\n     */\r\n    /* package-private */ Set getScannedDirs() {\r\n        return scannedDirs;\r\n    }\r\n\r\n    /**\r\n     * Clear internal caches.\r\n     *\r\n     * @since Ant 1.6\r\n     */\r\n    private synchronized void clearCaches() {\r\n        includeNonPatterns.clear();\r\n        excludeNonPatterns.clear();\r\n        includePatterns = null;\r\n        excludePatterns = null;\r\n        areNonPatternSetsReady = false;\r\n    }\r\n\r\n    /**\r\n     * Ensure that the in|exclude &quot;patterns&quot;\r\n     * have been properly divided up.\r\n     *\r\n     * @since Ant 1.6.3\r\n     */\r\n    /* package */ synchronized void ensureNonPatternSetsReady() {\r\n        if (!areNonPatternSetsReady) {\r\n            includePatterns = fillNonPatternSet(includeNonPatterns, includes);\r\n            excludePatterns = fillNonPatternSet(excludeNonPatterns, excludes);\r\n            areNonPatternSetsReady = true;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Add all patterns that are not real patterns (do not contain\r\n     * wildcards) to the set and returns the real patterns.\r\n     *\r\n     * @param map Map to populate.\r\n     * @param patterns String[] of patterns.\r\n     * @since Ant 1.8.0\r\n     */\r\n    private TokenizedPattern[] fillNonPatternSet(Map map, String[] patterns) {\r\n        ArrayList al = new ArrayList(patterns.length);\r\n        for (int i = 0; i < patterns.length; i++) {\r\n            if (!SelectorUtils.hasWildcards(patterns[i])) {\r\n                String s = isCaseSensitive()\r\n                    ? patterns[i] : patterns[i].toUpperCase();\r\n                map.put(s, new TokenizedPath(s));\r\n            } else {\r\n                al.add(new TokenizedPattern(patterns[i]));\r\n            }\r\n        }\r\n        return (TokenizedPattern[]) al.toArray(new TokenizedPattern[al.size()]);\r\n    }\r\n\r\n    /**\r\n     * Would following the given directory cause a loop of symbolic\r\n     * links deeper than allowed?\r\n     *\r\n     * <p>Can only happen if the given directory has been seen at\r\n     * least more often than allowed during the current scan and it is\r\n     * a symbolic link and enough other occurences of the same name\r\n     * higher up are symbolic links that point to the same place.</p>\r\n     *\r\n     * @since Ant 1.8.0\r\n     */\r\n    private boolean causesIllegalSymlinkLoop(String dirName, File parent,\r\n                                             LinkedList directoryNamesFollowed) {\r\n        try {\r\n            if (directoryNamesFollowed.size() >= maxLevelsOfSymlinks\r\n                && CollectionUtils.frequency(directoryNamesFollowed, dirName)\r\n                   >= maxLevelsOfSymlinks\r\n                && SYMLINK_UTILS.isSymbolicLink(parent, dirName)) {\r\n\r\n                ArrayList files = new ArrayList();\r\n                File f = FILE_UTILS.resolveFile(parent, dirName);\r\n                String target = f.getCanonicalPath();\r\n                files.add(target);\r\n\r\n                String relPath = \"\";\r\n                for (Iterator i = directoryNamesFollowed.iterator();\r\n                     i.hasNext(); ) {\r\n                    relPath += \"../\";\r\n                    String dir = (String) i.next();\r\n                    if (dirName.equals(dir)) {\r\n                        f = FILE_UTILS.resolveFile(parent, relPath + dir);\r\n                        files.add(f.getCanonicalPath());\r\n                        if (files.size() > maxLevelsOfSymlinks\r\n                            && CollectionUtils.frequency(files, target)\r\n                                 > maxLevelsOfSymlinks) {\r\n                            return true;\r\n                        }\r\n                    }\r\n                }\r\n\r\n            }\r\n            return false;\r\n        } catch (IOException ex) {\r\n            throw new BuildException(\"Caught error while checking for\"\r\n                                     + \" symbolic links\", ex);\r\n        }\r\n    }\r\n\r\n}','Public Class','ant','org.apache.tools.ant.DirectoryScanner',1,1,0,'',NULL),(4,'M','lm','public ResolvedModuleRevision getDependency(DependencyDescriptor dd, ResolveData data) throws ParseException {\r\n	IvyContext context = IvyContext.pushNewCopyContext();\r\n	try {\r\n		ResolvedModuleRevision mr = data.getCurrentResolvedModuleRevision();\r\n		if (mr != null) {\r\n			if (shouldReturnResolvedModule(dd, mr)) {\r\n				return mr;\r\n			}\r\n		}\r\n		\r\n		if (isForce()) {\r\n			dd = dd.clone(ModuleRevisionId.newInstance(\r\n			dd.getDependencyRevisionId(), \"latest.integration\"));\r\n		}\r\n		DependencyDescriptor systemDd = dd;\r\n		DependencyDescriptor nsDd = fromSystem(dd);\r\n		context.setDependencyDescriptor(systemDd);\r\n		context.setResolveData(data);\r\n		\r\n		clearIvyAttempts();\r\n		clearArtifactAttempts();\r\n		ModuleRevisionId systemMrid = systemDd.getDependencyRevisionId();\r\n		ModuleRevisionId nsMrid = nsDd.getDependencyRevisionId();\r\n		\r\n		checkRevision(systemMrid);\r\n\r\n		boolean isDynamic = getAndCheckIsDynamic(systemMrid);\r\n\r\n		// we first search for the dependency in cache\r\n		ResolvedModuleRevision rmr = null;\r\n		rmr = findModuleInCache(systemDd, data);\r\n		if (rmr != null) {\r\n			if (rmr.getDescriptor().isDefault() && rmr.getResolver() != this) {\r\n				Message.verbose(\"\\t\" + getName() + \": found revision in cache: \" \r\n				+ systemMrid\r\n				+ \" (resolved by \" + rmr.getResolver().getName()\r\n				+ \"): but it\'s a default one, maybe we can find a better one\");\r\n			} else if (isForce() && rmr.getResolver() != this) {\r\n				Message.verbose(\"\\t\" + getName() + \": found revision in cache: \" \r\n				+ systemMrid\r\n				+ \" (resolved by \" + rmr.getResolver().getName()\r\n				+ \"): but we are in force mode, let\'s try to find one ourself\");\r\n			} else {\r\n				Message.verbose(\"\\t\" + getName() + \": revision in cache: \" + systemMrid);\r\n				return checkLatest(systemDd, checkForcedResolvedModuleRevision(rmr), data);\r\n			}\r\n		}\r\n		\r\n		checkInterrupted();\r\n		\r\n		ResolvedResource ivyRef = findIvyFileRef(nsDd, data);\r\n		checkInterrupted();\r\n\r\n		// get module descriptor\r\n		ModuleDescriptor nsMd;\r\n		ModuleDescriptor systemMd = null;\r\n		if (ivyRef == null) {\r\n			if (!isAllownomd()) {\r\n				throw new UnresolvedDependencyException(\r\n				\"\\t\" + getName() + \": no ivy file found for \" + systemMrid, false);\r\n			}\r\n			nsMd = DefaultModuleDescriptor.newDefaultInstance(nsMrid, nsDd\r\n			.getAllDependencyArtifacts());\r\n			ResolvedResource artifactRef = findFirstArtifactRef(nsMd, nsDd, data);\r\n			checkInterrupted();\r\n			if (artifactRef == null) {\r\n				throw new UnresolvedDependencyException(\"\\t\" + getName() \r\n				+ \": no ivy file nor artifact found for \" + systemMrid, false);\r\n			} else {\r\n				long lastModified = artifactRef.getLastModified();\r\n				if (lastModified != 0 && nsMd instanceof DefaultModuleDescriptor) {\r\n					((DefaultModuleDescriptor) nsMd).setLastModified(lastModified);\r\n				}\r\n				Message.verbose(\"\\t\" + getName() + \": no ivy file found for \" + systemMrid\r\n				+ \": using default data\");\r\n				if (isDynamic) {\r\n					nsMd.setResolvedModuleRevisionId(ModuleRevisionId.newInstance(nsMrid,\r\n					artifactRef.getRevision()));\r\n				}\r\n				systemMd = toSystem(nsMd);\r\n				MetadataArtifactDownloadReport madr = \r\n				new MetadataArtifactDownloadReport(systemMd.getMetadataArtifact());\r\n				madr.setDownloadStatus(DownloadStatus.NO);\r\n				madr.setSearched(true);\r\n				rmr = new ResolvedModuleRevision(this, this, systemMd, madr, isForce());\r\n			}\r\n		} else {\r\n			if (ivyRef instanceof MDResolvedResource) {\r\n				rmr = ((MDResolvedResource) ivyRef).getResolvedModuleRevision();\r\n			}\r\n			if (rmr == null) {\r\n				rmr = parse(ivyRef, systemDd, data);\r\n				if (rmr == null) {\r\n					throw new UnresolvedDependencyException();\r\n				}\r\n			}\r\n			if (!rmr.getReport().isDownloaded() \r\n					&& rmr.getReport().getLocalFile() != null) {\r\n				return checkLatest(systemDd, checkForcedResolvedModuleRevision(rmr), data);\r\n			} else {\r\n				nsMd = rmr.getDescriptor();\r\n\r\n				// check descriptor data is in sync with resource revision and names\r\n				systemMd = toSystem(nsMd);\r\n				if (isCheckconsistency()) {\r\n					checkDescriptorConsistency(systemMrid, systemMd, ivyRef);\r\n					checkDescriptorConsistency(nsMrid, nsMd, ivyRef);\r\n				} else {\r\n					if (systemMd instanceof DefaultModuleDescriptor) {\r\n						DefaultModuleDescriptor defaultMd = (DefaultModuleDescriptor) systemMd;\r\n						ModuleRevisionId revision = getRevision(ivyRef, systemMrid, systemMd);\r\n						defaultMd.setModuleRevisionId(revision);\r\n						defaultMd.setResolvedModuleRevisionId(revision);\r\n					} else {\r\n						Message.warn(\r\n						\"consistency disabled with instance of non DefaultModuleDescriptor...\"\r\n						+ \" module info can\'t be updated, so consistency check will be done\");\r\n						checkDescriptorConsistency(nsMrid, nsMd, ivyRef);\r\n						checkDescriptorConsistency(systemMrid, systemMd, ivyRef);\r\n					}\r\n				}\r\n				rmr = new ResolvedModuleRevision(\r\n				this, this, systemMd, toSystem(rmr.getReport()), isForce());\r\n			}\r\n		}\r\n\r\n		resolveAndCheckRevision(systemMd, systemMrid, ivyRef, isDynamic);\r\n		resolveAndCheckPublicationDate(systemDd, systemMd, systemMrid, data);\r\n		checkNotConvertedExclusionRule(systemMd, ivyRef, data);\r\n\r\n		cacheModuleDescriptor(systemMd, systemMrid, ivyRef, rmr);            \r\n		\r\n		return checkLatest(systemDd, checkForcedResolvedModuleRevision(rmr), data);\r\n	} catch (UnresolvedDependencyException ex) {\r\n		if (ex.getMessage().length() > 0) {\r\n			if (ex.isError()) {\r\n				Message.error(ex.getMessage());\r\n			} else {\r\n				Message.verbose(ex.getMessage());\r\n			}\r\n		}\r\n		return data.getCurrentResolvedModuleRevision();\r\n	} finally {\r\n		IvyContext.popContext();\r\n	}\r\n}','Public Method','ivy','org.apache.ivy.plugins.resolver.BasicResolver.getDependency',1,4,0,'',NULL),(5,'C','rb','/*\r\n*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*\r\n*/\r\n\r\npackage org.apache.qpid.ra;\r\n\r\nimport javax.jms.JMSException;\r\nimport javax.jms.StreamMessage;\r\n\r\nimport org.slf4j.Logger;\r\nimport org.slf4j.LoggerFactory;\r\n\r\n/**\r\n* A wrapper for a message\r\n*\r\n*/\r\npublic class QpidRAStreamMessage extends QpidRAMessage implements StreamMessage\r\n{\r\n	/** The logger */\r\n	private static final Logger _log = LoggerFactory.getLogger(QpidRAStreamMessage.class);\r\n\r\n	/**\r\n	* Create a new wrapper\r\n	* @param message the message\r\n	* @param session the session\r\n	*/\r\n	public QpidRAStreamMessage(final StreamMessage message, final QpidRASessionImpl session)\r\n	{\r\n		super(message, session);\r\n\r\n		if (_log.isTraceEnabled())\r\n		{\r\n			_log.trace(\"constructor(\" + Util.asString(message) + \", \" + session + \")\");\r\n		}\r\n	}\r\n\r\n	/**\r\n	* Read\r\n	* @return The value\r\n	* @exception JMSException Thrown if an error occurs\r\n	*/\r\n	public boolean readBoolean() throws JMSException\r\n	{\r\n		if (_log.isTraceEnabled())\r\n		{\r\n			_log.trace(\"readBoolean()\");\r\n		}\r\n\r\n		return ((StreamMessage)_message).readBoolean();\r\n	}\r\n\r\n	/**\r\n	* Read\r\n	* @return The value\r\n	* @exception JMSException Thrown if an error occurs\r\n	*/\r\n	public byte readByte() throws JMSException\r\n	{\r\n		if (_log.isTraceEnabled())\r\n		{\r\n			_log.trace(\"readByte()\");\r\n		}\r\n\r\n		return ((StreamMessage)_message).readByte();\r\n	}\r\n\r\n	/**\r\n	* Read\r\n	* @param value The value\r\n	* @return The value\r\n	* @exception JMSException Thrown if an error occurs\r\n	*/\r\n	public int readBytes(final byte[] value) throws JMSException\r\n	{\r\n		if (_log.isTraceEnabled())\r\n		{\r\n			_log.trace(\"readBytes(\" + value + \")\");\r\n		}\r\n\r\n		return ((StreamMessage)_message).readBytes(value);\r\n	}\r\n\r\n	/**\r\n	* Read\r\n	* @return The value\r\n	* @exception JMSException Thrown if an error occurs\r\n	*/\r\n	public char readChar() throws JMSException\r\n	{\r\n		if (_log.isTraceEnabled())\r\n		{\r\n			_log.trace(\"readChar()\");\r\n		}\r\n\r\n		return ((StreamMessage)_message).readChar();\r\n	}\r\n\r\n	/**\r\n	* Read\r\n	* @return The value\r\n	* @exception JMSException Thrown if an error occurs\r\n	*/\r\n	public double readDouble() throws JMSException\r\n	{\r\n		if (_log.isTraceEnabled())\r\n		{\r\n			_log.trace(\"readDouble()\");\r\n		}\r\n\r\n		return ((StreamMessage)_message).readDouble();\r\n	}\r\n\r\n	/**\r\n	* Read\r\n	* @return The value\r\n	* @exception JMSException Thrown if an error occurs\r\n	*/\r\n	public float readFloat() throws JMSException\r\n	{\r\n		if (_log.isTraceEnabled())\r\n		{\r\n			_log.trace(\"readFloat()\");\r\n		}\r\n\r\n		return ((StreamMessage)_message).readFloat();\r\n	}\r\n\r\n	/**\r\n	* Read\r\n	* @return The value\r\n	* @exception JMSException Thrown if an error occurs\r\n	*/\r\n	public int readInt() throws JMSException\r\n	{\r\n		if (_log.isTraceEnabled())\r\n		{\r\n			_log.trace(\"readInt()\");\r\n		}\r\n\r\n		return ((StreamMessage)_message).readInt();\r\n	}\r\n\r\n	/**\r\n	* Read\r\n	* @return The value\r\n	* @exception JMSException Thrown if an error occurs\r\n	*/\r\n	public long readLong() throws JMSException\r\n	{\r\n		if (_log.isTraceEnabled())\r\n		{\r\n			_log.trace(\"readLong()\");\r\n		}\r\n\r\n		return ((StreamMessage)_message).readLong();\r\n	}\r\n\r\n	/**\r\n	* Read\r\n	* @return The value\r\n	* @exception JMSException Thrown if an error occurs\r\n	*/\r\n	public Object readObject() throws JMSException\r\n	{\r\n		if (_log.isTraceEnabled())\r\n		{\r\n			_log.trace(\"readObject()\");\r\n		}\r\n\r\n		return ((StreamMessage)_message).readObject();\r\n	}\r\n\r\n	/**\r\n	* Read\r\n	* @return The value\r\n	* @exception JMSException Thrown if an error occurs\r\n	*/\r\n	public short readShort() throws JMSException\r\n	{\r\n		if (_log.isTraceEnabled())\r\n		{\r\n			_log.trace(\"readShort()\");\r\n		}\r\n\r\n		return ((StreamMessage)_message).readShort();\r\n	}\r\n\r\n	/**\r\n	* Read\r\n	* @return The value\r\n	* @exception JMSException Thrown if an error occurs\r\n	*/\r\n	public String readString() throws JMSException\r\n	{\r\n		if (_log.isTraceEnabled())\r\n		{\r\n			_log.trace(\"readString()\");\r\n		}\r\n\r\n		return ((StreamMessage)_message).readString();\r\n	}\r\n\r\n	/**\r\n	* Reset\r\n	* @exception JMSException Thrown if an error occurs\r\n	*/\r\n	public void reset() throws JMSException\r\n	{\r\n		if (_log.isTraceEnabled())\r\n		{\r\n			_log.trace(\"reset()\");\r\n		}\r\n\r\n		((StreamMessage)_message).reset();\r\n	}\r\n\r\n	/**\r\n	* Write\r\n	* @param value The value\r\n	* @exception JMSException Thrown if an error occurs\r\n	*/\r\n	public void writeBoolean(final boolean value) throws JMSException\r\n	{\r\n		if (_log.isTraceEnabled())\r\n		{\r\n			_log.trace(\"writeBoolean(\" + value + \")\");\r\n		}\r\n\r\n		((StreamMessage)_message).writeBoolean(value);\r\n	}\r\n\r\n	/**\r\n	* Write\r\n	* @param value The value\r\n	* @exception JMSException Thrown if an error occurs\r\n	*/\r\n	public void writeByte(final byte value) throws JMSException\r\n	{\r\n		if (_log.isTraceEnabled())\r\n		{\r\n			_log.trace(\"writeByte(\" + value + \")\");\r\n		}\r\n\r\n		((StreamMessage)_message).writeByte(value);\r\n	}\r\n\r\n	/**\r\n	* Write\r\n	* @param value The value\r\n	* @param offset The offset\r\n	* @param length The length\r\n	* @exception JMSException Thrown if an error occurs\r\n	*/\r\n	public void writeBytes(final byte[] value, final int offset, final int length) throws JMSException\r\n	{\r\n		if (_log.isTraceEnabled())\r\n		{\r\n			_log.trace(\"writeBytes(\" + value + \", \" + offset + \", \" + length + \")\");\r\n		}\r\n\r\n		((StreamMessage)_message).writeBytes(value, offset, length);\r\n	}\r\n\r\n	/**\r\n	* Write\r\n	* @param value The value\r\n	* @exception JMSException Thrown if an error occurs\r\n	*/\r\n	public void writeBytes(final byte[] value) throws JMSException\r\n	{\r\n		if (_log.isTraceEnabled())\r\n		{\r\n			_log.trace(\"writeBytes(\" + value + \")\");\r\n		}\r\n\r\n		((StreamMessage)_message).writeBytes(value);\r\n	}\r\n\r\n	/**\r\n	* Write\r\n	* @param value The value\r\n	* @exception JMSException Thrown if an error occurs\r\n	*/\r\n	public void writeChar(final char value) throws JMSException\r\n	{\r\n		if (_log.isTraceEnabled())\r\n		{\r\n			_log.trace(\"writeChar(\" + value + \")\");\r\n		}\r\n\r\n		((StreamMessage)_message).writeChar(value);\r\n	}\r\n\r\n	/**\r\n	* Write\r\n	* @param value The value\r\n	* @exception JMSException Thrown if an error occurs\r\n	*/\r\n	public void writeDouble(final double value) throws JMSException\r\n	{\r\n		if (_log.isTraceEnabled())\r\n		{\r\n			_log.trace(\"writeDouble(\" + value + \")\");\r\n		}\r\n\r\n		((StreamMessage)_message).writeDouble(value);\r\n	}\r\n\r\n	/**\r\n	* Write\r\n	* @param value The value\r\n	* @exception JMSException Thrown if an error occurs\r\n	*/\r\n	public void writeFloat(final float value) throws JMSException\r\n	{\r\n		if (_log.isTraceEnabled())\r\n		{\r\n			_log.trace(\"writeFloat(\" + value + \")\");\r\n		}\r\n\r\n		((StreamMessage)_message).writeFloat(value);\r\n	}\r\n\r\n	/**\r\n	* Write\r\n	* @param value The value\r\n	* @exception JMSException Thrown if an error occurs\r\n	*/\r\n	public void writeInt(final int value) throws JMSException\r\n	{\r\n		if (_log.isTraceEnabled())\r\n		{\r\n			_log.trace(\"writeInt(\" + value + \")\");\r\n		}\r\n\r\n		((StreamMessage)_message).writeInt(value);\r\n	}\r\n\r\n	/**\r\n	* Write\r\n	* @param value The value\r\n	* @exception JMSException Thrown if an error occurs\r\n	*/\r\n	public void writeLong(final long value) throws JMSException\r\n	{\r\n		if (_log.isTraceEnabled())\r\n		{\r\n			_log.trace(\"writeLong(\" + value + \")\");\r\n		}\r\n\r\n		((StreamMessage)_message).writeLong(value);\r\n	}\r\n\r\n	/**\r\n	* Write\r\n	* @param value The value\r\n	* @exception JMSException Thrown if an error occurs\r\n	*/\r\n	public void writeObject(final Object value) throws JMSException\r\n	{\r\n		if (_log.isTraceEnabled())\r\n		{\r\n			_log.trace(\"writeObject(\" + value + \")\");\r\n		}\r\n\r\n		((StreamMessage)_message).writeObject(value);\r\n	}\r\n\r\n	/**\r\n	* Write\r\n	* @param value The value\r\n	* @exception JMSException Thrown if an error occurs\r\n	*/\r\n	public void writeShort(final short value) throws JMSException\r\n	{\r\n		if (_log.isTraceEnabled())\r\n		{\r\n			_log.trace(\"writeShort(\" + value + \")\");\r\n		}\r\n\r\n		((StreamMessage)_message).writeShort(value);\r\n	}\r\n\r\n	/**\r\n	* Write\r\n	* @param value The value\r\n	* @exception JMSException Thrown if an error occurs\r\n	*/\r\n	public void writeString(final String value) throws JMSException\r\n	{\r\n		if (_log.isTraceEnabled())\r\n		{\r\n			_log.trace(\"writeString(\" + value + \")\");\r\n		}\r\n\r\n		((StreamMessage)_message).writeString(value);\r\n	}\r\n}','Public Class','qpid','org.apache.qpid.ra.QpidRAStreamMessage',2,2,0,'/*\r\n*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*\r\n*/\r\n\r\npackage org.apache.qpid.ra;\r\n\r\nimport java.util.Enumeration;\r\n\r\nimport javax.jms.Destination;\r\nimport javax.jms.JMSException;\r\nimport javax.jms.Message;\r\n\r\nimport org.slf4j.Logger;\r\nimport org.slf4j.LoggerFactory;\r\n\r\n/**\r\n* A wrapper for a message\r\n*/\r\npublic class QpidRAMessage implements Message\r\n{\r\n	/** The logger */\r\n	private static final Logger _log = LoggerFactory.getLogger(QpidRAMessage.class);\r\n\r\n	/** The message */\r\n	protected Message _message;\r\n\r\n	/** The session */\r\n	protected QpidRASessionImpl _session;\r\n\r\n	/**\r\n	* Create a new wrapper\r\n	* @param message the message\r\n	* @param session the session\r\n	*/\r\n	public QpidRAMessage(final Message message, final QpidRASessionImpl session)\r\n	{\r\n		if (_log.isTraceEnabled())\r\n		{\r\n			_log.trace(\"constructor(\" + Util.asString(message) + \", \" + session + \")\");\r\n		}\r\n\r\n		this._message = message;\r\n		this._session = session;\r\n	}\r\n\r\n	/**\r\n	* Acknowledge\r\n	* @exception JMSException Thrown if an error occurs\r\n	*/\r\n	public void acknowledge() throws JMSException\r\n	{\r\n		if (_log.isTraceEnabled())\r\n		{\r\n			_log.trace(\"acknowledge()\");\r\n		}\r\n\r\n		_session.getSessionInternal(); // Check for closed\r\n		_message.acknowledge();\r\n	}\r\n\r\n	/**\r\n	* Clear body\r\n	* @exception JMSException Thrown if an error occurs\r\n	*/\r\n	public void clearBody() throws JMSException\r\n	{\r\n		if (_log.isTraceEnabled())\r\n		{\r\n			_log.trace(\"clearBody()\");\r\n		}\r\n\r\n		_message.clearBody();\r\n	}\r\n\r\n	/**\r\n	* Clear properties\r\n	* @exception JMSException Thrown if an error occurs\r\n	*/\r\n	public void clearProperties() throws JMSException\r\n	{\r\n		if (_log.isTraceEnabled())\r\n		{\r\n			_log.trace(\"clearProperties()\");\r\n		}\r\n\r\n		_message.clearProperties();\r\n	}\r\n\r\n	/**\r\n	* Get property\r\n	* @param name The name\r\n	* @return The value\r\n	* @exception JMSException Thrown if an error occurs\r\n	*/\r\n	public boolean getBooleanProperty(final String name) throws JMSException\r\n	{\r\n		if (_log.isTraceEnabled())\r\n		{\r\n			_log.trace(\"getBooleanProperty(\" + name + \")\");\r\n		}\r\n\r\n		return _message.getBooleanProperty(name);\r\n	}\r\n\r\n	/**\r\n	* Get property\r\n	* @param name The name\r\n	* @return The value\r\n	* @exception JMSException Thrown if an error occurs\r\n	*/\r\n	public byte getByteProperty(final String name) throws JMSException\r\n	{\r\n		if (_log.isTraceEnabled())\r\n		{\r\n			_log.trace(\"getByteProperty(\" + name + \")\");\r\n		}\r\n\r\n		return _message.getByteProperty(name);\r\n	}\r\n\r\n	/**\r\n	* Get property\r\n	* @param name The name\r\n	* @return The value\r\n	* @exception JMSException Thrown if an error occurs\r\n	*/\r\n	public double getDoubleProperty(final String name) throws JMSException\r\n	{\r\n		if (_log.isTraceEnabled())\r\n		{\r\n			_log.trace(\"getDoubleProperty(\" + name + \")\");\r\n		}\r\n\r\n		return _message.getDoubleProperty(name);\r\n	}\r\n\r\n	/**\r\n	* Get property\r\n	* @param name The name\r\n	* @return The value\r\n	* @exception JMSException Thrown if an error occurs\r\n	*/\r\n	public float getFloatProperty(final String name) throws JMSException\r\n	{\r\n		if (_log.isTraceEnabled())\r\n		{\r\n			_log.trace(\"getFloatProperty(\" + name + \")\");\r\n		}\r\n\r\n		return _message.getFloatProperty(name);\r\n	}\r\n\r\n	/**\r\n	* Get property\r\n	* @param name The name\r\n	* @return The value\r\n	* @exception JMSException Thrown if an error occurs\r\n	*/\r\n	public int getIntProperty(final String name) throws JMSException\r\n	{\r\n		if (_log.isTraceEnabled())\r\n		{\r\n			_log.trace(\"getIntProperty(\" + name + \")\");\r\n		}\r\n\r\n		return _message.getIntProperty(name);\r\n	}\r\n\r\n	/**\r\n	* Get correlation id\r\n	* @return The value\r\n	* @exception JMSException Thrown if an error occurs\r\n	*/\r\n	public String getJMSCorrelationID() throws JMSException\r\n	{\r\n		if (_log.isTraceEnabled())\r\n		{\r\n			_log.trace(\"getJMSCorrelationID()\");\r\n		}\r\n\r\n		return _message.getJMSCorrelationID();\r\n	}\r\n\r\n	/**\r\n	* Get correlation id\r\n	* @return The value\r\n	* @exception JMSException Thrown if an error occurs\r\n	*/\r\n	public byte[] getJMSCorrelationIDAsBytes() throws JMSException\r\n	{\r\n		if (_log.isTraceEnabled())\r\n		{\r\n			_log.trace(\"getJMSCorrelationIDAsBytes()\");\r\n		}\r\n\r\n		return _message.getJMSCorrelationIDAsBytes();\r\n	}\r\n\r\n	/**\r\n	* Get delivery mode\r\n	* @return The value\r\n	* @exception JMSException Thrown if an error occurs\r\n	*/\r\n	public int getJMSDeliveryMode() throws JMSException\r\n	{\r\n		if (_log.isTraceEnabled())\r\n		{\r\n			_log.trace(\"getJMSDeliveryMode()\");\r\n		}\r\n\r\n		return _message.getJMSDeliveryMode();\r\n	}\r\n\r\n	/**\r\n	* Get destination\r\n	* @return The value\r\n	* @exception JMSException Thrown if an error occurs\r\n	*/\r\n	public Destination getJMSDestination() throws JMSException\r\n	{\r\n		if (_log.isTraceEnabled())\r\n		{\r\n			_log.trace(\"getJMSDestination()\");\r\n		}\r\n\r\n		return _message.getJMSDestination();\r\n	}\r\n\r\n	/**\r\n	* Get expiration\r\n	* @return The value\r\n	* @exception JMSException Thrown if an error occurs\r\n	*/\r\n	public long getJMSExpiration() throws JMSException\r\n	{\r\n		if (_log.isTraceEnabled())\r\n		{\r\n			_log.trace(\"getJMSExpiration()\");\r\n		}\r\n\r\n		return _message.getJMSExpiration();\r\n	}\r\n\r\n	/**\r\n	* Get message id\r\n	* @return The value\r\n	* @exception JMSException Thrown if an error occurs\r\n	*/\r\n	public String getJMSMessageID() throws JMSException\r\n	{\r\n		if (_log.isTraceEnabled())\r\n		{\r\n			_log.trace(\"getJMSMessageID()\");\r\n		}\r\n\r\n		return _message.getJMSMessageID();\r\n	}\r\n\r\n	/**\r\n	* Get priority\r\n	* @return The value\r\n	* @exception JMSException Thrown if an error occurs\r\n	*/\r\n	public int getJMSPriority() throws JMSException\r\n	{\r\n		if (_log.isTraceEnabled())\r\n		{\r\n			_log.trace(\"getJMSPriority()\");\r\n		}\r\n\r\n		return _message.getJMSPriority();\r\n	}\r\n\r\n	/**\r\n	* Get redelivered status\r\n	* @return The value\r\n	* @exception JMSException Thrown if an error occurs\r\n	*/\r\n	public boolean getJMSRedelivered() throws JMSException\r\n	{\r\n		if (_log.isTraceEnabled())\r\n		{\r\n			_log.trace(\"getJMSRedelivered()\");\r\n		}\r\n\r\n		return _message.getJMSRedelivered();\r\n	}\r\n\r\n	/**\r\n	* Get reply to destination\r\n	* @return The value\r\n	* @exception JMSException Thrown if an error occurs\r\n	*/\r\n	public Destination getJMSReplyTo() throws JMSException\r\n	{\r\n		if (_log.isTraceEnabled())\r\n		{\r\n			_log.trace(\"getJMSReplyTo()\");\r\n		}\r\n\r\n		return _message.getJMSReplyTo();\r\n	}\r\n\r\n	/**\r\n	* Get timestamp\r\n	* @return The value\r\n	* @exception JMSException Thrown if an error occurs\r\n	*/\r\n	public long getJMSTimestamp() throws JMSException\r\n	{\r\n		if (_log.isTraceEnabled())\r\n		{\r\n			_log.trace(\"getJMSTimestamp()\");\r\n		}\r\n\r\n		return _message.getJMSTimestamp();\r\n	}\r\n\r\n	/**\r\n	* Get type\r\n	* @return The value\r\n	* @exception JMSException Thrown if an error occurs\r\n	*/\r\n	public String getJMSType() throws JMSException\r\n	{\r\n		if (_log.isTraceEnabled())\r\n		{\r\n			_log.trace(\"getJMSType()\");\r\n		}\r\n\r\n		return _message.getJMSType();\r\n	}\r\n\r\n	/**\r\n	* Get property\r\n	* @param name The name\r\n	* @return The value\r\n	* @exception JMSException Thrown if an error occurs\r\n	*/\r\n	public long getLongProperty(final String name) throws JMSException\r\n	{\r\n		if (_log.isTraceEnabled())\r\n		{\r\n			_log.trace(\"getLongProperty(\" + name + \")\");\r\n		}\r\n\r\n		return _message.getLongProperty(name);\r\n	}\r\n\r\n	/**\r\n	* Get property\r\n	* @param name The name\r\n	* @return The value\r\n	* @exception JMSException Thrown if an error occurs\r\n	*/\r\n	public Object getObjectProperty(final String name) throws JMSException\r\n	{\r\n		if (_log.isTraceEnabled())\r\n		{\r\n			_log.trace(\"getObjectProperty(\" + name + \")\");\r\n		}\r\n\r\n		return _message.getObjectProperty(name);\r\n	}\r\n\r\n	/**\r\n	* Get property names\r\n	* @return The values\r\n	* @exception JMSException Thrown if an error occurs\r\n	*/\r\n	public Enumeration<?> getPropertyNames() throws JMSException\r\n	{\r\n		if (_log.isTraceEnabled())\r\n		{\r\n			_log.trace(\"getPropertyNames()\");\r\n		}\r\n\r\n		return _message.getPropertyNames();\r\n	}\r\n\r\n	/**\r\n	* Get property\r\n	* @param name The name\r\n	* @return The value\r\n	* @exception JMSException Thrown if an error occurs\r\n	*/\r\n	public short getShortProperty(final String name) throws JMSException\r\n	{\r\n		if (_log.isTraceEnabled())\r\n		{\r\n			_log.trace(\"getShortProperty(\" + name + \")\");\r\n		}\r\n\r\n		return _message.getShortProperty(name);\r\n	}\r\n\r\n	/**\r\n	* Get property\r\n	* @param name The name\r\n	* @return The value\r\n	* @exception JMSException Thrown if an error occurs\r\n	*/\r\n	public String getStringProperty(final String name) throws JMSException\r\n	{\r\n		if (_log.isTraceEnabled())\r\n		{\r\n			_log.trace(\"getStringProperty(\" + name + \")\");\r\n		}\r\n\r\n		return _message.getStringProperty(name);\r\n	}\r\n\r\n	/**\r\n	* Do property exist\r\n	* @param name The name\r\n	* @return The value\r\n	* @exception JMSException Thrown if an error occurs\r\n	*/\r\n	public boolean propertyExists(final String name) throws JMSException\r\n	{\r\n		if (_log.isTraceEnabled())\r\n		{\r\n			_log.trace(\"propertyExists(\" + name + \")\");\r\n		}\r\n\r\n		return _message.propertyExists(name);\r\n	}\r\n\r\n	/**\r\n	* Set property\r\n	* @param name The name\r\n	* @param value The value\r\n	* @exception JMSException Thrown if an error occurs\r\n	*/\r\n	public void setBooleanProperty(final String name, final boolean value) throws JMSException\r\n	{\r\n		if (_log.isTraceEnabled())\r\n		{\r\n			_log.trace(\"setBooleanProperty(\" + name + \", \" + value + \")\");\r\n		}\r\n\r\n		_message.setBooleanProperty(name, value);\r\n	}\r\n\r\n	/**\r\n	* Set property\r\n	* @param name The name\r\n	* @param value The value\r\n	* @exception JMSException Thrown if an error occurs\r\n	*/\r\n	public void setByteProperty(final String name, final byte value) throws JMSException\r\n	{\r\n		if (_log.isTraceEnabled())\r\n		{\r\n			_log.trace(\"setByteProperty(\" + name + \", \" + value + \")\");\r\n		}\r\n\r\n		_message.setByteProperty(name, value);\r\n	}\r\n\r\n	/**\r\n	* Set property\r\n	* @param name The name\r\n	* @param value The value\r\n	* @exception JMSException Thrown if an error occurs\r\n	*/\r\n	public void setDoubleProperty(final String name, final double value) throws JMSException\r\n	{\r\n		if (_log.isTraceEnabled())\r\n		{\r\n			_log.trace(\"setDoubleProperty(\" + name + \", \" + value + \")\");\r\n		}\r\n\r\n		_message.setDoubleProperty(name, value);\r\n	}\r\n\r\n	/**\r\n	* Set property\r\n	* @param name The name\r\n	* @param value The value\r\n	* @exception JMSException Thrown if an error occurs\r\n	*/\r\n	public void setFloatProperty(final String name, final float value) throws JMSException\r\n	{\r\n		if (_log.isTraceEnabled())\r\n		{\r\n			_log.trace(\"setFloatProperty(\" + name + \", \" + value + \")\");\r\n		}\r\n\r\n		_message.setFloatProperty(name, value);\r\n	}\r\n\r\n	/**\r\n	* Set property\r\n	* @param name The name\r\n	* @param value The value\r\n	* @exception JMSException Thrown if an error occurs\r\n	*/\r\n	public void setIntProperty(final String name, final int value) throws JMSException\r\n	{\r\n		if (_log.isTraceEnabled())\r\n		{\r\n			_log.trace(\"setIntProperty(\" + name + \", \" + value + \")\");\r\n		}\r\n\r\n		_message.setIntProperty(name, value);\r\n	}\r\n\r\n	/**\r\n	* Set correlation id\r\n	* @param correlationID The value\r\n	* @exception JMSException Thrown if an error occurs\r\n	*/\r\n	public void setJMSCorrelationID(final String correlationID) throws JMSException\r\n	{\r\n		if (_log.isTraceEnabled())\r\n		{\r\n			_log.trace(\"setJMSCorrelationID(\" + correlationID + \")\");\r\n		}\r\n\r\n		_message.setJMSCorrelationID(correlationID);\r\n	}\r\n\r\n	/**\r\n	* Set correlation id\r\n	* @param correlationID The value\r\n	* @exception JMSException Thrown if an error occurs\r\n	*/\r\n	public void setJMSCorrelationIDAsBytes(final byte[] correlationID) throws JMSException\r\n	{\r\n		if (_log.isTraceEnabled())\r\n		{\r\n			_log.trace(\"setJMSCorrelationIDAsBytes(\" + correlationID + \")\");\r\n		}\r\n\r\n		_message.setJMSCorrelationIDAsBytes(correlationID);\r\n	}\r\n\r\n	/**\r\n	* Set delivery mode\r\n	* @param deliveryMode The value\r\n	* @exception JMSException Thrown if an error occurs\r\n	*/\r\n	public void setJMSDeliveryMode(final int deliveryMode) throws JMSException\r\n	{\r\n		if (_log.isTraceEnabled())\r\n		{\r\n			_log.trace(\"setJMSDeliveryMode(\" + deliveryMode + \")\");\r\n		}\r\n\r\n		_message.setJMSDeliveryMode(deliveryMode);\r\n	}\r\n\r\n	/**\r\n	* Set destination\r\n	* @param destination The value\r\n	* @exception JMSException Thrown if an error occurs\r\n	*/\r\n	public void setJMSDestination(final Destination destination) throws JMSException\r\n	{\r\n		if (_log.isTraceEnabled())\r\n		{\r\n			_log.trace(\"setJMSDestination(\" + destination + \")\");\r\n		}\r\n\r\n		_message.setJMSDestination(destination);\r\n	}\r\n\r\n	/**\r\n	* Set expiration\r\n	* @param expiration The value\r\n	* @exception JMSException Thrown if an error occurs\r\n	*/\r\n	public void setJMSExpiration(final long expiration) throws JMSException\r\n	{\r\n		if (_log.isTraceEnabled())\r\n		{\r\n			_log.trace(\"setJMSExpiration(\" + expiration + \")\");\r\n		}\r\n\r\n		_message.setJMSExpiration(expiration);\r\n	}\r\n\r\n	/**\r\n	* Set message id\r\n	* @param id The value\r\n	* @exception JMSException Thrown if an error occurs\r\n	*/\r\n	public void setJMSMessageID(final String id) throws JMSException\r\n	{\r\n		if (_log.isTraceEnabled())\r\n		{\r\n			_log.trace(\"setJMSMessageID(\" + id + \")\");\r\n		}\r\n\r\n		_message.setJMSMessageID(id);\r\n	}\r\n\r\n	/**\r\n	* Set priority\r\n	* @param priority The value\r\n	* @exception JMSException Thrown if an error occurs\r\n	*/\r\n	public void setJMSPriority(final int priority) throws JMSException\r\n	{\r\n		if (_log.isTraceEnabled())\r\n		{\r\n			_log.trace(\"setJMSPriority(\" + priority + \")\");\r\n		}\r\n\r\n		_message.setJMSPriority(priority);\r\n	}\r\n\r\n	/**\r\n	* Set redelivered status\r\n	* @param redelivered The value\r\n	* @exception JMSException Thrown if an error occurs\r\n	*/\r\n	public void setJMSRedelivered(final boolean redelivered) throws JMSException\r\n	{\r\n		if (_log.isTraceEnabled())\r\n		{\r\n			_log.trace(\"setJMSRedelivered(\" + redelivered + \")\");\r\n		}\r\n\r\n		_message.setJMSRedelivered(redelivered);\r\n	}\r\n\r\n	/**\r\n	* Set reply to\r\n	* @param replyTo The value\r\n	* @exception JMSException Thrown if an error occurs\r\n	*/\r\n	public void setJMSReplyTo(final Destination replyTo) throws JMSException\r\n	{\r\n		if (_log.isTraceEnabled())\r\n		{\r\n			_log.trace(\"setJMSReplyTo(\" + replyTo + \")\");\r\n		}\r\n\r\n		_message.setJMSReplyTo(replyTo);\r\n	}\r\n\r\n	/**\r\n	* Set timestamp\r\n	* @param timestamp The value\r\n	* @exception JMSException Thrown if an error occurs\r\n	*/\r\n	public void setJMSTimestamp(final long timestamp) throws JMSException\r\n	{\r\n		if (_log.isTraceEnabled())\r\n		{\r\n			_log.trace(\"setJMSTimestamp(\" + timestamp + \")\");\r\n		}\r\n\r\n		_message.setJMSTimestamp(timestamp);\r\n	}\r\n\r\n	/**\r\n	* Set type\r\n	* @param type The value\r\n	* @exception JMSException Thrown if an error occurs\r\n	*/\r\n	public void setJMSType(final String type) throws JMSException\r\n	{\r\n		if (_log.isTraceEnabled())\r\n		{\r\n			_log.trace(\"setJMSType(\" + type + \")\");\r\n		}\r\n\r\n		_message.setJMSType(type);\r\n	}\r\n\r\n	/**\r\n	* Set property\r\n	* @param name The name\r\n	* @param value The value\r\n	* @exception JMSException Thrown if an error occurs\r\n	*/\r\n	public void setLongProperty(final String name, final long value) throws JMSException\r\n	{\r\n		if (_log.isTraceEnabled())\r\n		{\r\n			_log.trace(\"setLongProperty(\" + name + \", \" + value + \")\");\r\n		}\r\n\r\n		_message.setLongProperty(name, value);\r\n	}\r\n\r\n	/**\r\n	* Set property\r\n	* @param name The name\r\n	* @param value The value\r\n	* @exception JMSException Thrown if an error occurs\r\n	*/\r\n	public void setObjectProperty(final String name, final Object value) throws JMSException\r\n	{\r\n		if (_log.isTraceEnabled())\r\n		{\r\n			_log.trace(\"setObjectProperty(\" + name + \", \" + value + \")\");\r\n		}\r\n\r\n		_message.setObjectProperty(name, value);\r\n	}\r\n\r\n	/**\r\n	* Set property\r\n	* @param name The name\r\n	* @param value The value\r\n	* @exception JMSException Thrown if an error occurs\r\n	*/\r\n	public void setShortProperty(final String name, final short value) throws JMSException\r\n	{\r\n		if (_log.isTraceEnabled())\r\n		{\r\n			_log.trace(\"setShortProperty(\" + name + \", \" + value + \")\");\r\n		}\r\n\r\n		_message.setShortProperty(name, value);\r\n	}\r\n\r\n	/**\r\n	* Set property\r\n	* @param name The name\r\n	* @param value The value\r\n	* @exception JMSException Thrown if an error occurs\r\n	*/\r\n	public void setStringProperty(final String name, final String value) throws JMSException\r\n	{\r\n		if (_log.isTraceEnabled())\r\n		{\r\n			_log.trace(\"setStringProperty(\" + name + \", \" + value + \")\");\r\n		}\r\n\r\n		_message.setStringProperty(name, value);\r\n	}\r\n\r\n	/**\r\n	* Return the hash code\r\n	* @return The hash code\r\n	*/\r\n	@Override\r\n	public int hashCode()\r\n	{\r\n		return _message.hashCode();\r\n	}\r\n\r\n	/**\r\n	* Check for equality\r\n	* @param object The other object\r\n	* @return True / false\r\n	*/\r\n	@Override\r\n	public boolean equals(final Object object)\r\n	{\r\n		if (object != null && object instanceof QpidRAMessage)\r\n		{\r\n			return _message.equals(((QpidRAMessage)object)._message);\r\n		}\r\n		else\r\n		{\r\n			return _message.equals(object);\r\n		}\r\n	}\r\n}','org.apache.qpid.ra.QpidRAMessage'),(6,'M','lm','@Override\r\n    public boolean check(List<LogicalOperator> nodes) throws OptimizerException {\r\n        try {\r\n            LOFilter filter = (LOFilter) getOperator(nodes);\r\n            List<LogicalOperator> predecessors = (mPlan.getPredecessors(filter) == null ? null\r\n                    : new ArrayList<LogicalOperator>(mPlan\r\n                            .getPredecessors(filter)));\r\n\r\n            // if there are no predecessors return false\r\n            if (predecessors == null) {\r\n                return false;\r\n            }\r\n\r\n            // if the filter has no predecessors or more than one predecessor\r\n            // return false\r\n            if (predecessors.size() == 0 || predecessors.size() > 1) {\r\n                return false;\r\n            }\r\n                \r\n            LogicalOperator predecessor = predecessors.get(0);\r\n\r\n            // if the predecessor is one of LOLoad/LOStore/LOStream/LOLimit/LONative\r\n            // return false\r\n            if (predecessor instanceof LOLoad || predecessor instanceof LOStore\r\n                    || predecessor instanceof LOStream\r\n                    || predecessor instanceof LOLimit \r\n                    || predecessor instanceof LONative) {\r\n                return false;\r\n            }\r\n            \r\n            // TODO\r\n            // for now filters cannot be combined\r\n            // remove this check when filters can be combined\r\n            if (predecessor instanceof LOFilter)\r\n                return false;\r\n\r\n            // TODO\r\n            // same rule as filters\r\n            if (predecessor instanceof LOSplitOutput) {\r\n                return false;\r\n            }\r\n            if (predecessor instanceof LOSplit) {\r\n                return false;\r\n            }\r\n\r\n            UDFFinder udfFinder = new UDFFinder(filter.getComparisonPlan());\r\n            udfFinder.visit();\r\n\r\n            // if the filter\'s inner plan contains any UDF then return false\r\n            if (udfFinder.foundAnyUDF()) {\r\n                return false;\r\n            }\r\n\r\n            CastFinder castFinder = new CastFinder(filter.getComparisonPlan());\r\n            castFinder.visit();\r\n\r\n            // if the filter\'s inner plan contains any casts then return false\r\n            if (castFinder.foundAnyCast()) {\r\n                return false;\r\n            }\r\n\r\n            List<RequiredFields> filterRequiredFields = filter\r\n                    .getRequiredFields();\r\n            if (filterRequiredFields == null) {\r\n                return false;\r\n            }\r\n            RequiredFields requiredField = filterRequiredFields.get(0);\r\n\r\n            // the filter\'s conditions contain constant expression\r\n            // return false\r\n            if (requiredField.needNoFields()) {\r\n                return false;\r\n            }\r\n\r\n            // if the predecessor is a multi-input operator then detailed\r\n            // checks are required\r\n            if (predecessor instanceof LOCross\r\n                    || predecessor instanceof LOUnion\r\n                    || predecessor instanceof LOCogroup\r\n                    || predecessor instanceof LOJoin) {\r\n\r\n                // check if the filter\'s required fields in conjunction with the\r\n                // predecessor\'s projection map. If the filter needs more than\r\n                // one input then the filter\'s expressions have to be split\r\n\r\n                List<LogicalOperator> grandParents = mPlan\r\n                        .getPredecessors(predecessor);\r\n\r\n                // if the predecessor does not have predecessors return false\r\n                if (grandParents == null || grandParents.size() == 0) {\r\n                    return false;\r\n                }\r\n                \r\n                // check if the predecessor is a group by\r\n                if (grandParents.size() == 1) {\r\n                    if (predecessor instanceof LOCogroup) {\r\n                        mSwap = true;\r\n                        return true;\r\n                    } else {\r\n                        // only a group by can have a single input\r\n                        return false;\r\n                    }\r\n                }\r\n\r\n                if (requiredField.needAllFields()) {\r\n                    return false;\r\n                }\r\n\r\n                Pair<Boolean, Set<Integer>> mappingResult = isRequiredFieldMapped(requiredField, predecessor.getProjectionMap());\r\n                boolean mapped = mappingResult.first;\r\n                Set<Integer> grandParentIndexes = mappingResult.second;\r\n                if (!mapped) {\r\n                    return false;\r\n                }\r\n                \r\n                // TODO\r\n                // the filter\'s conditions requires more than one input of its\r\n                // predecessor\r\n                // when the filter\'s conditions are splittable return true\r\n                if ((grandParentIndexes == null)\r\n                        || (grandParentIndexes.size() == 0)\r\n                        || (grandParentIndexes.size() > 1)) {\r\n                    return false;\r\n                }\r\n\r\n                if (predecessor instanceof LOCogroup) {\r\n                    // check for outer\r\n                    if (isAnyOuter((LOCogroup) predecessor)) {\r\n                        return false;\r\n                    }\r\n                }\r\n                \r\n                mPushBeforeInput = grandParentIndexes.iterator().next();\r\n                \r\n                if (predecessor instanceof LOJoin) {\r\n                    boolean otherBranchContainOuter = false;\r\n                    boolean sawInner = false;\r\n                    for (int i=0;i<=mPlan.getSuccessors(predecessor).size();i++) {\r\n                        // We do not push filter if any other branch is outer\r\n                        // See PIG-1289\r\n                        // Also in LOJoin, innerFlag==true indicate that branch is the outer join side\r\n                        // which has the exact opposite semantics\r\n                        // If all innerFlag is true, that implies a regular join\r\n                        // If all innerFlag is false, means a outer join, in this case, we can not push up filter for any path (See PIG-1507)\r\n                        if (i!=mPushBeforeInput && ((LOJoin)predecessor).getInnerFlags()[i]) {\r\n                            otherBranchContainOuter = true;\r\n                        }\r\n                        if (((LOJoin)predecessor).getInnerFlags()[i]==false) {\r\n                            sawInner = true;\r\n                        }\r\n                    }\r\n                    if (!otherBranchContainOuter && ((LOJoin)predecessor).getInnerFlags()[mPushBeforeInput]==false) // all innerFlag is false, implies an outer join\r\n                    {\r\n                        mPushBeforeInput = -1;\r\n                        return false;\r\n                    }\r\n                    if (otherBranchContainOuter && sawInner) // If it is not a regular join and the path we push is on inner side\r\n                    {\r\n                        mPushBeforeInput = -1;\r\n                        return false;\r\n                    }\r\n                }\r\n                \r\n                mPushBefore = true;\r\n                return true;\r\n\r\n            } else if (predecessor instanceof LOForEach) {\r\n\r\n                LOForEach loForEach = (LOForEach) predecessor;\r\n                List<Boolean> mFlatten = loForEach.getFlatten();\r\n                boolean hasFlatten = false;\r\n                for (Boolean b : mFlatten) {\r\n                    if (b.equals(true)) {\r\n                        hasFlatten = true;\r\n                    }\r\n                }\r\n\r\n                // TODO\r\n                // A better check is to examine each column in the filter\'s\r\n                // required fields. If the column is the result of a flatten\r\n                // then\r\n                // return false else return true\r\n\r\n                // for now if the foreach has a flatten then return false\r\n                if (hasFlatten) {\r\n                    return false;\r\n                }\r\n\r\n                Pair<Boolean, Set<Integer>> mappingResult = isRequiredFieldMapped(requiredField, predecessor.getProjectionMap());\r\n                boolean mapped = mappingResult.first;\r\n                \r\n                // Check if it is a direct mapping, that is, project optionally followed by cast, so if project->project, it is not\r\n                // considered as a mapping\r\n                for (Pair<Integer, Integer> pair : requiredField.getFields())\r\n                {\r\n                    if (!isFieldSimple(loForEach.getForEachPlans().get(pair.second)))\r\n                    {\r\n                        mapped = false;\r\n                        break;\r\n                    }\r\n                }\r\n                \r\n                if (!mapped) {\r\n                    return false;\r\n                }\r\n            }\r\n\r\n            mSwap = true;\r\n            return true;\r\n        } catch (OptimizerException oe) {\r\n            throw oe;\r\n        } catch (Exception e) {\r\n            int errCode = 2149;\r\n            String msg = \"Internal error while trying to check if filters can be pushed up.\";\r\n            throw new OptimizerException(msg, errCode, PigException.BUG, e);\r\n        }\r\n    }','Public Method','pig','org.apache.pig.impl.logicalLayer.optimizer.PushUpFilter.check',2,8,0,'',NULL),(7,'C','rb','/*\r\n*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*\r\n*/\r\npackage org.apache.qpid.ra.inflow;\r\n\r\nimport java.io.Serializable;\r\n\r\nimport javax.jms.Session;\r\nimport javax.resource.ResourceException;\r\nimport javax.resource.spi.ActivationSpec;\r\nimport javax.resource.spi.InvalidPropertyException;\r\nimport javax.resource.spi.ResourceAdapter;\r\n\r\nimport org.apache.qpid.ra.ConnectionFactoryProperties;\r\nimport org.apache.qpid.ra.QpidResourceAdapter;\r\nimport org.slf4j.Logger;\r\nimport org.slf4j.LoggerFactory;\r\n\r\n/**\r\n* The activation spec\r\n* These properties are set on the MDB ActivactionProperties\r\n*\r\n*/\r\npublic class QpidActivationSpec extends ConnectionFactoryProperties implements ActivationSpec, Serializable\r\n{\r\n	private static final long serialVersionUID = 7379131936083146158L;\r\n\r\n	private static final int DEFAULT_MAX_SESSION = 15;\r\n\r\n	/** The logger */\r\n	private static final transient Logger _log = LoggerFactory.getLogger(QpidActivationSpec.class);\r\n\r\n	/** The resource adapter */\r\n	private QpidResourceAdapter _ra;\r\n\r\n	/** The destination */\r\n	private String _destination;\r\n\r\n	/** The destination type */\r\n	private String _destinationType;\r\n\r\n	/** The message selector */\r\n	private String _messageSelector;\r\n\r\n	/** The acknowledgement mode */\r\n	private int _acknowledgeMode;\r\n\r\n	/** The subscription durability */\r\n	private boolean _subscriptionDurability;\r\n\r\n	/** The subscription name */\r\n	private String _subscriptionName;\r\n\r\n	/** The maximum number of sessions */\r\n	private Integer _maxSession;\r\n\r\n	/** Transaction timeout */\r\n	private Integer _transactionTimeout;\r\n\r\n	/** prefetch low */\r\n	private Integer _prefetchLow;\r\n\r\n	/** prefetch high */\r\n	private Integer _prefetchHigh;\r\n\r\n	private boolean _useJNDI = true;\r\n\r\n	// undefined by default, default is specified at the RA level in QpidRAProperties\r\n	private Integer _setupAttempts;\r\n\r\n	// undefined by default, default is specified at the RA level in QpidRAProperties\r\n	private Long _setupInterval;\r\n\r\n	private Boolean _useConnectionPerHandler;\r\n\r\n	/**\r\n	* Constructor\r\n	*/\r\n	public QpidActivationSpec()\r\n	{\r\n		if (_log.isTraceEnabled())\r\n		{\r\n			_log.trace(\"constructor()\");\r\n		}\r\n\r\n		_acknowledgeMode = Session.AUTO_ACKNOWLEDGE;\r\n		_maxSession = DEFAULT_MAX_SESSION;\r\n		_transactionTimeout = 0;\r\n	}\r\n\r\n	/**\r\n	* Get the resource adapter\r\n	* @return The resource adapter\r\n	*/\r\n	public ResourceAdapter getResourceAdapter()\r\n	{\r\n		if (_log.isTraceEnabled())\r\n		{\r\n			_log.trace(\"getResourceAdapter()\");\r\n		}\r\n\r\n		return _ra;\r\n	}\r\n\r\n	/**\r\n	* @return the useJNDI\r\n	*/\r\n	public boolean isUseJNDI()\r\n	{\r\n		return _useJNDI;\r\n	}\r\n\r\n	/**\r\n	* @param value the useJNDI to set\r\n	*/\r\n	public void setUseJNDI(final boolean value)\r\n	{\r\n		_useJNDI = value;\r\n	}\r\n\r\n	/**\r\n	* Set the resource adapter\r\n	* @param ra The resource adapter\r\n	* @exception ResourceException Thrown if incorrect resource adapter\r\n	*/\r\n	public void setResourceAdapter(final ResourceAdapter ra) throws ResourceException\r\n	{\r\n		if (_log.isTraceEnabled())\r\n		{\r\n			_log.trace(\"setResourceAdapter(\" + ra + \")\");\r\n		}\r\n\r\n		if (ra == null || !(ra instanceof QpidResourceAdapter))\r\n		{\r\n			throw new ResourceException(\"Resource adapter is \" + ra);\r\n		}\r\n\r\n		this._ra = (QpidResourceAdapter)ra;\r\n	}\r\n\r\n	/**\r\n	* Get the destination\r\n	* @return The value\r\n	*/\r\n	public String getDestination()\r\n	{\r\n		if (_log.isTraceEnabled())\r\n		{\r\n			_log.trace(\"getDestination()\");\r\n		}\r\n\r\n		return _destination;\r\n	}\r\n\r\n	/**\r\n	* Set the destination\r\n	* @param value The value\r\n	*/\r\n	public void setDestination(final String value)\r\n	{\r\n		if (_log.isTraceEnabled())\r\n		{\r\n			_log.trace(\"setDestination(\" + value + \")\");\r\n		}\r\n\r\n		_destination = value;\r\n	}\r\n\r\n	/**\r\n	* Get the destination type\r\n	* @return The value\r\n	*/\r\n	public String getDestinationType()\r\n	{\r\n		if (_log.isTraceEnabled())\r\n		{\r\n			_log.trace(\"getDestinationType()\");\r\n		}\r\n\r\n		return _destinationType;\r\n	}\r\n\r\n	/**\r\n	* Set the destination type\r\n	* @param value The value\r\n	*/\r\n	public void setDestinationType(final String value)\r\n	{\r\n		if (_log.isTraceEnabled())\r\n		{\r\n			_log.trace(\"setDestinationType(\" + value + \")\");\r\n		}\r\n\r\n		_destinationType = value;\r\n	}\r\n\r\n	/**\r\n	* Get the message selector\r\n	* @return The value\r\n	*/\r\n	public String getMessageSelector()\r\n	{\r\n		if (_log.isTraceEnabled())\r\n		{\r\n			_log.trace(\"getMessageSelector()\");\r\n		}\r\n\r\n		return _messageSelector;\r\n	}\r\n\r\n	/**\r\n	* Set the message selector\r\n	* @param value The value\r\n	*/\r\n	public void setMessageSelector(final String value)\r\n	{\r\n		if (_log.isTraceEnabled())\r\n		{\r\n			_log.trace(\"setMessageSelector(\" + value + \")\");\r\n		}\r\n\r\n		_messageSelector = value;\r\n	}\r\n\r\n	/**\r\n	* Get the acknowledge mode\r\n	* @return The value\r\n	*/\r\n	public String getAcknowledgeMode()\r\n	{\r\n		if (_log.isTraceEnabled())\r\n		{\r\n			_log.trace(\"getAcknowledgeMode()\");\r\n		}\r\n\r\n		if (Session.DUPS_OK_ACKNOWLEDGE == _acknowledgeMode)\r\n		{\r\n			return \"Dups-ok-acknowledge\";\r\n		}\r\n		else\r\n		{\r\n			return \"Auto-acknowledge\";\r\n		}\r\n	}\r\n\r\n	/**\r\n	* Set the acknowledge mode\r\n	* @param value The value\r\n	*/\r\n	public void setAcknowledgeMode(final String value)\r\n	{\r\n		if (_log.isTraceEnabled())\r\n		{\r\n			_log.trace(\"setAcknowledgeMode(\" + value + \")\");\r\n		}\r\n\r\n		if (\"DUPS_OK_ACKNOWLEDGE\".equalsIgnoreCase(value) || \"Dups-ok-acknowledge\".equalsIgnoreCase(value))\r\n		{\r\n			_acknowledgeMode = Session.DUPS_OK_ACKNOWLEDGE;\r\n		}\r\n		else if (\"AUTO_ACKNOWLEDGE\".equalsIgnoreCase(value) || \"Auto-acknowledge\".equalsIgnoreCase(value))\r\n		{\r\n			_acknowledgeMode = Session.AUTO_ACKNOWLEDGE;\r\n		}\r\n		else\r\n		{\r\n			throw new IllegalArgumentException(\"Unsupported acknowledgement mode \" + value);\r\n		}\r\n	}\r\n\r\n	/**\r\n	* @return the acknowledgement mode\r\n	*/\r\n	public int getAcknowledgeModeInt()\r\n	{\r\n		if (_log.isTraceEnabled())\r\n		{\r\n			_log.trace(\"getAcknowledgeMode()\");\r\n		}\r\n\r\n		return _acknowledgeMode;\r\n	}\r\n\r\n	/**\r\n	* Get the subscription durability\r\n	* @return The value\r\n	*/\r\n	public String getSubscriptionDurability()\r\n	{\r\n		if (_log.isTraceEnabled())\r\n		{\r\n			_log.trace(\"getSubscriptionDurability()\");\r\n		}\r\n\r\n		if (_subscriptionDurability)\r\n		{\r\n			return \"Durable\";\r\n		}\r\n		else\r\n		{\r\n			return \"NonDurable\";\r\n		}\r\n	}\r\n\r\n	/**\r\n	* Set the subscription durability\r\n	* @param value The value\r\n	*/\r\n	public void setSubscriptionDurability(final String value)\r\n	{\r\n		if (_log.isTraceEnabled())\r\n		{\r\n			_log.trace(\"setSubscriptionDurability(\" + value + \")\");\r\n		}\r\n\r\n		_subscriptionDurability = \"Durable\".equals(value);\r\n	}\r\n\r\n	/**\r\n	* Get the status of subscription durability\r\n	* @return The value\r\n	*/\r\n	public boolean isSubscriptionDurable()\r\n	{\r\n		if (_log.isTraceEnabled())\r\n		{\r\n			_log.trace(\"isSubscriptionDurable()\");\r\n		}\r\n\r\n		return _subscriptionDurability;\r\n	}\r\n\r\n	/**\r\n	* Get the subscription name\r\n	* @return The value\r\n	*/\r\n	public String getSubscriptionName()\r\n	{\r\n		if (_log.isTraceEnabled())\r\n		{\r\n			_log.trace(\"getSubscriptionName()\");\r\n		}\r\n\r\n		return _subscriptionName;\r\n	}\r\n\r\n	/**\r\n	* Set the subscription name\r\n	* @param value The value\r\n	*/\r\n	public void setSubscriptionName(final String value)\r\n	{\r\n		if (_log.isTraceEnabled())\r\n		{\r\n			_log.trace(\"setSubscriptionName(\" + value + \")\");\r\n		}\r\n\r\n		_subscriptionName = value;\r\n	}\r\n\r\n	/**\r\n	* Get the number of max session\r\n	* @return The value\r\n	*/\r\n	public Integer getMaxSession()\r\n	{\r\n		if (_log.isTraceEnabled())\r\n		{\r\n			_log.trace(\"getMaxSession()\");\r\n		}\r\n\r\n		if (_maxSession == null)\r\n		{\r\n			return DEFAULT_MAX_SESSION;\r\n		}\r\n\r\n		return _maxSession;\r\n	}\r\n\r\n	/**\r\n	* Set the number of max session\r\n	* @param value The value\r\n	*/\r\n	public void setMaxSession(final Integer value)\r\n	{\r\n		if (_log.isTraceEnabled())\r\n		{\r\n			_log.trace(\"setMaxSession(\" + value + \")\");\r\n		}\r\n\r\n		_maxSession = value;\r\n	}\r\n\r\n	/**\r\n	* Get the transaction timeout\r\n	* @return The value\r\n	*/\r\n	public Integer getTransactionTimeout()\r\n	{\r\n		if (_log.isTraceEnabled())\r\n		{\r\n			_log.trace(\"getTransactionTimeout()\");\r\n		}\r\n\r\n		return _transactionTimeout;\r\n	}\r\n\r\n	/**\r\n	* Set the transaction timeout\r\n	* @param value The value\r\n	*/\r\n	public void setTransactionTimeout(final Integer value)\r\n	{\r\n		if (_log.isTraceEnabled())\r\n		{\r\n			_log.trace(\"setTransactionTimeout(\" + value + \")\");\r\n		}\r\n\r\n		_transactionTimeout = value;\r\n	}\r\n\r\n	/**\r\n	* Get the prefetch low\r\n	* @return The value\r\n	*/\r\n	public Integer getPrefetchLow()\r\n	{\r\n		if (_log.isTraceEnabled())\r\n		{\r\n			_log.trace(\"getPrefetchLow()\");\r\n		}\r\n\r\n		return _prefetchLow;\r\n	}\r\n\r\n	/**\r\n	* Set the prefetch low\r\n	* @param value The value\r\n	*/\r\n	public void setPrefetchLow(final Integer prefetchLow)\r\n	{\r\n		if (_log.isTraceEnabled())\r\n		{\r\n			_log.trace(\"setPrefetchLow(\" + prefetchLow + \")\");\r\n		}\r\n\r\n		this._prefetchLow = prefetchLow;\r\n	}\r\n\r\n	/**\r\n	* Get the prefetch high\r\n	* @return The value\r\n	*/\r\n	public Integer getPrefetchHigh()\r\n	{\r\n		if (_log.isTraceEnabled())\r\n		{\r\n			_log.trace(\"getPrefetchHigh()\");\r\n		}\r\n\r\n		return _prefetchHigh;\r\n	}\r\n\r\n	/**\r\n	* Set the prefetch high\r\n	* @param value The value\r\n	*/\r\n	public void setPrefetchHigh(final Integer prefetchHigh)\r\n	{\r\n		if (_log.isTraceEnabled())\r\n		{\r\n			_log.trace(\"setPrefetchHigh(\" + prefetchHigh + \")\");\r\n		}\r\n\r\n		this._prefetchHigh = prefetchHigh;\r\n	}\r\n\r\n	public int getSetupAttempts()\r\n	{\r\n		if (_log.isTraceEnabled())\r\n		{\r\n			_log.trace(\"getSetupAttempts()\");\r\n		}\r\n\r\n		if (_setupAttempts == null)\r\n		{\r\n			return _ra.getSetupAttempts();\r\n		}\r\n		else\r\n		{\r\n			return _setupAttempts;\r\n		}\r\n	}\r\n\r\n	public void setSetupAttempts(int setupAttempts)\r\n	{\r\n		if (_log.isTraceEnabled())\r\n		{\r\n			_log.trace(\"setSetupAttempts(\" + setupAttempts + \")\");\r\n		}\r\n\r\n		this._setupAttempts = setupAttempts;\r\n	}\r\n\r\n	public long getSetupInterval()\r\n	{\r\n		if (_log.isTraceEnabled())\r\n		{\r\n			_log.trace(\"getSetupInterval()\");\r\n		}\r\n\r\n		if (_setupInterval == null)\r\n		{\r\n			return _ra.getSetupInterval();\r\n		}\r\n		else\r\n		{\r\n			return _setupInterval;\r\n		}\r\n	}\r\n\r\n	public void setSetupInterval(long setupInterval)\r\n	{\r\n		if (_log.isTraceEnabled())\r\n		{\r\n			_log.trace(\"setSetupInterval(\" + setupInterval + \")\");\r\n		}\r\n\r\n		this._setupInterval = setupInterval;\r\n	}\r\n\r\n	public Boolean isUseConnectionPerHandler()\r\n	{              \r\n		return (_useConnectionPerHandler == null) ? _ra.isUseConnectionPerHandler() : _useConnectionPerHandler;\r\n	}\r\n\r\n	public void setUseConnectionPerHandler(Boolean connectionPerHandler)\r\n	{\r\n		this._useConnectionPerHandler = connectionPerHandler;                       \r\n	}\r\n\r\n	/**\r\n	* Validate\r\n	* @exception InvalidPropertyException Thrown if a validation exception occurs\r\n	*/\r\n	public void validate() throws InvalidPropertyException\r\n	{\r\n		if (_log.isTraceEnabled())\r\n		{\r\n			_log.trace(\"validate()\");\r\n		}\r\n\r\n		if (_destination == null || _destination.trim().equals(\"\"))\r\n		{\r\n			throw new InvalidPropertyException(\"Destination is mandatory\");\r\n		}\r\n	}\r\n\r\n\r\n	/**\r\n	* Get a string representation\r\n	* @return The value\r\n	*/\r\n	@Override\r\n	public String toString()\r\n	{\r\n		StringBuffer buffer = new StringBuffer();\r\n		buffer.append(QpidActivationSpec.class.getName()).append(\'(\');\r\n		buffer.append(\"ra=\").append(_ra);\r\n		buffer.append(\" destination=\").append(_destination);\r\n		buffer.append(\" destinationType=\").append(_destinationType);\r\n		\r\n		if (_messageSelector != null)\r\n		{\r\n			buffer.append(\" selector=\").append(_messageSelector);\r\n		}\r\n		\r\n		buffer.append(\" ack=\").append(getAcknowledgeMode());\r\n		buffer.append(\" durable=\").append(_subscriptionDurability);\r\n		buffer.append(\" clientID=\").append(getClientId());\r\n		\r\n		if (_subscriptionName != null)\r\n		{\r\n			buffer.append(\" subscription=\").append(_subscriptionName);\r\n		}\r\n		\r\n		buffer.append(\" user=\").append(getUserName());\r\n		\r\n		if (getPassword() != null)\r\n		{\r\n			buffer.append(\" password=\").append(\"********\");\r\n		}\r\n		\r\n		buffer.append(\" maxSession=\").append(_maxSession);\r\n		\r\n		if (_prefetchLow != null)\r\n		{\r\n			buffer.append(\" prefetchLow=\").append(_prefetchLow);\r\n		}\r\n		if (_prefetchHigh != null)\r\n		{\r\n			buffer.append(\" prefetchHigh=\").append(_prefetchHigh);\r\n		}\r\n		\r\n		buffer.append(\" connectionPerHandler=\").append(isUseConnectionPerHandler());\r\n		buffer.append(\')\');\r\n\r\n		return buffer.toString();\r\n	}\r\n}','Public Class','qpid','org.apache.qpid.ra.inflow.QpidActivationSpec',1,10,0,'/*\r\n*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*\r\n*/\r\npackage org.apache.qpid.ra;\r\n\r\nimport org.slf4j.Logger;\r\nimport org.slf4j.LoggerFactory;\r\n\r\n/**\r\n*/\r\npublic class ConnectionFactoryProperties\r\n{\r\n	/**\r\n	* The logger\r\n	*/\r\n	private static final Logger _log = LoggerFactory.getLogger(ConnectionFactoryProperties.class);\r\n\r\n	private boolean _hasBeenUpdated = false;\r\n\r\n	private String _clientId;\r\n\r\n	private String _connectionURL;\r\n\r\n	private String _userName;\r\n\r\n	private String _password;\r\n\r\n	private String _host;\r\n\r\n	private Integer _port;\r\n\r\n	private String _path;\r\n\r\n	private Boolean _localTx = Boolean.FALSE;\r\n\r\n	public String getClientId()\r\n	{\r\n		if (_log.isTraceEnabled())\r\n		{\r\n			_log.trace(\"getClientID()\");\r\n		}\r\n		return _clientId;\r\n	}\r\n\r\n	public void setClientId(final String clientID)\r\n	{\r\n		if (_log.isTraceEnabled())\r\n		{\r\n			_log.trace(\"setClientID(\" + clientID + \")\");\r\n		}\r\n		_hasBeenUpdated = true;\r\n		this._clientId = clientID;\r\n	}\r\n\r\n	public boolean isHasBeenUpdated()\r\n	{\r\n		return _hasBeenUpdated;\r\n	}\r\n\r\n	public String getConnectionURL()\r\n	{\r\n		if (_log.isTraceEnabled())\r\n		{\r\n			_log.trace(\"getConnectionURL()\");\r\n		}\r\n		return _connectionURL;\r\n	}\r\n\r\n	public void setConnectionURL(final String connectionURL)\r\n	{\r\n		if (_log.isTraceEnabled())\r\n		{\r\n			_log.trace(\"setConnectionURL(\" + Util.maskUrlForLog(connectionURL) + \")\");\r\n		}\r\n\r\n		_hasBeenUpdated = true;\r\n		this._connectionURL = connectionURL;\r\n	}\r\n\r\n	public String getPassword()\r\n	{\r\n		if (_log.isTraceEnabled())\r\n		{\r\n			_log.trace(\"getDefaultPassword()\");\r\n		}\r\n		return _password;\r\n	}\r\n\r\n	public void setPassword(final String defaultPassword)\r\n	{\r\n		if (_log.isTraceEnabled())\r\n		{\r\n			_log.trace(\"setDefaultPassword(\" + defaultPassword + \")\");\r\n		}\r\n		_hasBeenUpdated = true;\r\n		this._password = defaultPassword;\r\n	}\r\n\r\n	public String getUserName()\r\n	{\r\n		if (_log.isTraceEnabled())\r\n		{\r\n			_log.trace(\"getDefaultUsername()\");\r\n		}\r\n		return _userName;\r\n	}\r\n\r\n	public void setUserName(final String defaultUsername)\r\n	{\r\n		if (_log.isTraceEnabled())\r\n		{\r\n			_log.trace(\"setDefaultUsername(\" + defaultUsername + \")\");\r\n		}\r\n		_hasBeenUpdated = true;\r\n		this._userName = defaultUsername;\r\n	}\r\n\r\n	public String getHost()\r\n	{\r\n		if (_log.isTraceEnabled())\r\n		{\r\n			_log.trace(\"getHost()\");\r\n		}\r\n		return _host;\r\n	}\r\n\r\n	public void setHost(final String host)\r\n	{\r\n		if (_log.isTraceEnabled())\r\n		{\r\n			_log.trace(\"setHost(\" + host + \")\");\r\n		}\r\n		_hasBeenUpdated = true;\r\n		this._host = host;\r\n	}\r\n\r\n	public Integer getPort()\r\n	{\r\n		if (_log.isTraceEnabled())\r\n		{\r\n			_log.trace(\"getPort()\");\r\n		}\r\n		return _port;\r\n	}\r\n\r\n	public void setPort(final Integer port)\r\n	{\r\n		if (_log.isTraceEnabled())\r\n		{\r\n			_log.trace(\"setPort(\" + port + \")\");\r\n		}\r\n		_hasBeenUpdated = true;\r\n		this._port = port;\r\n	}\r\n\r\n	public String getPath()\r\n	{\r\n		if (_log.isTraceEnabled())\r\n		{\r\n			_log.trace(\"getPath()\");\r\n		}\r\n		return _path;\r\n	}\r\n\r\n	public void setPath(final String path)\r\n	{\r\n		if (_log.isTraceEnabled())\r\n		{\r\n			_log.trace(\"setPath(\" + path + \")\");\r\n		}\r\n		_hasBeenUpdated = true;\r\n		this._path = path;\r\n	}\r\n\r\n	public Boolean isUseLocalTx()\r\n	{\r\n		if (_log.isTraceEnabled())\r\n		{\r\n			_log.trace(\"isUseLocalTx()\");\r\n		}\r\n		return _localTx;\r\n	}\r\n\r\n	public void setUseLocalTx(Boolean localTx)\r\n	{\r\n		if (_log.isTraceEnabled())\r\n		{\r\n			_log.trace(\"setUseLocalTx(\" + localTx + \")\");\r\n		}\r\n\r\n		if(localTx != null)\r\n		{\r\n			_hasBeenUpdated = true;\r\n			this._localTx = localTx;\r\n		}\r\n\r\n	}\r\n\r\n}','org.apache.qpid.ra.ConnectionFactoryProperties'),(8,'C','gc','/*******************************************************************************\r\n* Copyright (c) 2000, 2003 IBM Corporation and others.\r\n* All rights reserved. This program and the accompanying materials \r\n* are made available under the terms of the Common Public License v1.0\r\n* which accompanies this distribution, and is available at\r\n* http://www.eclipse.org/legal/cpl-v10.html\r\n* \r\n* Contributors:\r\n*     IBM Corporation - initial API and implementation\r\n*******************************************************************************/\r\npackage org.eclipse.jdt.internal.core.util;\r\n\r\nimport java.util.Iterator;\r\n\r\nimport org.eclipse.jdt.core.compiler.CharOperation;\r\nimport org.eclipse.jdt.core.compiler.IScanner;\r\nimport org.eclipse.jdt.core.compiler.ITerminalSymbols;\r\nimport org.eclipse.jdt.core.compiler.InvalidInputException;\r\nimport org.eclipse.jdt.internal.compiler.ast.StringLiteral;\r\nimport org.eclipse.jdt.internal.compiler.classfmt.ClassFileConstants;\r\nimport org.eclipse.jdt.internal.compiler.parser.NLSLine;\r\n\r\npublic class PublicScanner implements IScanner, ITerminalSymbols {\r\n\r\n	/* APIs ares\r\n	- getNextToken() which return the current type of the token\r\n	(this value is not memorized by the scanner)\r\n	- getCurrentTokenSource() which provides with the token \"REAL\" source\r\n	(aka all unicode have been transformed into a correct char)\r\n	- sourceStart gives the position into the stream\r\n	- currentPosition-1 gives the sourceEnd position into the stream \r\n	*/\r\n\r\n	// 1.4 feature \r\n	private boolean assertMode = false;\r\n	public boolean useAssertAsAnIndentifier = false;\r\n	//flag indicating if processed source contains occurrences of keyword assert \r\n	public boolean containsAssertKeyword = false; \r\n	\r\n	public boolean recordLineSeparator = false;\r\n	public char currentCharacter;\r\n	public int startPosition;\r\n	public int currentPosition;\r\n	public int initialPosition, eofPosition;\r\n	// after this position eof are generated instead of real token from the source\r\n\r\n	public boolean tokenizeComments = false;\r\n	public boolean tokenizeWhiteSpace = false;\r\n\r\n	//source should be viewed as a window (aka a part)\r\n	//of a entire very large stream\r\n	public char source[];\r\n\r\n	//unicode support\r\n	public char[] withoutUnicodeBuffer;\r\n	public int withoutUnicodePtr; //when == 0 ==> no unicode in the current token\r\n	public boolean unicodeAsBackSlash = false;\r\n\r\n	public boolean scanningFloatLiteral = false;\r\n\r\n	//support for /** comments\r\n	public int[] commentStops = new int[10];\r\n	public int[] commentStarts = new int[10];\r\n	public int commentPtr = -1; // no comment test with commentPtr value -1\r\n	\r\n	// task tag support\r\n	public char[][] foundTaskTags = null;\r\n	public char[][] foundTaskMessages;\r\n	public char[][] foundTaskPriorities = null;\r\n	public int[][] foundTaskPositions;\r\n	public int foundTaskCount = 0;\r\n	public char[][] taskTags = null;\r\n	public char[][] taskPriorities = null;\r\n	\r\n	//diet parsing support - jump over some method body when requested\r\n	public boolean diet = false;\r\n\r\n	//support for the  poor-line-debuggers ....\r\n	//remember the position of the cr/lf\r\n	public int[] lineEnds = new int[250];\r\n	public int linePtr = -1;\r\n	public boolean wasAcr = false;\r\n\r\n	public static final String END_OF_SOURCE = \"End_Of_Source\"; //$NON-NLS-1$\r\n\r\n	public static final String INVALID_HEXA = \"Invalid_Hexa_Literal\"; //$NON-NLS-1$\r\n	public static final String INVALID_OCTAL = \"Invalid_Octal_Literal\"; //$NON-NLS-1$\r\n	public static final String INVALID_CHARACTER_CONSTANT = \"Invalid_Character_Constant\";  //$NON-NLS-1$\r\n	public static final String INVALID_ESCAPE = \"Invalid_Escape\"; //$NON-NLS-1$\r\n	public static final String INVALID_INPUT = \"Invalid_Input\"; //$NON-NLS-1$\r\n	public static final String INVALID_UNICODE_ESCAPE = \"Invalid_Unicode_Escape\"; //$NON-NLS-1$\r\n	public static final String INVALID_FLOAT = \"Invalid_Float_Literal\"; //$NON-NLS-1$\r\n\r\n	public static final String NULL_SOURCE_STRING = \"Null_Source_String\"; //$NON-NLS-1$\r\n	public static final String UNTERMINATED_STRING = \"Unterminated_String\"; //$NON-NLS-1$\r\n	public static final String UNTERMINATED_COMMENT = \"Unterminated_Comment\"; //$NON-NLS-1$\r\n	public static final String INVALID_CHAR_IN_STRING = \"Invalid_Char_In_String\"; //$NON-NLS-1$\r\n\r\n	//----------------optimized identifier managment------------------\r\n	static final char[] charArray_a = new char[] {\'a\'}, \r\n	charArray_b = new char[] {\'b\'}, \r\n	charArray_c = new char[] {\'c\'}, \r\n	charArray_d = new char[] {\'d\'}, \r\n	charArray_e = new char[] {\'e\'}, \r\n	charArray_f = new char[] {\'f\'}, \r\n	charArray_g = new char[] {\'g\'}, \r\n	charArray_h = new char[] {\'h\'}, \r\n	charArray_i = new char[] {\'i\'}, \r\n	charArray_j = new char[] {\'j\'}, \r\n	charArray_k = new char[] {\'k\'}, \r\n	charArray_l = new char[] {\'l\'}, \r\n	charArray_m = new char[] {\'m\'}, \r\n	charArray_n = new char[] {\'n\'}, \r\n	charArray_o = new char[] {\'o\'}, \r\n	charArray_p = new char[] {\'p\'}, \r\n	charArray_q = new char[] {\'q\'}, \r\n	charArray_r = new char[] {\'r\'}, \r\n	charArray_s = new char[] {\'s\'}, \r\n	charArray_t = new char[] {\'t\'}, \r\n	charArray_u = new char[] {\'u\'}, \r\n	charArray_v = new char[] {\'v\'}, \r\n	charArray_w = new char[] {\'w\'}, \r\n	charArray_x = new char[] {\'x\'}, \r\n	charArray_y = new char[] {\'y\'}, \r\n	charArray_z = new char[] {\'z\'}; \r\n\r\n	static final char[] initCharArray = \r\n	new char[] {\'\\u0000\', \'\\u0000\', \'\\u0000\', \'\\u0000\', \'\\u0000\', \'\\u0000\'}; \r\n	static final int TableSize = 30, InternalTableSize = 6; //30*6 = 180 entries\r\n	public static final int OptimizedLength = 6;\r\n	public /*static*/ final char[][][][] charArray_length = \r\n	new char[OptimizedLength][TableSize][InternalTableSize][]; \r\n	// support for detecting non-externalized string literals\r\n	int currentLineNr= -1;\r\n	int previousLineNr= -1;\r\n	NLSLine currentLine= null;\r\n	public static final String TAG_PREFIX= \"//$NON-NLS-\"; //$NON-NLS-1$\r\n	public static final int TAG_PREFIX_LENGTH= TAG_PREFIX.length();\r\n	public static final String TAG_POSTFIX= \"$\"; //$NON-NLS-1$\r\n	public static final int TAG_POSTFIX_LENGTH= TAG_POSTFIX.length();\r\n	public StringLiteral[] nonNLSStrings = null;\r\n	public boolean checkNonExternalizedStringLiterals = false;\r\n	public boolean wasNonExternalizedStringLiteral = false;\r\n	\r\n	/*static*/ {\r\n		for (int i = 0; i < 6; i++) {\r\n			for (int j = 0; j < TableSize; j++) {\r\n				for (int k = 0; k < InternalTableSize; k++) {\r\n					charArray_length[i][j][k] = initCharArray;\r\n				}\r\n			}\r\n		}\r\n	}\r\n	static int newEntry2 = 0, \r\n	newEntry3 = 0, \r\n	newEntry4 = 0, \r\n	newEntry5 = 0, \r\n	newEntry6 = 0;\r\n\r\n	public static final int RoundBracket = 0;\r\n	public static final int SquareBracket = 1;\r\n	public static final int CurlyBracket = 2;	\r\n	public static final int BracketKinds = 3;\r\n\r\n	public PublicScanner() {\r\n		this(false /*comment*/, false /*whitespace*/, false /*nls*/, ClassFileConstants.JDK1_3 /*sourceLevel*/, null/*taskTag*/, null/*taskPriorities*/);\r\n	}\r\n\r\n	public PublicScanner(\r\n	boolean tokenizeComments, \r\n	boolean tokenizeWhiteSpace, \r\n	boolean checkNonExternalizedStringLiterals, \r\n	long sourceLevel,\r\n	char[][] taskTags,\r\n	char[][] taskPriorities) {\r\n\r\n		this.eofPosition = Integer.MAX_VALUE;\r\n		this.tokenizeComments = tokenizeComments;\r\n		this.tokenizeWhiteSpace = tokenizeWhiteSpace;\r\n		this.checkNonExternalizedStringLiterals = checkNonExternalizedStringLiterals;\r\n		this.assertMode = sourceLevel >= ClassFileConstants.JDK1_4;\r\n		this.taskTags = taskTags;\r\n		this.taskPriorities = taskPriorities;\r\n	}\r\n\r\n	public  final boolean atEnd() {\r\n		// This code is not relevant if source is \r\n		// Only a part of the real stream input\r\n\r\n		return source.length == currentPosition;\r\n	}\r\n\r\n	private void checkNonExternalizedString()  throws InvalidInputException {\r\n		if (currentLine == null) \r\n		return;\r\n		parseTags(currentLine);\r\n	}\r\n\r\n	// chech presence of task: tags\r\n	public void checkTaskTag(int commentStart, int commentEnd) {\r\n		char[] src = this.source;\r\n		\r\n		// only look for newer task: tags\r\n		if (this.foundTaskCount > 0\r\n				&& this.foundTaskPositions[this.foundTaskCount - 1][0] >= commentStart) {\r\n			return;\r\n		}\r\n		int foundTaskIndex = this.foundTaskCount;\r\n		char previous = \'/\';\r\n		nextChar : for (\r\n		int i = commentStart + 1; i < commentEnd && i < this.eofPosition; i++) {\r\n			char[] tag = null;\r\n			char[] priority = null;\r\n			// check for tag occurrence\r\n			nextTag : for (int itag = 0; itag < this.taskTags.length; itag++) {\r\n				tag = this.taskTags[itag];\r\n				int tagLength = tag.length;\r\n				if (tagLength == 0) continue nextTag;\r\n\r\n				// ensure tag is not leaded with letter if tag starts with a letter\r\n				if (Character.isLetterOrDigit(tag[0])) {\r\n					if (Character.isLetterOrDigit(previous)) {\r\n						continue nextTag;\r\n					}\r\n				}\r\n\r\n				for (int t = 0; t < tagLength; t++) {\r\n					if (src[i + t] != tag[t])\r\n					continue nextTag;\r\n				}\r\n				// ensure tag is not followed with letter if tag finishes with a letter\r\n				if (i+tagLength < commentEnd && Character.isLetterOrDigit(src[i+tagLength-1])) {\r\n					if (Character.isLetterOrDigit(src[i + tagLength]))\r\n					continue nextTag;\r\n				}\r\n				if (this.foundTaskTags == null) {\r\n					this.foundTaskTags = new char[5][];\r\n					this.foundTaskMessages = new char[5][];\r\n					this.foundTaskPriorities = new char[5][];\r\n					this.foundTaskPositions = new int[5][];\r\n				} else if (this.foundTaskCount == this.foundTaskTags.length) {\r\n					System.arraycopy(this.foundTaskTags, 0, this.foundTaskTags = new char[this.foundTaskCount * 2][], 0, this.foundTaskCount);\r\n					System.arraycopy(this.foundTaskMessages, 0, this.foundTaskMessages = new char[this.foundTaskCount * 2][], 0, this.foundTaskCount);\r\n					System.arraycopy(this.foundTaskPriorities, 0, this.foundTaskPriorities = new char[this.foundTaskCount * 2][], 0, this.foundTaskCount);\r\n					System.arraycopy(this.foundTaskPositions, 0, this.foundTaskPositions = new int[this.foundTaskCount * 2][], 0, this.foundTaskCount);\r\n				}\r\n				\r\n				priority = this.taskPriorities != null && itag < this.taskPriorities.length\r\n				? this.taskPriorities[itag]\r\n				: null;\r\n				\r\n				this.foundTaskTags[this.foundTaskCount] = tag;\r\n				this.foundTaskPriorities[this.foundTaskCount] = priority;\r\n				this.foundTaskPositions[this.foundTaskCount] = new int[] { i, i + tagLength - 1 };\r\n				this.foundTaskMessages[this.foundTaskCount] = CharOperation.NO_CHAR;\r\n				this.foundTaskCount++;\r\n				i += tagLength - 1; // will be incremented when looping\r\n				break nextTag;\r\n			}\r\n			previous = src[i];\r\n		}\r\n		for (int i = foundTaskIndex; i < this.foundTaskCount; i++) {\r\n			// retrieve message start and end positions\r\n			int msgStart = this.foundTaskPositions[i][0] + this.foundTaskTags[i].length;\r\n			int max_value = i + 1 < this.foundTaskCount\r\n			? this.foundTaskPositions[i + 1][0] - 1\r\n			: commentEnd - 1;\r\n			// at most beginning of next task\r\n			if (max_value < msgStart) {\r\n				max_value = msgStart; // would only occur if tag is before EOF.\r\n			}\r\n			int end = -1;\r\n			char c;\r\n			for (int j = msgStart; j < max_value; j++) {\r\n				if ((c = src[j]) == \'\\n\' || c == \'\\r\') {\r\n					end = j - 1;\r\n					break;\r\n				}\r\n			}\r\n			if (end == -1) {\r\n				for (int j = max_value; j > msgStart; j--) {\r\n					if ((c = src[j]) == \'*\') {\r\n						end = j - 1;\r\n						break;\r\n					}\r\n				}\r\n				if (end == -1)\r\n				end = max_value;\r\n			}\r\n			if (msgStart == end)\r\n			continue; // empty\r\n			// trim the message\r\n			while (CharOperation.isWhitespace(src[end]) && msgStart <= end)\r\n			end--;\r\n			while (CharOperation.isWhitespace(src[msgStart]) && msgStart <= end)\r\n			msgStart++;\r\n			// update the end position of the task\r\n			this.foundTaskPositions[i][1] = end;\r\n			// get the message source\r\n			final int messageLength = end - msgStart + 1;\r\n			char[] message = new char[messageLength];\r\n			System.arraycopy(src, msgStart, message, 0, messageLength);\r\n			this.foundTaskMessages[i] = message;\r\n		}\r\n	}\r\n	public char[] getCurrentIdentifierSource() {\r\n		//return the token REAL source (aka unicodes are precomputed)\r\n\r\n		char[] result;\r\n		if (withoutUnicodePtr != 0)\r\n		//0 is used as a fast test flag so the real first char is in position 1\r\n		System.arraycopy(\r\n		withoutUnicodeBuffer, \r\n		1, \r\n		result = new char[withoutUnicodePtr], \r\n		0, \r\n		withoutUnicodePtr); \r\n		else {\r\n			int length = currentPosition - startPosition;\r\n			switch (length) { // see OptimizedLength\r\n			case 1 :\r\n				return optimizedCurrentTokenSource1();\r\n			case 2 :\r\n				return optimizedCurrentTokenSource2();\r\n			case 3 :\r\n				return optimizedCurrentTokenSource3();\r\n			case 4 :\r\n				return optimizedCurrentTokenSource4();\r\n			case 5 :\r\n				return optimizedCurrentTokenSource5();\r\n			case 6 :\r\n				return optimizedCurrentTokenSource6();\r\n			}\r\n			//no optimization\r\n			System.arraycopy(source, startPosition, result = new char[length], 0, length);\r\n		}\r\n		return result;\r\n	}\r\n	public int getCurrentTokenEndPosition(){\r\n		return this.currentPosition - 1;\r\n	}\r\n	public final char[] getCurrentTokenSource() {\r\n		// Return the token REAL source (aka unicodes are precomputed)\r\n\r\n		char[] result;\r\n		if (withoutUnicodePtr != 0)\r\n		// 0 is used as a fast test flag so the real first char is in position 1\r\n		System.arraycopy(\r\n		withoutUnicodeBuffer, \r\n		1, \r\n		result = new char[withoutUnicodePtr], \r\n		0, \r\n		withoutUnicodePtr); \r\n		else {\r\n			int length;\r\n			System.arraycopy(\r\n			source, \r\n			startPosition, \r\n			result = new char[length = currentPosition - startPosition], \r\n			0, \r\n			length); \r\n		}\r\n		return result;\r\n	}\r\n	public final char[] getCurrentTokenSourceString() {\r\n		//return the token REAL source (aka unicodes are precomputed).\r\n		//REMOVE the two \" that are at the beginning and the end.\r\n\r\n		char[] result;\r\n		if (withoutUnicodePtr != 0)\r\n		//0 is used as a fast test flag so the real first char is in position 1\r\n		System.arraycopy(withoutUnicodeBuffer, 2,\r\n		//2 is 1 (real start) + 1 (to jump over the \")\r\n		result = new char[withoutUnicodePtr - 2], 0, withoutUnicodePtr - 2);\r\n		else {\r\n			int length;\r\n			System.arraycopy(\r\n			source, \r\n			startPosition + 1, \r\n			result = new char[length = currentPosition - startPosition - 2], \r\n			0, \r\n			length); \r\n		}\r\n		return result;\r\n	}\r\n\r\n	public final char[] getRawTokenSource() {\r\n		int length = this.currentPosition - this.startPosition;\r\n		char[] tokenSource = new char[length];\r\n		System.arraycopy(source, this.startPosition, tokenSource, 0, length);\r\n		return tokenSource;	\r\n	}\r\n	\r\n	public int getCurrentTokenStartPosition(){\r\n		return this.startPosition;\r\n	}\r\n	/*\r\n* Search the source position corresponding to the end of a given line number\r\n*\r\n* Line numbers are 1-based, and relative to the scanner initialPosition. \r\n* Character positions are 0-based.\r\n*\r\n* In case the given line number is inconsistent, answers -1.\r\n*/\r\n	public final int getLineEnd(int lineNumber) {\r\n\r\n		if (lineEnds == null) return -1;\r\n		if (lineNumber >= lineEnds.length) return -1;\r\n		if (lineNumber <= 0) return -1;\r\n		\r\n		if (lineNumber == lineEnds.length - 1) return eofPosition;\r\n		return lineEnds[lineNumber-1]; // next line start one character behind the lineEnd of the previous line\r\n	}\r\n\r\n	public final int[] getLineEnds() {\r\n		//return a bounded copy of this.lineEnds \r\n\r\n		int[] copy;\r\n		System.arraycopy(lineEnds, 0, copy = new int[linePtr + 1], 0, linePtr + 1);\r\n		return copy;\r\n	}\r\n\r\n	/**\r\n* Search the source position corresponding to the beginning of a given line number\r\n*\r\n* Line numbers are 1-based, and relative to the scanner initialPosition. \r\n* Character positions are 0-based.\r\n*\r\n* e.g.	getLineStart(1) --> 0	indicates that the first line starts at character 0.\r\n*\r\n* In case the given line number is inconsistent, answers -1.\r\n*/\r\n	public final int getLineStart(int lineNumber) {\r\n\r\n		if (lineEnds == null) return -1;\r\n		if (lineNumber >= lineEnds.length) return -1;\r\n		if (lineNumber <= 0) return -1;\r\n		\r\n		if (lineNumber == 1) return initialPosition;\r\n		return lineEnds[lineNumber-2]+1; // next line start one character behind the lineEnd of the previous line\r\n	}\r\n	public final boolean getNextChar(char testedChar) {\r\n		//BOOLEAN\r\n		//handle the case of unicode.\r\n		//when a unicode appears then we must use a buffer that holds char internal values\r\n		//At the end of this method currentCharacter holds the new visited char\r\n		//and currentPosition points right next after it\r\n		//Both previous lines are true if the currentCharacter is == to the testedChar\r\n		//On false, no side effect has occured.\r\n\r\n		//ALL getNextChar.... ARE OPTIMIZED COPIES \r\n\r\n		int temp = currentPosition;\r\n		try {\r\n			if (((currentCharacter = source[currentPosition++]) == \'\\\\\')\r\n					&& (source[currentPosition] == \'u\')) {\r\n				//-------------unicode traitement ------------\r\n				int c1, c2, c3, c4;\r\n				int unicodeSize = 6;\r\n				currentPosition++;\r\n				while (source[currentPosition] == \'u\') {\r\n					currentPosition++;\r\n					unicodeSize++;\r\n				}\r\n\r\n				if (((c1 = Character.getNumericValue(source[currentPosition++])) > 15\r\n							|| c1 < 0)\r\n						|| ((c2 = Character.getNumericValue(source[currentPosition++])) > 15 || c2 < 0)\r\n						|| ((c3 = Character.getNumericValue(source[currentPosition++])) > 15 || c3 < 0)\r\n						|| ((c4 = Character.getNumericValue(source[currentPosition++])) > 15 || c4 < 0)) {\r\n					currentPosition = temp;\r\n					return false;\r\n				}\r\n\r\n				currentCharacter = (char) (((c1 * 16 + c2) * 16 + c3) * 16 + c4);\r\n				if (currentCharacter != testedChar) {\r\n					currentPosition = temp;\r\n					return false;\r\n				}\r\n				unicodeAsBackSlash = currentCharacter == \'\\\\\';\r\n\r\n				//need the unicode buffer\r\n				if (withoutUnicodePtr == 0) {\r\n					//buffer all the entries that have been left aside....\r\n					withoutUnicodePtr = currentPosition - unicodeSize - startPosition;\r\n					System.arraycopy(\r\n					source, \r\n					startPosition, \r\n					withoutUnicodeBuffer, \r\n					1, \r\n					withoutUnicodePtr); \r\n				}\r\n				//fill the buffer with the char\r\n				withoutUnicodeBuffer[++withoutUnicodePtr] = currentCharacter;\r\n				return true;\r\n\r\n			} //-------------end unicode traitement--------------\r\n			else {\r\n				if (currentCharacter != testedChar) {\r\n					currentPosition = temp;\r\n					return false;\r\n				}\r\n				unicodeAsBackSlash = false;\r\n				if (withoutUnicodePtr != 0)\r\n				withoutUnicodeBuffer[++withoutUnicodePtr] = currentCharacter;\r\n				return true;\r\n			}\r\n		} catch (IndexOutOfBoundsException e) {\r\n			unicodeAsBackSlash = false;\r\n			currentPosition = temp;\r\n			return false;\r\n		}\r\n	}\r\n	public final int getNextChar(char testedChar1, char testedChar2) {\r\n		//INT 0 : testChar1 \\\\\\\\///\\\\\\\\ 1 : testedChar2 \\\\\\\\///\\\\\\\\ -1 : others\r\n		//test can be done with (x==0) for the first and (x>0) for the second\r\n		//handle the case of unicode.\r\n		//when a unicode appears then we must use a buffer that holds char internal values\r\n		//At the end of this method currentCharacter holds the new visited char\r\n		//and currentPosition points right next after it\r\n		//Both previous lines are true if the currentCharacter is == to the testedChar1/2\r\n		//On false, no side effect has occured.\r\n\r\n		//ALL getNextChar.... ARE OPTIMIZED COPIES \r\n\r\n		int temp = currentPosition;\r\n		try {\r\n			int result;\r\n			if (((currentCharacter = source[currentPosition++]) == \'\\\\\')\r\n					&& (source[currentPosition] == \'u\')) {\r\n				//-------------unicode traitement ------------\r\n				int c1, c2, c3, c4;\r\n				int unicodeSize = 6;\r\n				currentPosition++;\r\n				while (source[currentPosition] == \'u\') {\r\n					currentPosition++;\r\n					unicodeSize++;\r\n				}\r\n\r\n				if (((c1 = Character.getNumericValue(source[currentPosition++])) > 15\r\n							|| c1 < 0)\r\n						|| ((c2 = Character.getNumericValue(source[currentPosition++])) > 15 || c2 < 0)\r\n						|| ((c3 = Character.getNumericValue(source[currentPosition++])) > 15 || c3 < 0)\r\n						|| ((c4 = Character.getNumericValue(source[currentPosition++])) > 15 || c4 < 0)) {\r\n					currentPosition = temp;\r\n					return 2;\r\n				}\r\n\r\n				currentCharacter = (char) (((c1 * 16 + c2) * 16 + c3) * 16 + c4);\r\n				if (currentCharacter == testedChar1)\r\n				result = 0;\r\n				else\r\n				if (currentCharacter == testedChar2)\r\n				result = 1;\r\n				else {\r\n					currentPosition = temp;\r\n					return -1;\r\n				}\r\n\r\n				//need the unicode buffer\r\n				if (withoutUnicodePtr == 0) {\r\n					//buffer all the entries that have been left aside....\r\n					withoutUnicodePtr = currentPosition - unicodeSize - startPosition;\r\n					System.arraycopy(\r\n					source, \r\n					startPosition, \r\n					withoutUnicodeBuffer, \r\n					1, \r\n					withoutUnicodePtr); \r\n				}\r\n				//fill the buffer with the char\r\n				withoutUnicodeBuffer[++withoutUnicodePtr] = currentCharacter;\r\n				return result;\r\n			} //-------------end unicode traitement--------------\r\n			else {\r\n				if (currentCharacter == testedChar1)\r\n				result = 0;\r\n				else\r\n				if (currentCharacter == testedChar2)\r\n				result = 1;\r\n				else {\r\n					currentPosition = temp;\r\n					return -1;\r\n				}\r\n\r\n				if (withoutUnicodePtr != 0)\r\n				withoutUnicodeBuffer[++withoutUnicodePtr] = currentCharacter;\r\n				return result;\r\n			}\r\n		} catch (IndexOutOfBoundsException e) {\r\n			currentPosition = temp;\r\n			return -1;\r\n		}\r\n	}\r\n	public final boolean getNextCharAsDigit() {\r\n		//BOOLEAN\r\n		//handle the case of unicode.\r\n		//when a unicode appears then we must use a buffer that holds char internal values\r\n		//At the end of this method currentCharacter holds the new visited char\r\n		//and currentPosition points right next after it\r\n		//Both previous lines are true if the currentCharacter is a digit\r\n		//On false, no side effect has occured.\r\n\r\n		//ALL getNextChar.... ARE OPTIMIZED COPIES \r\n\r\n		int temp = currentPosition;\r\n		try {\r\n			if (((currentCharacter = source[currentPosition++]) == \'\\\\\')\r\n					&& (source[currentPosition] == \'u\')) {\r\n				//-------------unicode traitement ------------\r\n				int c1, c2, c3, c4;\r\n				int unicodeSize = 6;\r\n				currentPosition++;\r\n				while (source[currentPosition] == \'u\') {\r\n					currentPosition++;\r\n					unicodeSize++;\r\n				}\r\n\r\n				if (((c1 = Character.getNumericValue(source[currentPosition++])) > 15\r\n							|| c1 < 0)\r\n						|| ((c2 = Character.getNumericValue(source[currentPosition++])) > 15 || c2 < 0)\r\n						|| ((c3 = Character.getNumericValue(source[currentPosition++])) > 15 || c3 < 0)\r\n						|| ((c4 = Character.getNumericValue(source[currentPosition++])) > 15 || c4 < 0)) {\r\n					currentPosition = temp;\r\n					return false;\r\n				}\r\n\r\n				currentCharacter = (char) (((c1 * 16 + c2) * 16 + c3) * 16 + c4);\r\n				if (!Character.isDigit(currentCharacter)) {\r\n					currentPosition = temp;\r\n					return false;\r\n				}\r\n\r\n				//need the unicode buffer\r\n				if (withoutUnicodePtr == 0) {\r\n					//buffer all the entries that have been left aside....\r\n					withoutUnicodePtr = currentPosition - unicodeSize - startPosition;\r\n					System.arraycopy(\r\n					source, \r\n					startPosition, \r\n					withoutUnicodeBuffer, \r\n					1, \r\n					withoutUnicodePtr); \r\n				}\r\n				//fill the buffer with the char\r\n				withoutUnicodeBuffer[++withoutUnicodePtr] = currentCharacter;\r\n				return true;\r\n			} //-------------end unicode traitement--------------\r\n			else {\r\n				if (!Character.isDigit(currentCharacter)) {\r\n					currentPosition = temp;\r\n					return false;\r\n				}\r\n				if (withoutUnicodePtr != 0)\r\n				withoutUnicodeBuffer[++withoutUnicodePtr] = currentCharacter;\r\n				return true;\r\n			}\r\n		} catch (IndexOutOfBoundsException e) {\r\n			currentPosition = temp;\r\n			return false;\r\n		}\r\n	}\r\n	public final boolean getNextCharAsDigit(int radix) {\r\n		//BOOLEAN\r\n		//handle the case of unicode.\r\n		//when a unicode appears then we must use a buffer that holds char internal values\r\n		//At the end of this method currentCharacter holds the new visited char\r\n		//and currentPosition points right next after it\r\n		//Both previous lines are true if the currentCharacter is a digit base on radix\r\n		//On false, no side effect has occured.\r\n\r\n		//ALL getNextChar.... ARE OPTIMIZED COPIES \r\n\r\n		int temp = currentPosition;\r\n		try {\r\n			if (((currentCharacter = source[currentPosition++]) == \'\\\\\')\r\n					&& (source[currentPosition] == \'u\')) {\r\n				//-------------unicode traitement ------------\r\n				int c1, c2, c3, c4;\r\n				int unicodeSize = 6;\r\n				currentPosition++;\r\n				while (source[currentPosition] == \'u\') {\r\n					currentPosition++;\r\n					unicodeSize++;\r\n				}\r\n\r\n				if (((c1 = Character.getNumericValue(source[currentPosition++])) > 15\r\n							|| c1 < 0)\r\n						|| ((c2 = Character.getNumericValue(source[currentPosition++])) > 15 || c2 < 0)\r\n						|| ((c3 = Character.getNumericValue(source[currentPosition++])) > 15 || c3 < 0)\r\n						|| ((c4 = Character.getNumericValue(source[currentPosition++])) > 15 || c4 < 0)) {\r\n					currentPosition = temp;\r\n					return false;\r\n				}\r\n\r\n				currentCharacter = (char) (((c1 * 16 + c2) * 16 + c3) * 16 + c4);\r\n				if (Character.digit(currentCharacter, radix) == -1) {\r\n					currentPosition = temp;\r\n					return false;\r\n				}\r\n\r\n				//need the unicode buffer\r\n				if (withoutUnicodePtr == 0) {\r\n					//buffer all the entries that have been left aside....\r\n					withoutUnicodePtr = currentPosition - unicodeSize - startPosition;\r\n					System.arraycopy(\r\n					source, \r\n					startPosition, \r\n					withoutUnicodeBuffer, \r\n					1, \r\n					withoutUnicodePtr); \r\n				}\r\n				//fill the buffer with the char\r\n				withoutUnicodeBuffer[++withoutUnicodePtr] = currentCharacter;\r\n				return true;\r\n			} //-------------end unicode traitement--------------\r\n			else {\r\n				if (Character.digit(currentCharacter, radix) == -1) {\r\n					currentPosition = temp;\r\n					return false;\r\n				}\r\n				if (withoutUnicodePtr != 0)\r\n				withoutUnicodeBuffer[++withoutUnicodePtr] = currentCharacter;\r\n				return true;\r\n			}\r\n		} catch (IndexOutOfBoundsException e) {\r\n			currentPosition = temp;\r\n			return false;\r\n		}\r\n	}\r\n	public boolean getNextCharAsJavaIdentifierPart() {\r\n		//BOOLEAN\r\n		//handle the case of unicode.\r\n		//when a unicode appears then we must use a buffer that holds char internal values\r\n		//At the end of this method currentCharacter holds the new visited char\r\n		//and currentPosition points right next after it\r\n		//Both previous lines are true if the currentCharacter is a JavaIdentifierPart\r\n		//On false, no side effect has occured.\r\n\r\n		//ALL getNextChar.... ARE OPTIMIZED COPIES \r\n\r\n		int temp = currentPosition;\r\n		try {\r\n			if (((currentCharacter = source[currentPosition++]) == \'\\\\\')\r\n					&& (source[currentPosition] == \'u\')) {\r\n				//-------------unicode traitement ------------\r\n				int c1, c2, c3, c4;\r\n				int unicodeSize = 6;\r\n				currentPosition++;\r\n				while (source[currentPosition] == \'u\') {\r\n					currentPosition++;\r\n					unicodeSize++;\r\n				}\r\n\r\n				if (((c1 = Character.getNumericValue(source[currentPosition++])) > 15\r\n							|| c1 < 0)\r\n						|| ((c2 = Character.getNumericValue(source[currentPosition++])) > 15 || c2 < 0)\r\n						|| ((c3 = Character.getNumericValue(source[currentPosition++])) > 15 || c3 < 0)\r\n						|| ((c4 = Character.getNumericValue(source[currentPosition++])) > 15 || c4 < 0)) {\r\n					currentPosition = temp;\r\n					return false;\r\n				}\r\n\r\n				currentCharacter = (char) (((c1 * 16 + c2) * 16 + c3) * 16 + c4);\r\n				if (!Character.isJavaIdentifierPart(currentCharacter)) {\r\n					currentPosition = temp;\r\n					return false;\r\n				}\r\n\r\n				//need the unicode buffer\r\n				if (withoutUnicodePtr == 0) {\r\n					//buffer all the entries that have been left aside....\r\n					withoutUnicodePtr = currentPosition - unicodeSize - startPosition;\r\n					System.arraycopy(\r\n					source, \r\n					startPosition, \r\n					withoutUnicodeBuffer, \r\n					1, \r\n					withoutUnicodePtr); \r\n				}\r\n				//fill the buffer with the char\r\n				withoutUnicodeBuffer[++withoutUnicodePtr] = currentCharacter;\r\n				return true;\r\n			} //-------------end unicode traitement--------------\r\n			else {\r\n				if (!Character.isJavaIdentifierPart(currentCharacter)) {\r\n					currentPosition = temp;\r\n					return false;\r\n				}\r\n\r\n				if (withoutUnicodePtr != 0)\r\n				withoutUnicodeBuffer[++withoutUnicodePtr] = currentCharacter;\r\n				return true;\r\n			}\r\n		} catch (IndexOutOfBoundsException e) {\r\n			currentPosition = temp;\r\n			return false;\r\n		}\r\n	}\r\n	public int getNextToken() throws InvalidInputException {\r\n\r\n		this.wasAcr = false;\r\n		if (diet) {\r\n			jumpOverMethodBody();\r\n			diet = false;\r\n			return currentPosition > source.length ? TokenNameEOF : TokenNameRBRACE;\r\n		}\r\n		int whiteStart = 0;\r\n		try {\r\n			while (true) { //loop for jumping over comments\r\n				withoutUnicodePtr = 0;\r\n				//start with a new token (even comment written with unicode )\r\n\r\n				// ---------Consume white space and handles startPosition---------\r\n				whiteStart = currentPosition;\r\n				boolean isWhiteSpace, hasWhiteSpaces = false;\r\n				int offset = 0;\r\n				do {\r\n					startPosition = currentPosition;\r\n					boolean checkIfUnicode = false;\r\n					try {\r\n						checkIfUnicode = ((currentCharacter = source[currentPosition++]) == \'\\\\\')\r\n						&& (source[currentPosition] == \'u\');\r\n					} catch(IndexOutOfBoundsException e) {\r\n						if (tokenizeWhiteSpace && (whiteStart != currentPosition - 1)) {\r\n							// reposition scanner in case we are interested by spaces as tokens\r\n							currentPosition--;\r\n							startPosition = whiteStart;\r\n							return TokenNameWHITESPACE;\r\n						}\r\n						if (currentPosition > eofPosition)\r\n						return TokenNameEOF;\r\n					}\r\n					if (checkIfUnicode) {\r\n						isWhiteSpace = jumpOverUnicodeWhiteSpace();\r\n						offset = 6;\r\n					} else {\r\n						offset = 1;\r\n						if ((currentCharacter == \'\\r\') || (currentCharacter == \'\\n\')) {\r\n							checkNonExternalizedString();\r\n							if (recordLineSeparator) {\r\n								pushLineSeparator();\r\n							} else {\r\n								currentLine = null;\r\n							}\r\n						}\r\n						isWhiteSpace = \r\n						(currentCharacter == \' \') || CharOperation.isWhitespace(currentCharacter); \r\n					}\r\n					if (isWhiteSpace) {\r\n						hasWhiteSpaces = true;\r\n					}\r\n				} while (isWhiteSpace);\r\n				if (tokenizeWhiteSpace && hasWhiteSpaces) {\r\n					// reposition scanner in case we are interested by spaces as tokens\r\n					currentPosition-=offset;\r\n					startPosition = whiteStart;\r\n					return TokenNameWHITESPACE;\r\n				}\r\n				//little trick to get out in the middle of a source compuation\r\n				if (currentPosition > eofPosition)\r\n				return TokenNameEOF;\r\n\r\n				// ---------Identify the next token-------------\r\n\r\n				switch (currentCharacter) {\r\n				case \'(\' :\r\n					return TokenNameLPAREN;\r\n				case \')\' :\r\n					return TokenNameRPAREN;\r\n				case \'{\' :\r\n					return TokenNameLBRACE;\r\n				case \'}\' :\r\n					return TokenNameRBRACE;\r\n				case \'[\' :\r\n					return TokenNameLBRACKET;\r\n				case \']\' :\r\n					return TokenNameRBRACKET;\r\n				case \';\' :\r\n					return TokenNameSEMICOLON;\r\n				case \',\' :\r\n					return TokenNameCOMMA;\r\n				case \'.\' :\r\n					if (getNextCharAsDigit())\r\n					return scanNumber(true);\r\n					return TokenNameDOT;\r\n				case \'+\' :\r\n					{\r\n						int test;\r\n						if ((test = getNextChar(\'+\', \'=\')) == 0)\r\n						return TokenNamePLUS_PLUS;\r\n						if (test > 0)\r\n						return TokenNamePLUS_EQUAL;\r\n						return TokenNamePLUS;\r\n					}\r\n				case \'-\' :\r\n					{\r\n						int test;\r\n						if ((test = getNextChar(\'-\', \'=\')) == 0)\r\n						return TokenNameMINUS_MINUS;\r\n						if (test > 0)\r\n						return TokenNameMINUS_EQUAL;\r\n						return TokenNameMINUS;\r\n					}\r\n				case \'~\' :\r\n					return TokenNameTWIDDLE;\r\n				case \'!\' :\r\n					if (getNextChar(\'=\'))\r\n					return TokenNameNOT_EQUAL;\r\n					return TokenNameNOT;\r\n				case \'*\' :\r\n					if (getNextChar(\'=\'))\r\n					return TokenNameMULTIPLY_EQUAL;\r\n					return TokenNameMULTIPLY;\r\n				case \'%\' :\r\n					if (getNextChar(\'=\'))\r\n					return TokenNameREMAINDER_EQUAL;\r\n					return TokenNameREMAINDER;\r\n				case \'<\' :\r\n					{\r\n						int test;\r\n						if ((test = getNextChar(\'=\', \'<\')) == 0)\r\n						return TokenNameLESS_EQUAL;\r\n						if (test > 0) {\r\n							if (getNextChar(\'=\'))\r\n							return TokenNameLEFT_SHIFT_EQUAL;\r\n							return TokenNameLEFT_SHIFT;\r\n						}\r\n						return TokenNameLESS;\r\n					}\r\n				case \'>\' :\r\n					{\r\n						int test;\r\n						if ((test = getNextChar(\'=\', \'>\')) == 0)\r\n						return TokenNameGREATER_EQUAL;\r\n						if (test > 0) {\r\n							if ((test = getNextChar(\'=\', \'>\')) == 0)\r\n							return TokenNameRIGHT_SHIFT_EQUAL;\r\n							if (test > 0) {\r\n								if (getNextChar(\'=\'))\r\n								return TokenNameUNSIGNED_RIGHT_SHIFT_EQUAL;\r\n								return TokenNameUNSIGNED_RIGHT_SHIFT;\r\n							}\r\n							return TokenNameRIGHT_SHIFT;\r\n						}\r\n						return TokenNameGREATER;\r\n					}\r\n				case \'=\' :\r\n					if (getNextChar(\'=\'))\r\n					return TokenNameEQUAL_EQUAL;\r\n					return TokenNameEQUAL;\r\n				case \'&\' :\r\n					{\r\n						int test;\r\n						if ((test = getNextChar(\'&\', \'=\')) == 0)\r\n						return TokenNameAND_AND;\r\n						if (test > 0)\r\n						return TokenNameAND_EQUAL;\r\n						return TokenNameAND;\r\n					}\r\n				case \'|\' :\r\n					{\r\n						int test;\r\n						if ((test = getNextChar(\'|\', \'=\')) == 0)\r\n						return TokenNameOR_OR;\r\n						if (test > 0)\r\n						return TokenNameOR_EQUAL;\r\n						return TokenNameOR;\r\n					}\r\n				case \'^\' :\r\n					if (getNextChar(\'=\'))\r\n					return TokenNameXOR_EQUAL;\r\n					return TokenNameXOR;\r\n				case \'?\' :\r\n					return TokenNameQUESTION;\r\n				case \':\' :\r\n					return TokenNameCOLON;\r\n				case \'\\\'\' :\r\n					{\r\n						int test;\r\n						if ((test = getNextChar(\'\\n\', \'\\r\')) == 0) {\r\n							throw new InvalidInputException(INVALID_CHARACTER_CONSTANT);\r\n						}\r\n						if (test > 0) {\r\n							// relocate if finding another quote fairly close: thus unicode \'/u000D\' will be fully consumed\r\n							for (int lookAhead = 0; lookAhead < 3; lookAhead++) {\r\n								if (currentPosition + lookAhead == source.length)\r\n								break;\r\n								if (source[currentPosition + lookAhead] == \'\\n\')\r\n								break;\r\n								if (source[currentPosition + lookAhead] == \'\\\'\') {\r\n									currentPosition += lookAhead + 1;\r\n									break;\r\n								}\r\n							}\r\n							throw new InvalidInputException(INVALID_CHARACTER_CONSTANT);\r\n						}\r\n					}\r\n					if (getNextChar(\'\\\'\')) {\r\n						// relocate if finding another quote fairly close: thus unicode \'/u000D\' will be fully consumed\r\n						for (int lookAhead = 0; lookAhead < 3; lookAhead++) {\r\n							if (currentPosition + lookAhead == source.length)\r\n							break;\r\n							if (source[currentPosition + lookAhead] == \'\\n\')\r\n							break;\r\n							if (source[currentPosition + lookAhead] == \'\\\'\') {\r\n								currentPosition += lookAhead + 1;\r\n								break;\r\n							}\r\n						}\r\n						throw new InvalidInputException(INVALID_CHARACTER_CONSTANT);\r\n					}\r\n					if (getNextChar(\'\\\\\'))\r\n					scanEscapeCharacter();\r\n					else { // consume next character\r\n						unicodeAsBackSlash = false;\r\n						boolean checkIfUnicode = false;\r\n						try {\r\n							checkIfUnicode = ((currentCharacter = source[currentPosition++]) == \'\\\\\')\r\n							&& (source[currentPosition] == \'u\');\r\n						} catch(IndexOutOfBoundsException e) {\r\n							if (currentPosition > eofPosition)\r\n							return TokenNameEOF;\r\n							throw new InvalidInputException(INVALID_CHARACTER_CONSTANT);\r\n						}\r\n						if (checkIfUnicode) {\r\n							getNextUnicodeChar();\r\n						} else {\r\n							if (withoutUnicodePtr != 0) {\r\n								withoutUnicodeBuffer[++withoutUnicodePtr] = currentCharacter;\r\n							}\r\n						}\r\n					}\r\n					if (getNextChar(\'\\\'\'))\r\n					return TokenNameCharacterLiteral;\r\n					// relocate if finding another quote fairly close: thus unicode \'/u000D\' will be fully consumed\r\n					for (int lookAhead = 0; lookAhead < 20; lookAhead++) {\r\n						if (currentPosition + lookAhead == source.length)\r\n						break;\r\n						if (source[currentPosition + lookAhead] == \'\\n\')\r\n						break;\r\n						if (source[currentPosition + lookAhead] == \'\\\'\') {\r\n							currentPosition += lookAhead + 1;\r\n							break;\r\n						}\r\n					}\r\n					throw new InvalidInputException(INVALID_CHARACTER_CONSTANT);\r\n				case \'\"\' :\r\n					try {\r\n						// consume next character\r\n						unicodeAsBackSlash = false;\r\n						if (((currentCharacter = source[currentPosition++]) == \'\\\\\')\r\n								&& (source[currentPosition] == \'u\')) {\r\n							getNextUnicodeChar();\r\n						} else {\r\n							if (withoutUnicodePtr != 0) {\r\n								withoutUnicodeBuffer[++withoutUnicodePtr] = currentCharacter;\r\n							}\r\n						}\r\n\r\n						while (currentCharacter != \'\"\') {\r\n							/**** \\r and \\n are not valid in string literals ****/\r\n							if ((currentCharacter == \'\\n\') || (currentCharacter == \'\\r\')) {\r\n								// relocate if finding another quote fairly close: thus unicode \'/u000D\' will be fully consumed\r\n								for (int lookAhead = 0; lookAhead < 50; lookAhead++) {\r\n									if (currentPosition + lookAhead == source.length)\r\n									break;\r\n									if (source[currentPosition + lookAhead] == \'\\n\')\r\n									break;\r\n									if (source[currentPosition + lookAhead] == \'\\\"\') {\r\n										currentPosition += lookAhead + 1;\r\n										break;\r\n									}\r\n								}\r\n								throw new InvalidInputException(INVALID_CHAR_IN_STRING);\r\n							}\r\n							if (currentCharacter == \'\\\\\') {\r\n								int escapeSize = currentPosition;\r\n								boolean backSlashAsUnicodeInString = unicodeAsBackSlash;\r\n								//scanEscapeCharacter make a side effect on this value and we need the previous value few lines down this one\r\n								scanEscapeCharacter();\r\n								escapeSize = currentPosition - escapeSize;\r\n								if (withoutUnicodePtr == 0) {\r\n									//buffer all the entries that have been left aside....\r\n									withoutUnicodePtr = currentPosition - escapeSize - 1 - startPosition;\r\n									System.arraycopy(\r\n									source, \r\n									startPosition, \r\n									withoutUnicodeBuffer, \r\n									1, \r\n									withoutUnicodePtr); \r\n									withoutUnicodeBuffer[++withoutUnicodePtr] = currentCharacter;\r\n								} else { //overwrite the / in the buffer\r\n									withoutUnicodeBuffer[withoutUnicodePtr] = currentCharacter;\r\n									if (backSlashAsUnicodeInString) { //there are TWO \\ in the stream where only one is correct\r\n										withoutUnicodePtr--;\r\n									}\r\n								}\r\n							}\r\n							// consume next character\r\n							unicodeAsBackSlash = false;\r\n							if (((currentCharacter = source[currentPosition++]) == \'\\\\\')\r\n									&& (source[currentPosition] == \'u\')) {\r\n								getNextUnicodeChar();\r\n							} else {\r\n								if (withoutUnicodePtr != 0) {\r\n									withoutUnicodeBuffer[++withoutUnicodePtr] = currentCharacter;\r\n								}\r\n							}\r\n\r\n						}\r\n					} catch (IndexOutOfBoundsException e) {\r\n						throw new InvalidInputException(UNTERMINATED_STRING);\r\n					} catch (InvalidInputException e) {\r\n						if (e.getMessage().equals(INVALID_ESCAPE)) {\r\n							// relocate if finding another quote fairly close: thus unicode \'/u000D\' will be fully consumed\r\n							for (int lookAhead = 0; lookAhead < 50; lookAhead++) {\r\n								if (currentPosition + lookAhead == source.length)\r\n								break;\r\n								if (source[currentPosition + lookAhead] == \'\\n\')\r\n								break;\r\n								if (source[currentPosition + lookAhead] == \'\\\"\') {\r\n									currentPosition += lookAhead + 1;\r\n									break;\r\n								}\r\n							}\r\n\r\n						}\r\n						throw e; // rethrow\r\n					}\r\n					if (checkNonExternalizedStringLiterals){ // check for presence of	NLS tags //$NON-NLS-?$ where ? is an int.\r\n						if (currentLine == null) {\r\n							currentLine = new NLSLine();\r\n						}\r\n						currentLine.add(\r\n						new StringLiteral(\r\n						getCurrentTokenSourceString(), \r\n						startPosition, \r\n						currentPosition - 1));\r\n					}\r\n					return TokenNameStringLiteral;\r\n				case \'/\' :\r\n					{\r\n						int test;\r\n						if ((test = getNextChar(\'/\', \'*\')) == 0) { //line comment \r\n							try { //get the next char \r\n								if (((currentCharacter = source[currentPosition++]) == \'\\\\\')\r\n										&& (source[currentPosition] == \'u\')) {\r\n									//-------------unicode traitement ------------\r\n									int c1 = 0, c2 = 0, c3 = 0, c4 = 0;\r\n									currentPosition++;\r\n									while (source[currentPosition] == \'u\') {\r\n										currentPosition++;\r\n									}\r\n									if ((c1 = Character.getNumericValue(source[currentPosition++])) > 15\r\n											|| c1 < 0\r\n											|| (c2 = Character.getNumericValue(source[currentPosition++])) > 15\r\n											|| c2 < 0\r\n											|| (c3 = Character.getNumericValue(source[currentPosition++])) > 15\r\n											|| c3 < 0\r\n											|| (c4 = Character.getNumericValue(source[currentPosition++])) > 15\r\n											|| c4 < 0) {\r\n										throw new InvalidInputException(INVALID_UNICODE_ESCAPE);\r\n									} else {\r\n										currentCharacter = (char) (((c1 * 16 + c2) * 16 + c3) * 16 + c4);\r\n									}\r\n								}\r\n\r\n								//handle the \\\\u case manually into comment\r\n								if (currentCharacter == \'\\\\\') {\r\n									if (source[currentPosition] == \'\\\\\')\r\n									currentPosition++;\r\n								} //jump over the \\\\\r\n								boolean isUnicode = false;\r\n								while (currentCharacter != \'\\r\' && currentCharacter != \'\\n\') {\r\n									//get the next char\r\n									isUnicode = false;									\r\n									if (((currentCharacter = source[currentPosition++]) == \'\\\\\')\r\n											&& (source[currentPosition] == \'u\')) {\r\n										isUnicode = true;											\r\n										//-------------unicode traitement ------------\r\n										int c1 = 0, c2 = 0, c3 = 0, c4 = 0;\r\n										currentPosition++;\r\n										while (source[currentPosition] == \'u\') {\r\n											currentPosition++;\r\n										}\r\n										if ((c1 = Character.getNumericValue(source[currentPosition++])) > 15\r\n												|| c1 < 0\r\n												|| (c2 = Character.getNumericValue(source[currentPosition++])) > 15\r\n												|| c2 < 0\r\n												|| (c3 = Character.getNumericValue(source[currentPosition++])) > 15\r\n												|| c3 < 0\r\n												|| (c4 = Character.getNumericValue(source[currentPosition++])) > 15\r\n												|| c4 < 0) {\r\n											throw new InvalidInputException(INVALID_UNICODE_ESCAPE);\r\n										} else {\r\n											currentCharacter = (char) (((c1 * 16 + c2) * 16 + c3) * 16 + c4);\r\n										}\r\n									}\r\n									//handle the \\\\u case manually into comment\r\n									if (currentCharacter == \'\\\\\') {\r\n										if (source[currentPosition] == \'\\\\\')\r\n										currentPosition++;\r\n									} //jump over the \\\\\r\n								}\r\n								/*\r\n								* We need to completely consume the line break\r\n								*/\r\n								if (currentCharacter == \'\\r\'\r\n										&& source.length > currentPosition) {\r\n									if (source[currentPosition] == \'\\n\') {\r\n										currentPosition++;\r\n										currentCharacter = \'\\n\';\r\n									} else if ((source[currentPosition] == \'\\\\\')\r\n											&& (source[currentPosition + 1] == \'u\')) {\r\n										isUnicode = true;\r\n										char unicodeChar;\r\n										int index = currentPosition + 1;\r\n										index++;\r\n										while (source[index] == \'u\') {\r\n											index++;\r\n										}\r\n										//-------------unicode traitement ------------\r\n										int c1 = 0, c2 = 0, c3 = 0, c4 = 0;\r\n										if ((c1 = Character.getNumericValue(source[index++])) > 15\r\n												|| c1 < 0\r\n												|| (c2 = Character.getNumericValue(source[index++])) > 15\r\n												|| c2 < 0\r\n												|| (c3 = Character.getNumericValue(source[index++])) > 15\r\n												|| c3 < 0\r\n												|| (c4 = Character.getNumericValue(source[index++])) > 15\r\n												|| c4 < 0) {\r\n											currentPosition = index;\r\n											throw new InvalidInputException(INVALID_UNICODE_ESCAPE);\r\n										} else {\r\n											unicodeChar = (char) (((c1 * 16 + c2) * 16 + c3) * 16 + c4);\r\n										}\r\n										if (unicodeChar == \'\\n\') {\r\n											currentPosition = index;\r\n											currentCharacter = \'\\n\';\r\n										}\r\n									}\r\n								}\r\n								recordComment(false);\r\n								if (this.taskTags != null) checkTaskTag(this.startPosition, this.currentPosition);\r\n								if ((currentCharacter == \'\\r\') || (currentCharacter == \'\\n\')) {\r\n									checkNonExternalizedString();\r\n									if (recordLineSeparator) {\r\n										if (isUnicode) {\r\n											pushUnicodeLineSeparator();\r\n										} else {\r\n											pushLineSeparator();\r\n										}\r\n									} else {\r\n										currentLine = null;\r\n									}\r\n								}\r\n								if (tokenizeComments) {\r\n									return TokenNameCOMMENT_LINE;\r\n								}\r\n							} catch (IndexOutOfBoundsException e) {\r\n								recordComment(false);\r\n								if (this.taskTags != null) checkTaskTag(this.startPosition, this.currentPosition-1);\r\n								if (tokenizeComments) {\r\n									this.currentPosition--; // reset one character behind\r\n									return TokenNameCOMMENT_LINE;\r\n								}\r\n							}\r\n							break;\r\n						}\r\n						if (test > 0) { //traditional and annotation comment\r\n							try { //get the next char\r\n								boolean isJavadoc = false, star = false;\r\n								boolean isUnicode = false;\r\n								// consume next character\r\n								unicodeAsBackSlash = false;\r\n								if (((currentCharacter = source[currentPosition++]) == \'\\\\\')\r\n										&& (source[currentPosition] == \'u\')) {\r\n									getNextUnicodeChar();\r\n									isUnicode = true;\r\n								} else {\r\n									isUnicode = false;\r\n									if (withoutUnicodePtr != 0) {\r\n										withoutUnicodeBuffer[++withoutUnicodePtr] = currentCharacter;\r\n									}\r\n								}\r\n								\r\n								if (currentCharacter == \'*\') {\r\n									isJavadoc = true;\r\n									star = true;\r\n								}\r\n								if ((currentCharacter == \'\\r\') || (currentCharacter == \'\\n\')) {\r\n									checkNonExternalizedString();\r\n									if (recordLineSeparator) {\r\n										if (!isUnicode) {\r\n											pushLineSeparator();\r\n										}\r\n									} else {\r\n										currentLine = null;\r\n									}\r\n								}\r\n								isUnicode = false;\r\n								if (((currentCharacter = source[currentPosition++]) == \'\\\\\')\r\n										&& (source[currentPosition] == \'u\')) {\r\n									//-------------unicode traitement ------------\r\n									getNextUnicodeChar();\r\n									isUnicode = true;\r\n								} else {\r\n									isUnicode = false;\r\n								}\r\n								//handle the \\\\u case manually into comment\r\n								if (currentCharacter == \'\\\\\') {\r\n									if (source[currentPosition] == \'\\\\\')\r\n									currentPosition++; //jump over the \\\\\r\n								}\r\n								//loop until end of comment */\r\n								while ((currentCharacter != \'/\') || (!star)) {\r\n									if ((currentCharacter == \'\\r\') || (currentCharacter == \'\\n\')) {\r\n										checkNonExternalizedString();\r\n										if (recordLineSeparator) {\r\n											if (!isUnicode) {\r\n												pushLineSeparator();\r\n											}\r\n										} else {\r\n											currentLine = null;\r\n										}\r\n									}\r\n									star = currentCharacter == \'*\';\r\n									//get next char\r\n									if (((currentCharacter = source[currentPosition++]) == \'\\\\\')\r\n											&& (source[currentPosition] == \'u\')) {\r\n										//-------------unicode traitement ------------\r\n										getNextUnicodeChar();\r\n										isUnicode = true;\r\n									} else {\r\n										isUnicode = false;\r\n									}\r\n									//handle the \\\\u case manually into comment\r\n									if (currentCharacter == \'\\\\\') {\r\n										if (source[currentPosition] == \'\\\\\')\r\n										currentPosition++;\r\n									} //jump over the \\\\\r\n								}\r\n								recordComment(isJavadoc);\r\n								if (this.taskTags != null) checkTaskTag(this.startPosition, this.currentPosition);\r\n								if (tokenizeComments) {\r\n									if (isJavadoc)\r\n									return TokenNameCOMMENT_JAVADOC;\r\n									return TokenNameCOMMENT_BLOCK;\r\n								}\r\n							} catch (IndexOutOfBoundsException e) {\r\n								throw new InvalidInputException(UNTERMINATED_COMMENT);\r\n							}\r\n							break;\r\n						}\r\n						if (getNextChar(\'=\'))\r\n						return TokenNameDIVIDE_EQUAL;\r\n						return TokenNameDIVIDE;\r\n					}\r\n				case \'\\u001a\' :\r\n					if (atEnd())\r\n					return TokenNameEOF;\r\n					//the atEnd may not be <currentPosition == source.length> if source is only some part of a real (external) stream\r\n					throw new InvalidInputException(\"Ctrl-Z\"); //$NON-NLS-1$\r\n\r\n					default :\r\n					if (Character.isJavaIdentifierStart(currentCharacter))\r\n					return scanIdentifierOrKeyword();\r\n					if (Character.isDigit(currentCharacter))\r\n					return scanNumber(false);\r\n					return TokenNameERROR;\r\n				}\r\n			}\r\n		} //-----------------end switch while try--------------------\r\n		catch (IndexOutOfBoundsException e) {\r\n			if (tokenizeWhiteSpace && (whiteStart != currentPosition - 1)) {\r\n				// reposition scanner in case we are interested by spaces as tokens\r\n				currentPosition--;\r\n				startPosition = whiteStart;\r\n				return TokenNameWHITESPACE;\r\n			}\r\n		}\r\n		return TokenNameEOF;\r\n	}\r\n	public final void getNextUnicodeChar()\r\n	throws IndexOutOfBoundsException, InvalidInputException {\r\n		//VOID\r\n		//handle the case of unicode.\r\n		//when a unicode appears then we must use a buffer that holds char internal values\r\n		//At the end of this method currentCharacter holds the new visited char\r\n		//and currentPosition points right next after it\r\n\r\n		//ALL getNextChar.... ARE OPTIMIZED COPIES \r\n\r\n		int c1 = 0, c2 = 0, c3 = 0, c4 = 0, unicodeSize = 6;\r\n		currentPosition++;\r\n		while (source[currentPosition] == \'u\') {\r\n			currentPosition++;\r\n			unicodeSize++;\r\n		}\r\n\r\n		if ((c1 = Character.getNumericValue(source[currentPosition++])) > 15\r\n				|| c1 < 0\r\n				|| (c2 = Character.getNumericValue(source[currentPosition++])) > 15\r\n				|| c2 < 0\r\n				|| (c3 = Character.getNumericValue(source[currentPosition++])) > 15\r\n				|| c3 < 0\r\n				|| (c4 = Character.getNumericValue(source[currentPosition++])) > 15\r\n				|| c4 < 0){\r\n			throw new InvalidInputException(INVALID_UNICODE_ESCAPE);\r\n		} else {\r\n			currentCharacter = (char) (((c1 * 16 + c2) * 16 + c3) * 16 + c4);\r\n			//need the unicode buffer\r\n			if (withoutUnicodePtr == 0) {\r\n				//buffer all the entries that have been left aside....\r\n				withoutUnicodePtr = currentPosition - unicodeSize - startPosition;\r\n				System.arraycopy(\r\n				source, \r\n				startPosition, \r\n				withoutUnicodeBuffer, \r\n				1, \r\n				withoutUnicodePtr); \r\n			}\r\n			//fill the buffer with the char\r\n			withoutUnicodeBuffer[++withoutUnicodePtr] = currentCharacter;\r\n		}\r\n		unicodeAsBackSlash = currentCharacter == \'\\\\\';\r\n	}\r\n\r\n	public char[] getSource(){\r\n		return this.source;\r\n	}\r\n\r\n	/* Tokenize a method body, assuming that curly brackets are properly balanced.\r\n*/\r\n	public final void jumpOverMethodBody() {\r\n\r\n		this.wasAcr = false;\r\n		int found = 1;\r\n		try {\r\n			while (true) { //loop for jumping over comments\r\n				// ---------Consume white space and handles startPosition---------\r\n				boolean isWhiteSpace;\r\n				do {\r\n					startPosition = currentPosition;\r\n					if (((currentCharacter = source[currentPosition++]) == \'\\\\\')\r\n							&& (source[currentPosition] == \'u\')) {\r\n						isWhiteSpace = jumpOverUnicodeWhiteSpace();\r\n					} else {\r\n						if (recordLineSeparator\r\n								&& ((currentCharacter == \'\\r\') || (currentCharacter == \'\\n\')))\r\n						pushLineSeparator();\r\n						isWhiteSpace = CharOperation.isWhitespace(currentCharacter);\r\n					}\r\n				} while (isWhiteSpace);\r\n\r\n				// -------consume token until } is found---------\r\n				switch (currentCharacter) {\r\n				case \'{\' :\r\n					found++;\r\n					break;\r\n				case \'}\' :\r\n					found--;\r\n					if (found == 0)\r\n					return;\r\n					break;\r\n				case \'\\\'\' :\r\n					{\r\n						boolean test;\r\n						test = getNextChar(\'\\\\\');\r\n						if (test) {\r\n							try {\r\n								scanEscapeCharacter();\r\n							} catch (InvalidInputException ex) {\r\n							}\r\n						} else {\r\n							try { // consume next character\r\n								unicodeAsBackSlash = false;\r\n								if (((currentCharacter = source[currentPosition++]) == \'\\\\\')\r\n										&& (source[currentPosition] == \'u\')) {\r\n									getNextUnicodeChar();\r\n								} else {\r\n									if (withoutUnicodePtr != 0) {\r\n										withoutUnicodeBuffer[++withoutUnicodePtr] = currentCharacter;\r\n									}\r\n								}\r\n							} catch (InvalidInputException ex) {\r\n							}\r\n						}\r\n						getNextChar(\'\\\'\');\r\n						break;\r\n					}\r\n				case \'\"\' :\r\n					try {\r\n						try { // consume next character\r\n							unicodeAsBackSlash = false;\r\n							if (((currentCharacter = source[currentPosition++]) == \'\\\\\')\r\n									&& (source[currentPosition] == \'u\')) {\r\n								getNextUnicodeChar();\r\n							} else {\r\n								if (withoutUnicodePtr != 0) {\r\n									withoutUnicodeBuffer[++withoutUnicodePtr] = currentCharacter;\r\n								}\r\n							}\r\n						} catch (InvalidInputException ex) {\r\n						}\r\n						while (currentCharacter != \'\"\') {\r\n							if (currentCharacter == \'\\r\'){\r\n								if (source[currentPosition] == \'\\n\') currentPosition++;\r\n								break; // the string cannot go further that the line\r\n							}\r\n							if (currentCharacter == \'\\n\'){\r\n								break; // the string cannot go further that the line\r\n							}\r\n							if (currentCharacter == \'\\\\\') {\r\n								try {\r\n									scanEscapeCharacter();\r\n								} catch (InvalidInputException ex) {\r\n								}\r\n							}\r\n							try { // consume next character\r\n								unicodeAsBackSlash = false;\r\n								if (((currentCharacter = source[currentPosition++]) == \'\\\\\')\r\n										&& (source[currentPosition] == \'u\')) {\r\n									getNextUnicodeChar();\r\n								} else {\r\n									if (withoutUnicodePtr != 0) {\r\n										withoutUnicodeBuffer[++withoutUnicodePtr] = currentCharacter;\r\n									}\r\n								}\r\n							} catch (InvalidInputException ex) {\r\n							}\r\n						}\r\n					} catch (IndexOutOfBoundsException e) {\r\n						return;\r\n					}\r\n					break;\r\n				case \'/\' :\r\n					{\r\n						int test;\r\n						boolean isUnicode;\r\n						if ((test = getNextChar(\'/\', \'*\')) == 0) { //line comment \r\n							try {\r\n								//get the next char \r\n								if (((currentCharacter = source[currentPosition++]) == \'\\\\\')\r\n										&& (source[currentPosition] == \'u\')) {\r\n									//-------------unicode traitement ------------\r\n									isUnicode = true;\r\n									int c1 = 0, c2 = 0, c3 = 0, c4 = 0;\r\n									currentPosition++;\r\n									while (source[currentPosition] == \'u\') {\r\n										currentPosition++;\r\n									}\r\n									if ((c1 = Character.getNumericValue(source[currentPosition++])) > 15\r\n											|| c1 < 0\r\n											|| (c2 = Character.getNumericValue(source[currentPosition++])) > 15\r\n											|| c2 < 0\r\n											|| (c3 = Character.getNumericValue(source[currentPosition++])) > 15\r\n											|| c3 < 0\r\n											|| (c4 = Character.getNumericValue(source[currentPosition++])) > 15\r\n											|| c4 < 0) { //error don\'t care of the value\r\n										currentCharacter = \'A\';\r\n									} //something different from \\n and \\r\r\n									else {\r\n										currentCharacter = (char) (((c1 * 16 + c2) * 16 + c3) * 16 + c4);\r\n									}\r\n								} else {\r\n									isUnicode = false;\r\n								}\r\n\r\n								while (currentCharacter != \'\\r\' && currentCharacter != \'\\n\') {\r\n									//get the next char \r\n									if (((currentCharacter = source[currentPosition++]) == \'\\\\\')\r\n											&& (source[currentPosition] == \'u\')) {\r\n										//-------------unicode traitement ------------\r\n										int c1 = 0, c2 = 0, c3 = 0, c4 = 0;\r\n										currentPosition++;\r\n										isUnicode = true;\r\n										while (source[currentPosition] == \'u\') {\r\n											currentPosition++;\r\n										}\r\n										if ((c1 = Character.getNumericValue(source[currentPosition++])) > 15\r\n												|| c1 < 0\r\n												|| (c2 = Character.getNumericValue(source[currentPosition++])) > 15\r\n												|| c2 < 0\r\n												|| (c3 = Character.getNumericValue(source[currentPosition++])) > 15\r\n												|| c3 < 0\r\n												|| (c4 = Character.getNumericValue(source[currentPosition++])) > 15\r\n												|| c4 < 0) { //error don\'t care of the value\r\n											currentCharacter = \'A\';\r\n										} //something different from \\n and \\r\r\n										else {\r\n											currentCharacter = (char) (((c1 * 16 + c2) * 16 + c3) * 16 + c4);\r\n										}\r\n									} else {\r\n										isUnicode = false;\r\n									}\r\n								}\r\n								if (recordLineSeparator\r\n										&& ((currentCharacter == \'\\r\') || (currentCharacter == \'\\n\'))) {\r\n									if (!isUnicode) {\r\n										pushLineSeparator();\r\n									}\r\n								}\r\n							} catch (IndexOutOfBoundsException e) {\r\n							} //an eof will them be generated\r\n							break;\r\n						}\r\n						if (test > 0) { //traditional and annotation comment\r\n							isUnicode = false;\r\n							boolean star = false;\r\n							try { // consume next character\r\n								unicodeAsBackSlash = false;\r\n								if (((currentCharacter = source[currentPosition++]) == \'\\\\\')\r\n										&& (source[currentPosition] == \'u\')) {\r\n									getNextUnicodeChar();\r\n									isUnicode = true;\r\n								} else {\r\n									isUnicode = false;\r\n									if (withoutUnicodePtr != 0) {\r\n										withoutUnicodeBuffer[++withoutUnicodePtr] = currentCharacter;\r\n									}\r\n								}\r\n							} catch (InvalidInputException ex) {\r\n							}\r\n							if (currentCharacter == \'*\') {\r\n								star = true;\r\n							}\r\n							if (recordLineSeparator\r\n									&& ((currentCharacter == \'\\r\') || (currentCharacter == \'\\n\'))) {\r\n								if (!isUnicode) {\r\n									pushLineSeparator();\r\n								}\r\n							}\r\n							try { //get the next char \r\n								if (((currentCharacter = source[currentPosition++]) == \'\\\\\')\r\n										&& (source[currentPosition] == \'u\')) {\r\n									//-------------unicode traitement ------------\r\n									isUnicode = true;\r\n									int c1 = 0, c2 = 0, c3 = 0, c4 = 0;\r\n									currentPosition++;\r\n									while (source[currentPosition] == \'u\') {\r\n										currentPosition++;\r\n									}\r\n									if ((c1 = Character.getNumericValue(source[currentPosition++])) > 15\r\n											|| c1 < 0\r\n											|| (c2 = Character.getNumericValue(source[currentPosition++])) > 15\r\n											|| c2 < 0\r\n											|| (c3 = Character.getNumericValue(source[currentPosition++])) > 15\r\n											|| c3 < 0\r\n											|| (c4 = Character.getNumericValue(source[currentPosition++])) > 15\r\n											|| c4 < 0) { //error don\'t care of the value\r\n										currentCharacter = \'A\';\r\n									} //something different from * and /\r\n									else {\r\n										currentCharacter = (char) (((c1 * 16 + c2) * 16 + c3) * 16 + c4);\r\n									}\r\n								} else {\r\n									isUnicode = false;\r\n								}\r\n								//loop until end of comment */ \r\n								while ((currentCharacter != \'/\') || (!star)) {\r\n									if (recordLineSeparator\r\n											&& ((currentCharacter == \'\\r\') || (currentCharacter == \'\\n\'))) {\r\n										if (!isUnicode) {\r\n											pushLineSeparator();\r\n										}\r\n									}\r\n									star = currentCharacter == \'*\';\r\n									//get next char\r\n									if (((currentCharacter = source[currentPosition++]) == \'\\\\\')\r\n											&& (source[currentPosition] == \'u\')) {\r\n										//-------------unicode traitement ------------\r\n										isUnicode = true;\r\n										int c1 = 0, c2 = 0, c3 = 0, c4 = 0;\r\n										currentPosition++;\r\n										while (source[currentPosition] == \'u\') {\r\n											currentPosition++;\r\n										}\r\n										if ((c1 = Character.getNumericValue(source[currentPosition++])) > 15\r\n												|| c1 < 0\r\n												|| (c2 = Character.getNumericValue(source[currentPosition++])) > 15\r\n												|| c2 < 0\r\n												|| (c3 = Character.getNumericValue(source[currentPosition++])) > 15\r\n												|| c3 < 0\r\n												|| (c4 = Character.getNumericValue(source[currentPosition++])) > 15\r\n												|| c4 < 0) { //error don\'t care of the value\r\n											currentCharacter = \'A\';\r\n										} //something different from * and /\r\n										else {\r\n											currentCharacter = (char) (((c1 * 16 + c2) * 16 + c3) * 16 + c4);\r\n										}\r\n									} else {\r\n										isUnicode = false;\r\n									}\r\n								}\r\n							} catch (IndexOutOfBoundsException e) {\r\n								return;\r\n							}\r\n							break;\r\n						}\r\n						break;\r\n					}\r\n\r\n					default :\r\n					if (Character.isJavaIdentifierStart(currentCharacter)) {\r\n						try {\r\n							scanIdentifierOrKeyword();\r\n						} catch (InvalidInputException ex) {\r\n						}\r\n						break;\r\n					}\r\n					if (Character.isDigit(currentCharacter)) {\r\n						try {\r\n							scanNumber(false);\r\n						} catch (InvalidInputException ex) {\r\n						}\r\n						break;\r\n					}\r\n				}\r\n			}\r\n			//-----------------end switch while try--------------------\r\n		} catch (IndexOutOfBoundsException e) {\r\n		} catch (InvalidInputException e) {\r\n		}\r\n		return;\r\n	}\r\n	public final boolean jumpOverUnicodeWhiteSpace() throws InvalidInputException {\r\n		//BOOLEAN\r\n		//handle the case of unicode. Jump over the next whiteSpace\r\n		//making startPosition pointing on the next available char\r\n		//On false, the currentCharacter is filled up with a potential\r\n		//correct char\r\n\r\n		try {\r\n			this.wasAcr = false;\r\n			int c1, c2, c3, c4;\r\n			int unicodeSize = 6;\r\n			currentPosition++;\r\n			while (source[currentPosition] == \'u\') {\r\n				currentPosition++;\r\n				unicodeSize++;\r\n			}\r\n\r\n			if (((c1 = Character.getNumericValue(source[currentPosition++])) > 15\r\n						|| c1 < 0)\r\n					|| ((c2 = Character.getNumericValue(source[currentPosition++])) > 15 || c2 < 0)\r\n					|| ((c3 = Character.getNumericValue(source[currentPosition++])) > 15 || c3 < 0)\r\n					|| ((c4 = Character.getNumericValue(source[currentPosition++])) > 15 || c4 < 0)) {\r\n				throw new InvalidInputException(INVALID_UNICODE_ESCAPE);\r\n			}\r\n\r\n			currentCharacter = (char) (((c1 * 16 + c2) * 16 + c3) * 16 + c4);\r\n			if (CharOperation.isWhitespace(currentCharacter))\r\n			return true;\r\n\r\n			//buffer the new char which is not a white space\r\n			withoutUnicodeBuffer[++withoutUnicodePtr] = currentCharacter;\r\n			//withoutUnicodePtr == 1 is true here\r\n			return false;\r\n		} catch (IndexOutOfBoundsException e){\r\n			throw new InvalidInputException(INVALID_UNICODE_ESCAPE);\r\n		}\r\n	}\r\n\r\n	final char[] optimizedCurrentTokenSource1() {\r\n		//return always the same char[] build only once\r\n\r\n		//optimization at no speed cost of 99.5 % of the singleCharIdentifier\r\n		char charOne = source[startPosition];\r\n		switch (charOne) {\r\n		case \'a\' :\r\n			return charArray_a;\r\n		case \'b\' :\r\n			return charArray_b;\r\n		case \'c\' :\r\n			return charArray_c;\r\n		case \'d\' :\r\n			return charArray_d;\r\n		case \'e\' :\r\n			return charArray_e;\r\n		case \'f\' :\r\n			return charArray_f;\r\n		case \'g\' :\r\n			return charArray_g;\r\n		case \'h\' :\r\n			return charArray_h;\r\n		case \'i\' :\r\n			return charArray_i;\r\n		case \'j\' :\r\n			return charArray_j;\r\n		case \'k\' :\r\n			return charArray_k;\r\n		case \'l\' :\r\n			return charArray_l;\r\n		case \'m\' :\r\n			return charArray_m;\r\n		case \'n\' :\r\n			return charArray_n;\r\n		case \'o\' :\r\n			return charArray_o;\r\n		case \'p\' :\r\n			return charArray_p;\r\n		case \'q\' :\r\n			return charArray_q;\r\n		case \'r\' :\r\n			return charArray_r;\r\n		case \'s\' :\r\n			return charArray_s;\r\n		case \'t\' :\r\n			return charArray_t;\r\n		case \'u\' :\r\n			return charArray_u;\r\n		case \'v\' :\r\n			return charArray_v;\r\n		case \'w\' :\r\n			return charArray_w;\r\n		case \'x\' :\r\n			return charArray_x;\r\n		case \'y\' :\r\n			return charArray_y;\r\n		case \'z\' :\r\n			return charArray_z;\r\n			default :\r\n			return new char[] {charOne};\r\n		}\r\n	}\r\n	final char[] optimizedCurrentTokenSource2() {\r\n		//try to return the same char[] build only once\r\n\r\n		char c0, c1;\r\n		int hash = \r\n		(((c0 = source[startPosition]) << 6) + (c1 = source[startPosition + 1]))\r\n		% TableSize; \r\n		char[][] table = charArray_length[0][hash];\r\n		int i = newEntry2;\r\n		while (++i < InternalTableSize) {\r\n			char[] charArray = table[i];\r\n			if ((c0 == charArray[0]) && (c1 == charArray[1]))\r\n			return charArray;\r\n		}\r\n		//---------other side---------\r\n		i = -1;\r\n		int max = newEntry2;\r\n		while (++i <= max) {\r\n			char[] charArray = table[i];\r\n			if ((c0 == charArray[0]) && (c1 == charArray[1]))\r\n			return charArray;\r\n		}\r\n		//--------add the entry-------\r\n		if (++max >= InternalTableSize) max = 0;\r\n		char[] r;\r\n		table[max] = (r = new char[] {c0, c1});\r\n		newEntry2 = max;\r\n		return r;\r\n	}\r\n	final char[] optimizedCurrentTokenSource3() {\r\n		//try to return the same char[] build only once\r\n\r\n		char c0, c1, c2;\r\n		int hash = \r\n		(((c0 = source[startPosition]) << 12)\r\n		+ ((c1 = source[startPosition + 1]) << 6)\r\n		+ (c2 = source[startPosition + 2]))\r\n		% TableSize; \r\n		char[][] table = charArray_length[1][hash];\r\n		int i = newEntry3;\r\n		while (++i < InternalTableSize) {\r\n			char[] charArray = table[i];\r\n			if ((c0 == charArray[0]) && (c1 == charArray[1]) && (c2 == charArray[2]))\r\n			return charArray;\r\n		}\r\n		//---------other side---------\r\n		i = -1;\r\n		int max = newEntry3;\r\n		while (++i <= max) {\r\n			char[] charArray = table[i];\r\n			if ((c0 == charArray[0]) && (c1 == charArray[1]) && (c2 == charArray[2]))\r\n			return charArray;\r\n		}\r\n		//--------add the entry-------\r\n		if (++max >= InternalTableSize) max = 0;\r\n		char[] r;\r\n		table[max] = (r = new char[] {c0, c1, c2});\r\n		newEntry3 = max;\r\n		return r;\r\n	}\r\n	final char[] optimizedCurrentTokenSource4() {\r\n		//try to return the same char[] build only once\r\n\r\n		char c0, c1, c2, c3;\r\n		long hash = \r\n		((((long) (c0 = source[startPosition])) << 18)\r\n		+ ((c1 = source[startPosition + 1]) << 12)\r\n		+ ((c2 = source[startPosition + 2]) << 6)\r\n		+ (c3 = source[startPosition + 3]))\r\n		% TableSize; \r\n		char[][] table = charArray_length[2][(int) hash];\r\n		int i = newEntry4;\r\n		while (++i < InternalTableSize) {\r\n			char[] charArray = table[i];\r\n			if ((c0 == charArray[0])\r\n					&& (c1 == charArray[1])\r\n					&& (c2 == charArray[2])\r\n					&& (c3 == charArray[3]))\r\n			return charArray;\r\n		}\r\n		//---------other side---------\r\n		i = -1;\r\n		int max = newEntry4;\r\n		while (++i <= max) {\r\n			char[] charArray = table[i];\r\n			if ((c0 == charArray[0])\r\n					&& (c1 == charArray[1])\r\n					&& (c2 == charArray[2])\r\n					&& (c3 == charArray[3]))\r\n			return charArray;\r\n		}\r\n		//--------add the entry-------\r\n		if (++max >= InternalTableSize) max = 0;\r\n		char[] r;\r\n		table[max] = (r = new char[] {c0, c1, c2, c3});\r\n		newEntry4 = max;\r\n		return r;\r\n		\r\n	}\r\n	final char[] optimizedCurrentTokenSource5() {\r\n		//try to return the same char[] build only once\r\n\r\n		char c0, c1, c2, c3, c4;\r\n		long hash = \r\n		((((long) (c0 = source[startPosition])) << 24)\r\n		+ (((long) (c1 = source[startPosition + 1])) << 18)\r\n		+ ((c2 = source[startPosition + 2]) << 12)\r\n		+ ((c3 = source[startPosition + 3]) << 6)\r\n		+ (c4 = source[startPosition + 4]))\r\n		% TableSize; \r\n		char[][] table = charArray_length[3][(int) hash];\r\n		int i = newEntry5;\r\n		while (++i < InternalTableSize) {\r\n			char[] charArray = table[i];\r\n			if ((c0 == charArray[0])\r\n					&& (c1 == charArray[1])\r\n					&& (c2 == charArray[2])\r\n					&& (c3 == charArray[3])\r\n					&& (c4 == charArray[4]))\r\n			return charArray;\r\n		}\r\n		//---------other side---------\r\n		i = -1;\r\n		int max = newEntry5;\r\n		while (++i <= max) {\r\n			char[] charArray = table[i];\r\n			if ((c0 == charArray[0])\r\n					&& (c1 == charArray[1])\r\n					&& (c2 == charArray[2])\r\n					&& (c3 == charArray[3])\r\n					&& (c4 == charArray[4]))\r\n			return charArray;\r\n		}\r\n		//--------add the entry-------\r\n		if (++max >= InternalTableSize) max = 0;\r\n		char[] r;\r\n		table[max] = (r = new char[] {c0, c1, c2, c3, c4});\r\n		newEntry5 = max;\r\n		return r;\r\n		\r\n	}\r\n	final char[] optimizedCurrentTokenSource6() {\r\n		//try to return the same char[] build only once\r\n\r\n		char c0, c1, c2, c3, c4, c5;\r\n		long hash = \r\n		((((long) (c0 = source[startPosition])) << 32)\r\n		+ (((long) (c1 = source[startPosition + 1])) << 24)\r\n		+ (((long) (c2 = source[startPosition + 2])) << 18)\r\n		+ ((c3 = source[startPosition + 3]) << 12)\r\n		+ ((c4 = source[startPosition + 4]) << 6)\r\n		+ (c5 = source[startPosition + 5]))\r\n		% TableSize; \r\n		char[][] table = charArray_length[4][(int) hash];\r\n		int i = newEntry6;\r\n		while (++i < InternalTableSize) {\r\n			char[] charArray = table[i];\r\n			if ((c0 == charArray[0])\r\n					&& (c1 == charArray[1])\r\n					&& (c2 == charArray[2])\r\n					&& (c3 == charArray[3])\r\n					&& (c4 == charArray[4])\r\n					&& (c5 == charArray[5]))\r\n			return charArray;\r\n		}\r\n		//---------other side---------\r\n		i = -1;\r\n		int max = newEntry6;\r\n		while (++i <= max) {\r\n			char[] charArray = table[i];\r\n			if ((c0 == charArray[0])\r\n					&& (c1 == charArray[1])\r\n					&& (c2 == charArray[2])\r\n					&& (c3 == charArray[3])\r\n					&& (c4 == charArray[4])\r\n					&& (c5 == charArray[5]))\r\n			return charArray;\r\n		}\r\n		//--------add the entry-------\r\n		if (++max >= InternalTableSize) max = 0;\r\n		char[] r;\r\n		table[max] = (r = new char[] {c0, c1, c2, c3, c4, c5});\r\n		newEntry6 = max;\r\n		return r;	\r\n	}\r\n	private void parseTags(NLSLine line) throws InvalidInputException {\r\n		String s = new String(getCurrentTokenSource());\r\n		int pos = s.indexOf(TAG_PREFIX);\r\n		int lineLength = line.size();\r\n		while (pos != -1) {\r\n			int start = pos + TAG_PREFIX_LENGTH;\r\n			int end = s.indexOf(TAG_POSTFIX, start);\r\n			if (end != -1) {\r\n				String index = s.substring(start, end);\r\n				int i = 0;\r\n				try {\r\n					i = Integer.parseInt(index) - 1; // Tags are one based not zero based.\r\n				} catch (NumberFormatException e) {\r\n					i = -1; // we don\'t want to consider this as a valid NLS tag\r\n				}\r\n				if (line.exists(i)) {\r\n					line.set(i, null);\r\n				}\r\n			}\r\n			pos = s.indexOf(TAG_PREFIX, start);\r\n		}\r\n\r\n		this.nonNLSStrings = new StringLiteral[lineLength];\r\n		int nonNLSCounter = 0;\r\n		for (Iterator iterator = line.iterator(); iterator.hasNext(); ) {\r\n			StringLiteral literal = (StringLiteral) iterator.next();\r\n			if (literal != null) {\r\n				this.nonNLSStrings[nonNLSCounter++] = literal;\r\n			}\r\n		}\r\n		if (nonNLSCounter == 0) {\r\n			this.nonNLSStrings = null;\r\n			currentLine = null;\r\n			return;\r\n		} \r\n		this.wasNonExternalizedStringLiteral = true;\r\n		if (nonNLSCounter != lineLength) {\r\n			System.arraycopy(this.nonNLSStrings, 0, (this.nonNLSStrings = new StringLiteral[nonNLSCounter]), 0, nonNLSCounter);\r\n		}\r\n		currentLine = null;\r\n	}\r\n\r\n	public final void pushLineSeparator() throws InvalidInputException {\r\n		//see comment on isLineDelimiter(char) for the use of \'\\n\' and \'\\r\'\r\n		final int INCREMENT = 250;\r\n		\r\n		if (this.checkNonExternalizedStringLiterals) {\r\n			// reinitialize the current line for non externalize strings purpose\r\n			currentLine = null;\r\n		}\r\n		//currentCharacter is at position currentPosition-1\r\n\r\n		// cr 000D\r\n		if (currentCharacter == \'\\r\') {\r\n			int separatorPos = currentPosition - 1;\r\n			//TODO : (olivier) david - why the following line was \"if ((linePtr > 0) && (lineEnds[linePtr] >= separatorPos)) return;\" ?\r\n			if ((linePtr >= 0) && (lineEnds[linePtr] >= separatorPos)) return;\r\n			//System.out.println(\"CR-\" + separatorPos);\r\n			try {\r\n				lineEnds[++linePtr] = separatorPos;\r\n			} catch (IndexOutOfBoundsException e) {\r\n				//linePtr value is correct\r\n				int oldLength = lineEnds.length;\r\n				int[] old = lineEnds;\r\n				lineEnds = new int[oldLength + INCREMENT];\r\n				System.arraycopy(old, 0, lineEnds, 0, oldLength);\r\n				lineEnds[linePtr] = separatorPos;\r\n			}\r\n			// look-ahead for merged cr+lf\r\n			try {\r\n				if (source[currentPosition] == \'\\n\') {\r\n					//System.out.println(\"look-ahead LF-\" + currentPosition);			\r\n					lineEnds[linePtr] = currentPosition;\r\n					currentPosition++;\r\n					wasAcr = false;\r\n				} else {\r\n					wasAcr = true;\r\n				}\r\n			} catch(IndexOutOfBoundsException e) {\r\n				wasAcr = true;\r\n			}\r\n		} else {\r\n			// lf 000A\r\n			if (currentCharacter == \'\\n\') { //must merge eventual cr followed by lf\r\n				if (wasAcr && (lineEnds[linePtr] == (currentPosition - 2))) {\r\n					//System.out.println(\"merge LF-\" + (currentPosition - 1));							\r\n					lineEnds[linePtr] = currentPosition - 1;\r\n				} else {\r\n					int separatorPos = currentPosition - 1;\r\n					//TODO : (olivier) david - why the following line was \"if ((linePtr > 0) && (lineEnds[linePtr] >= separatorPos)) return;\" ?\r\n					if ((linePtr >= 0) && (lineEnds[linePtr] >= separatorPos)) return;\r\n					// System.out.println(\"LF-\" + separatorPos);							\r\n					try {\r\n						lineEnds[++linePtr] = separatorPos;\r\n					} catch (IndexOutOfBoundsException e) {\r\n						//linePtr value is correct\r\n						int oldLength = lineEnds.length;\r\n						int[] old = lineEnds;\r\n						lineEnds = new int[oldLength + INCREMENT];\r\n						System.arraycopy(old, 0, lineEnds, 0, oldLength);\r\n						lineEnds[linePtr] = separatorPos;\r\n					}\r\n				}\r\n				wasAcr = false;\r\n			}\r\n		}\r\n	}\r\n	public final void pushUnicodeLineSeparator() {\r\n		if (this.checkNonExternalizedStringLiterals) {\r\n			// reinitialize the current line for non externalize strings purpose\r\n			currentLine = null;\r\n		}\r\n		\r\n		// cr 000D\r\n		if (currentCharacter == \'\\r\') {\r\n			if (source[currentPosition] == \'\\n\') {\r\n				wasAcr = false;\r\n			} else {\r\n				wasAcr = true;\r\n			}\r\n		} else {\r\n			// lf 000A\r\n			if (currentCharacter == \'\\n\') { //must merge eventual cr followed by lf\r\n				wasAcr = false;\r\n			}\r\n		}\r\n	}\r\n	public final void recordComment(boolean isJavadoc) {\r\n\r\n		// a new annotation comment is recorded\r\n		try {\r\n			this.commentStops[++this.commentPtr] = isJavadoc ? this.currentPosition : -this.currentPosition;\r\n		} catch (IndexOutOfBoundsException e) {\r\n			int oldStackLength = this.commentStops.length;\r\n			int[] oldStack = this.commentStops;\r\n			this.commentStops = new int[oldStackLength + 30];\r\n			System.arraycopy(oldStack, 0, this.commentStops, 0, oldStackLength);\r\n			this.commentStops[this.commentPtr] = isJavadoc ? this.currentPosition : -this.currentPosition;\r\n			//grows the positions buffers too\r\n			int[] old = this.commentStarts;\r\n			this.commentStarts = new int[oldStackLength + 30];\r\n			System.arraycopy(old, 0, this.commentStarts, 0, oldStackLength);\r\n		}\r\n\r\n		//the buffer is of a correct size here\r\n		this.commentStarts[this.commentPtr] = this.startPosition;\r\n	}\r\n\r\n	public void resetTo(int begin, int end) {\r\n		//reset the scanner to a given position where it may rescan again\r\n\r\n		diet = false;\r\n		initialPosition = startPosition = currentPosition = begin;\r\n		eofPosition = end < Integer.MAX_VALUE ? end + 1 : end;\r\n		commentPtr = -1; // reset comment stack\r\n		foundTaskCount = 0;\r\n\r\n	}\r\n\r\n	public final void scanEscapeCharacter() throws InvalidInputException {\r\n		// the string with \"\\\\u\" is a legal string of two chars \\ and u\r\n		//thus we use a direct access to the source (for regular cases).\r\n\r\n		if (unicodeAsBackSlash) {\r\n			// consume next character\r\n			unicodeAsBackSlash = false;\r\n			if (((currentCharacter = source[currentPosition++]) == \'\\\\\') && (source[currentPosition] == \'u\')) {\r\n				getNextUnicodeChar();\r\n			} else {\r\n				if (withoutUnicodePtr != 0) {\r\n					withoutUnicodeBuffer[++withoutUnicodePtr] = currentCharacter;\r\n				}\r\n			}\r\n		} else\r\n		currentCharacter = source[currentPosition++];\r\n		switch (currentCharacter) {\r\n		case \'b\' :\r\n			currentCharacter = \'\\b\';\r\n			break;\r\n		case \'t\' :\r\n			currentCharacter = \'\\t\';\r\n			break;\r\n		case \'n\' :\r\n			currentCharacter = \'\\n\';\r\n			break;\r\n		case \'f\' :\r\n			currentCharacter = \'\\f\';\r\n			break;\r\n		case \'r\' :\r\n			currentCharacter = \'\\r\';\r\n			break;\r\n		case \'\\\"\' :\r\n			currentCharacter = \'\\\"\';\r\n			break;\r\n		case \'\\\'\' :\r\n			currentCharacter = \'\\\'\';\r\n			break;\r\n		case \'\\\\\' :\r\n			currentCharacter = \'\\\\\';\r\n			break;\r\n			default :\r\n			// -----------octal escape--------------\r\n			// OctalDigit\r\n			// OctalDigit OctalDigit\r\n			// ZeroToThree OctalDigit OctalDigit\r\n\r\n			int number = Character.getNumericValue(currentCharacter);\r\n			if (number >= 0 && number <= 7) {\r\n				boolean zeroToThreeNot = number > 3;\r\n				if (Character.isDigit(currentCharacter = source[currentPosition++])) {\r\n					int digit = Character.getNumericValue(currentCharacter);\r\n					if (digit >= 0 && digit <= 7) {\r\n						number = (number * 8) + digit;\r\n						if (Character.isDigit(currentCharacter = source[currentPosition++])) {\r\n							if (zeroToThreeNot) {// has read \\NotZeroToThree OctalDigit Digit --> ignore last character\r\n								currentPosition--;\r\n							} else {\r\n								digit = Character.getNumericValue(currentCharacter);\r\n								if (digit >= 0 && digit <= 7){ // has read \\ZeroToThree OctalDigit OctalDigit\r\n									number = (number * 8) + digit;\r\n								} else {// has read \\ZeroToThree OctalDigit NonOctalDigit --> ignore last character\r\n									currentPosition--;\r\n								}\r\n							}\r\n						} else { // has read \\OctalDigit NonDigit--> ignore last character\r\n							currentPosition--;\r\n						}\r\n					} else { // has read \\OctalDigit NonOctalDigit--> ignore last character						\r\n						currentPosition--;\r\n					}\r\n				} else { // has read \\OctalDigit --> ignore last character\r\n					currentPosition--;\r\n				}\r\n				if (number > 255)\r\n				throw new InvalidInputException(INVALID_ESCAPE);\r\n				currentCharacter = (char) number;\r\n			} else\r\n			throw new InvalidInputException(INVALID_ESCAPE);\r\n		}\r\n	}\r\n	public int scanIdentifierOrKeyword() throws InvalidInputException {\r\n		//test keywords\r\n\r\n		//first dispatch on the first char.\r\n		//then the length. If there are several\r\n		//keywors with the same length AND the same first char, then do another\r\n		//dispatch on the second char \r\n		useAssertAsAnIndentifier = false;\r\n		while (getNextCharAsJavaIdentifierPart());\r\n\r\n		int index, length;\r\n		char[] data;\r\n		char firstLetter;\r\n		if (withoutUnicodePtr == 0)\r\n\r\n		//quick test on length == 1 but not on length > 12 while most identifier\r\n		//have a length which is <= 12...but there are lots of identifier with\r\n		//only one char....\r\n\r\n		{\r\n			if ((length = currentPosition - startPosition) == 1)\r\n			return TokenNameIdentifier;\r\n			data = source;\r\n			index = startPosition;\r\n		} else {\r\n			if ((length = withoutUnicodePtr) == 1)\r\n			return TokenNameIdentifier;\r\n			data = withoutUnicodeBuffer;\r\n			index = 1;\r\n		}\r\n\r\n		firstLetter = data[index];\r\n		switch (firstLetter) {\r\n\r\n		case \'a\' : \r\n			switch(length) {\r\n			case 8: //abstract\r\n				if ((data[++index] == \'b\')\r\n						&& (data[++index] == \'s\')\r\n						&& (data[++index] == \'t\')\r\n						&& (data[++index] == \'r\')\r\n						&& (data[++index] == \'a\')\r\n						&& (data[++index] == \'c\')\r\n						&& (data[++index] == \'t\')) {\r\n					return TokenNameabstract;\r\n				} else {\r\n					return TokenNameIdentifier;\r\n				}\r\n			case 6: // assert\r\n				if ((data[++index] == \'s\')\r\n						&& (data[++index] == \'s\')\r\n						&& (data[++index] == \'e\')\r\n						&& (data[++index] == \'r\')\r\n						&& (data[++index] == \'t\')) {\r\n					if (assertMode) {\r\n						containsAssertKeyword = true;\r\n						return TokenNameassert;\r\n					} else {\r\n						useAssertAsAnIndentifier = true;\r\n						return TokenNameIdentifier;								\r\n					}\r\n				} else {\r\n					return TokenNameIdentifier;\r\n				}\r\n			default: \r\n				return TokenNameIdentifier;\r\n			}\r\n		case \'b\' : //boolean break byte\r\n			switch (length) {\r\n			case 4 :\r\n				if ((data[++index] == \'y\') && (data[++index] == \'t\') && (data[++index] == \'e\'))\r\n				return TokenNamebyte;\r\n				else\r\n				return TokenNameIdentifier;\r\n			case 5 :\r\n				if ((data[++index] == \'r\')\r\n						&& (data[++index] == \'e\')\r\n						&& (data[++index] == \'a\')\r\n						&& (data[++index] == \'k\'))\r\n				return TokenNamebreak;\r\n				else\r\n				return TokenNameIdentifier;\r\n			case 7 :\r\n				if ((data[++index] == \'o\')\r\n						&& (data[++index] == \'o\')\r\n						&& (data[++index] == \'l\')\r\n						&& (data[++index] == \'e\')\r\n						&& (data[++index] == \'a\')\r\n						&& (data[++index] == \'n\'))\r\n				return TokenNameboolean;\r\n				else\r\n				return TokenNameIdentifier;\r\n				default :\r\n				return TokenNameIdentifier;\r\n			}\r\n\r\n		case \'c\' : //case char catch const class continue\r\n			switch (length) {\r\n			case 4 :\r\n				if (data[++index] == \'a\')\r\n				if ((data[++index] == \'s\') && (data[++index] == \'e\'))\r\n				return TokenNamecase;\r\n				else\r\n				return TokenNameIdentifier;\r\n				else\r\n				if ((data[index] == \'h\') && (data[++index] == \'a\') && (data[++index] == \'r\'))\r\n				return TokenNamechar;\r\n				else\r\n				return TokenNameIdentifier;\r\n			case 5 :\r\n				if (data[++index] == \'a\')\r\n				if ((data[++index] == \'t\') && (data[++index] == \'c\') && (data[++index] == \'h\'))\r\n				return TokenNamecatch;\r\n				else\r\n				return TokenNameIdentifier;\r\n				else\r\n				if ((data[index] == \'l\')\r\n						&& (data[++index] == \'a\')\r\n						&& (data[++index] == \'s\')\r\n						&& (data[++index] == \'s\'))\r\n				return TokenNameclass;\r\n				else\r\n				if ((data[index] == \'o\')\r\n						&& (data[++index] == \'n\')\r\n						&& (data[++index] == \'s\')\r\n						&& (data[++index] == \'t\'))\r\n				return TokenNameERROR; //const is not used in java ???????\r\n				else\r\n				return TokenNameIdentifier;\r\n			case 8 :\r\n				if ((data[++index] == \'o\')\r\n						&& (data[++index] == \'n\')\r\n						&& (data[++index] == \'t\')\r\n						&& (data[++index] == \'i\')\r\n						&& (data[++index] == \'n\')\r\n						&& (data[++index] == \'u\')\r\n						&& (data[++index] == \'e\'))\r\n				return TokenNamecontinue;\r\n				else\r\n				return TokenNameIdentifier;\r\n				default :\r\n				return TokenNameIdentifier;\r\n			}\r\n\r\n		case \'d\' : //default do double\r\n			switch (length) {\r\n			case 2 :\r\n				if ((data[++index] == \'o\'))\r\n				return TokenNamedo;\r\n				else\r\n				return TokenNameIdentifier;\r\n			case 6 :\r\n				if ((data[++index] == \'o\')\r\n						&& (data[++index] == \'u\')\r\n						&& (data[++index] == \'b\')\r\n						&& (data[++index] == \'l\')\r\n						&& (data[++index] == \'e\'))\r\n				return TokenNamedouble;\r\n				else\r\n				return TokenNameIdentifier;\r\n			case 7 :\r\n				if ((data[++index] == \'e\')\r\n						&& (data[++index] == \'f\')\r\n						&& (data[++index] == \'a\')\r\n						&& (data[++index] == \'u\')\r\n						&& (data[++index] == \'l\')\r\n						&& (data[++index] == \'t\'))\r\n				return TokenNamedefault;\r\n				else\r\n				return TokenNameIdentifier;\r\n				default :\r\n				return TokenNameIdentifier;\r\n			}\r\n		case \'e\' : //else extends\r\n			switch (length) {\r\n			case 4 :\r\n				if ((data[++index] == \'l\') && (data[++index] == \'s\') && (data[++index] == \'e\'))\r\n				return TokenNameelse;\r\n				else\r\n				return TokenNameIdentifier;\r\n			case 7 :\r\n				if ((data[++index] == \'x\')\r\n						&& (data[++index] == \'t\')\r\n						&& (data[++index] == \'e\')\r\n						&& (data[++index] == \'n\')\r\n						&& (data[++index] == \'d\')\r\n						&& (data[++index] == \'s\'))\r\n				return TokenNameextends;\r\n				else\r\n				return TokenNameIdentifier;\r\n				default :\r\n				return TokenNameIdentifier;\r\n			}\r\n\r\n		case \'f\' : //final finally float for false\r\n			switch (length) {\r\n			case 3 :\r\n				if ((data[++index] == \'o\') && (data[++index] == \'r\'))\r\n				return TokenNamefor;\r\n				else\r\n				return TokenNameIdentifier;\r\n			case 5 :\r\n				if (data[++index] == \'i\')\r\n				if ((data[++index] == \'n\')\r\n						&& (data[++index] == \'a\')\r\n						&& (data[++index] == \'l\')) {\r\n					return TokenNamefinal;\r\n				} else\r\n				return TokenNameIdentifier;\r\n				else\r\n				if ((data[index] == \'l\')\r\n						&& (data[++index] == \'o\')\r\n						&& (data[++index] == \'a\')\r\n						&& (data[++index] == \'t\'))\r\n				return TokenNamefloat;\r\n				else\r\n				if ((data[index] == \'a\')\r\n						&& (data[++index] == \'l\')\r\n						&& (data[++index] == \'s\')\r\n						&& (data[++index] == \'e\'))\r\n				return TokenNamefalse;\r\n				else\r\n				return TokenNameIdentifier;\r\n			case 7 :\r\n				if ((data[++index] == \'i\')\r\n						&& (data[++index] == \'n\')\r\n						&& (data[++index] == \'a\')\r\n						&& (data[++index] == \'l\')\r\n						&& (data[++index] == \'l\')\r\n						&& (data[++index] == \'y\'))\r\n				return TokenNamefinally;\r\n				else\r\n				return TokenNameIdentifier;\r\n\r\n				default :\r\n				return TokenNameIdentifier;\r\n			}\r\n		case \'g\' : //goto\r\n			if (length == 4) {\r\n				if ((data[++index] == \'o\')\r\n						&& (data[++index] == \'t\')\r\n						&& (data[++index] == \'o\')) {\r\n					return TokenNameERROR;\r\n				}\r\n			} //no goto in java are allowed, so why java removes this keyword ???\r\n			return TokenNameIdentifier;\r\n\r\n		case \'i\' : //if implements import instanceof int interface\r\n			switch (length) {\r\n			case 2 :\r\n				if (data[++index] == \'f\')\r\n				return TokenNameif;\r\n				else\r\n				return TokenNameIdentifier;\r\n			case 3 :\r\n				if ((data[++index] == \'n\') && (data[++index] == \'t\'))\r\n				return TokenNameint;\r\n				else\r\n				return TokenNameIdentifier;\r\n			case 6 :\r\n				if ((data[++index] == \'m\')\r\n						&& (data[++index] == \'p\')\r\n						&& (data[++index] == \'o\')\r\n						&& (data[++index] == \'r\')\r\n						&& (data[++index] == \'t\'))\r\n				return TokenNameimport;\r\n				else\r\n				return TokenNameIdentifier;\r\n			case 9 :\r\n				if ((data[++index] == \'n\')\r\n						&& (data[++index] == \'t\')\r\n						&& (data[++index] == \'e\')\r\n						&& (data[++index] == \'r\')\r\n						&& (data[++index] == \'f\')\r\n						&& (data[++index] == \'a\')\r\n						&& (data[++index] == \'c\')\r\n						&& (data[++index] == \'e\'))\r\n				return TokenNameinterface;\r\n				else\r\n				return TokenNameIdentifier;\r\n			case 10 :\r\n				if (data[++index] == \'m\')\r\n				if ((data[++index] == \'p\')\r\n						&& (data[++index] == \'l\')\r\n						&& (data[++index] == \'e\')\r\n						&& (data[++index] == \'m\')\r\n						&& (data[++index] == \'e\')\r\n						&& (data[++index] == \'n\')\r\n						&& (data[++index] == \'t\')\r\n						&& (data[++index] == \'s\'))\r\n				return TokenNameimplements;\r\n				else\r\n				return TokenNameIdentifier;\r\n				else\r\n				if ((data[index] == \'n\')\r\n						&& (data[++index] == \'s\')\r\n						&& (data[++index] == \'t\')\r\n						&& (data[++index] == \'a\')\r\n						&& (data[++index] == \'n\')\r\n						&& (data[++index] == \'c\')\r\n						&& (data[++index] == \'e\')\r\n						&& (data[++index] == \'o\')\r\n						&& (data[++index] == \'f\'))\r\n				return TokenNameinstanceof;\r\n				else\r\n				return TokenNameIdentifier;\r\n\r\n				default :\r\n				return TokenNameIdentifier;\r\n			}\r\n\r\n		case \'l\' : //long\r\n			if (length == 4) {\r\n				if ((data[++index] == \'o\')\r\n						&& (data[++index] == \'n\')\r\n						&& (data[++index] == \'g\')) {\r\n					return TokenNamelong;\r\n				}\r\n			}\r\n			return TokenNameIdentifier;\r\n\r\n		case \'n\' : //native new null\r\n			switch (length) {\r\n			case 3 :\r\n				if ((data[++index] == \'e\') && (data[++index] == \'w\'))\r\n				return TokenNamenew;\r\n				else\r\n				return TokenNameIdentifier;\r\n			case 4 :\r\n				if ((data[++index] == \'u\') && (data[++index] == \'l\') && (data[++index] == \'l\'))\r\n				return TokenNamenull;\r\n				else\r\n				return TokenNameIdentifier;\r\n			case 6 :\r\n				if ((data[++index] == \'a\')\r\n						&& (data[++index] == \'t\')\r\n						&& (data[++index] == \'i\')\r\n						&& (data[++index] == \'v\')\r\n						&& (data[++index] == \'e\')) {\r\n					return TokenNamenative;\r\n				} else\r\n				return TokenNameIdentifier;\r\n				default :\r\n				return TokenNameIdentifier;\r\n			}\r\n\r\n		case \'p\' : //package private protected public\r\n			switch (length) {\r\n			case 6 :\r\n				if ((data[++index] == \'u\')\r\n						&& (data[++index] == \'b\')\r\n						&& (data[++index] == \'l\')\r\n						&& (data[++index] == \'i\')\r\n						&& (data[++index] == \'c\')) {\r\n					return TokenNamepublic;\r\n				} else\r\n				return TokenNameIdentifier;\r\n			case 7 :\r\n				if (data[++index] == \'a\')\r\n				if ((data[++index] == \'c\')\r\n						&& (data[++index] == \'k\')\r\n						&& (data[++index] == \'a\')\r\n						&& (data[++index] == \'g\')\r\n						&& (data[++index] == \'e\'))\r\n				return TokenNamepackage;\r\n				else\r\n				return TokenNameIdentifier;\r\n				else\r\n				if ((data[index] == \'r\')\r\n						&& (data[++index] == \'i\')\r\n						&& (data[++index] == \'v\')\r\n						&& (data[++index] == \'a\')\r\n						&& (data[++index] == \'t\')\r\n						&& (data[++index] == \'e\')) {\r\n					return TokenNameprivate;\r\n				} else\r\n				return TokenNameIdentifier;\r\n			case 9 :\r\n				if ((data[++index] == \'r\')\r\n						&& (data[++index] == \'o\')\r\n						&& (data[++index] == \'t\')\r\n						&& (data[++index] == \'e\')\r\n						&& (data[++index] == \'c\')\r\n						&& (data[++index] == \'t\')\r\n						&& (data[++index] == \'e\')\r\n						&& (data[++index] == \'d\')) {\r\n					return TokenNameprotected;\r\n				} else\r\n				return TokenNameIdentifier;\r\n\r\n				default :\r\n				return TokenNameIdentifier;\r\n			}\r\n\r\n		case \'r\' : //return\r\n			if (length == 6) {\r\n				if ((data[++index] == \'e\')\r\n						&& (data[++index] == \'t\')\r\n						&& (data[++index] == \'u\')\r\n						&& (data[++index] == \'r\')\r\n						&& (data[++index] == \'n\')) {\r\n					return TokenNamereturn;\r\n				}\r\n			}\r\n			return TokenNameIdentifier;\r\n\r\n		case \'s\' : //short static super switch synchronized strictfp\r\n			switch (length) {\r\n			case 5 :\r\n				if (data[++index] == \'h\')\r\n				if ((data[++index] == \'o\') && (data[++index] == \'r\') && (data[++index] == \'t\'))\r\n				return TokenNameshort;\r\n				else\r\n				return TokenNameIdentifier;\r\n				else\r\n				if ((data[index] == \'u\')\r\n						&& (data[++index] == \'p\')\r\n						&& (data[++index] == \'e\')\r\n						&& (data[++index] == \'r\'))\r\n				return TokenNamesuper;\r\n				else\r\n				return TokenNameIdentifier;\r\n\r\n			case 6 :\r\n				if (data[++index] == \'t\')\r\n				if ((data[++index] == \'a\')\r\n						&& (data[++index] == \'t\')\r\n						&& (data[++index] == \'i\')\r\n						&& (data[++index] == \'c\')) {\r\n					return TokenNamestatic;\r\n				} else\r\n				return TokenNameIdentifier;\r\n				else\r\n				if ((data[index] == \'w\')\r\n						&& (data[++index] == \'i\')\r\n						&& (data[++index] == \'t\')\r\n						&& (data[++index] == \'c\')\r\n						&& (data[++index] == \'h\'))\r\n				return TokenNameswitch;\r\n				else\r\n				return TokenNameIdentifier;\r\n			case 8 :\r\n				if ((data[++index] == \'t\')\r\n						&& (data[++index] == \'r\')\r\n						&& (data[++index] == \'i\')\r\n						&& (data[++index] == \'c\')\r\n						&& (data[++index] == \'t\')\r\n						&& (data[++index] == \'f\')\r\n						&& (data[++index] == \'p\'))\r\n				return TokenNamestrictfp;\r\n				else\r\n				return TokenNameIdentifier;\r\n			case 12 :\r\n				if ((data[++index] == \'y\')\r\n						&& (data[++index] == \'n\')\r\n						&& (data[++index] == \'c\')\r\n						&& (data[++index] == \'h\')\r\n						&& (data[++index] == \'r\')\r\n						&& (data[++index] == \'o\')\r\n						&& (data[++index] == \'n\')\r\n						&& (data[++index] == \'i\')\r\n						&& (data[++index] == \'z\')\r\n						&& (data[++index] == \'e\')\r\n						&& (data[++index] == \'d\')) {\r\n					return TokenNamesynchronized;\r\n				} else\r\n				return TokenNameIdentifier;\r\n				default :\r\n				return TokenNameIdentifier;\r\n			}\r\n\r\n		case \'t\' : //try throw throws transient this true\r\n			switch (length) {\r\n			case 3 :\r\n				if ((data[++index] == \'r\') && (data[++index] == \'y\'))\r\n				return TokenNametry;\r\n				else\r\n				return TokenNameIdentifier;\r\n			case 4 :\r\n				if ((data[++index] == \'h\') && (data[++index] == \'i\') && (data[++index] == \'s\'))\r\n				return TokenNamethis;\r\n				else\r\n				if ((data[index] == \'r\') && (data[++index] == \'u\') && (data[++index] == \'e\'))\r\n				return TokenNametrue;\r\n				else\r\n				return TokenNameIdentifier;\r\n			case 5 :\r\n				if ((data[++index] == \'h\')\r\n						&& (data[++index] == \'r\')\r\n						&& (data[++index] == \'o\')\r\n						&& (data[++index] == \'w\'))\r\n				return TokenNamethrow;\r\n				else\r\n				return TokenNameIdentifier;\r\n			case 6 :\r\n				if ((data[++index] == \'h\')\r\n						&& (data[++index] == \'r\')\r\n						&& (data[++index] == \'o\')\r\n						&& (data[++index] == \'w\')\r\n						&& (data[++index] == \'s\'))\r\n				return TokenNamethrows;\r\n				else\r\n				return TokenNameIdentifier;\r\n			case 9 :\r\n				if ((data[++index] == \'r\')\r\n						&& (data[++index] == \'a\')\r\n						&& (data[++index] == \'n\')\r\n						&& (data[++index] == \'s\')\r\n						&& (data[++index] == \'i\')\r\n						&& (data[++index] == \'e\')\r\n						&& (data[++index] == \'n\')\r\n						&& (data[++index] == \'t\')) {\r\n					return TokenNametransient;\r\n				} else\r\n				return TokenNameIdentifier;\r\n\r\n				default :\r\n				return TokenNameIdentifier;\r\n			}\r\n\r\n		case \'v\' : //void volatile\r\n			switch (length) {\r\n			case 4 :\r\n				if ((data[++index] == \'o\') && (data[++index] == \'i\') && (data[++index] == \'d\'))\r\n				return TokenNamevoid;\r\n				else\r\n				return TokenNameIdentifier;\r\n			case 8 :\r\n				if ((data[++index] == \'o\')\r\n						&& (data[++index] == \'l\')\r\n						&& (data[++index] == \'a\')\r\n						&& (data[++index] == \'t\')\r\n						&& (data[++index] == \'i\')\r\n						&& (data[++index] == \'l\')\r\n						&& (data[++index] == \'e\')) {\r\n					return TokenNamevolatile;\r\n				} else\r\n				return TokenNameIdentifier;\r\n\r\n				default :\r\n				return TokenNameIdentifier;\r\n			}\r\n\r\n		case \'w\' : //while widefp\r\n			switch (length) {\r\n			case 5 :\r\n				if ((data[++index] == \'h\')\r\n						&& (data[++index] == \'i\')\r\n						&& (data[++index] == \'l\')\r\n						&& (data[++index] == \'e\'))\r\n				return TokenNamewhile;\r\n				else\r\n				return TokenNameIdentifier;\r\n				//case 6:if ( (data[++index] ==\'i\') && (data[++index]==\'d\') && (data[++index]==\'e\') && (data[++index]==\'f\')&& (data[++index]==\'p\'))\r\n				//return TokenNamewidefp ;\r\n				//else\r\n				//return TokenNameIdentifier;\r\n				default :\r\n				return TokenNameIdentifier;\r\n			}\r\n\r\n			default :\r\n			return TokenNameIdentifier;\r\n		}\r\n	}\r\n	public int scanNumber(boolean dotPrefix) throws InvalidInputException {\r\n\r\n		//when entering this method the currentCharacter is the first\r\n		//digit of the number. It may be preceeded by a \'.\' when\r\n		//dotPrefix is true\r\n\r\n		boolean floating = dotPrefix;\r\n		if ((!dotPrefix) && (currentCharacter == \'0\')) {\r\n			if (getNextChar(\'x\', \'X\') >= 0) { //----------hexa-----------------\r\n				//force the first char of the hexa number do exist...\r\n				// consume next character\r\n				unicodeAsBackSlash = false;\r\n				if (((currentCharacter = source[currentPosition++]) == \'\\\\\')\r\n						&& (source[currentPosition] == \'u\')) {\r\n					getNextUnicodeChar();\r\n				} else {\r\n					if (withoutUnicodePtr != 0) {\r\n						withoutUnicodeBuffer[++withoutUnicodePtr] = currentCharacter;\r\n					}\r\n				}\r\n				if (Character.digit(currentCharacter, 16) == -1)\r\n				throw new InvalidInputException(INVALID_HEXA);\r\n				//---end forcing--\r\n				while (getNextCharAsDigit(16));\r\n				if (getNextChar(\'l\', \'L\') >= 0)\r\n				return TokenNameLongLiteral;\r\n				else\r\n				return TokenNameIntegerLiteral;\r\n			}\r\n\r\n			//there is x or X in the number\r\n			//potential octal ! ... some one may write 000099.0 ! thus 00100 < 00078.0 is true !!!!! crazy language\r\n			if (getNextCharAsDigit()) { //-------------potential octal-----------------\r\n				while (getNextCharAsDigit());\r\n\r\n				if (getNextChar(\'l\', \'L\') >= 0) {\r\n					return TokenNameLongLiteral;\r\n				}\r\n\r\n				if (getNextChar(\'f\', \'F\') >= 0) {\r\n					return TokenNameFloatingPointLiteral;\r\n				}\r\n\r\n				if (getNextChar(\'d\', \'D\') >= 0) {\r\n					return TokenNameDoubleLiteral;\r\n				} else { //make the distinction between octal and float ....\r\n					boolean isInteger = true;\r\n					if (getNextChar(\'.\')) { \r\n						isInteger = false;\r\n						while (getNextCharAsDigit());\r\n					}\r\n					if (getNextChar(\'e\', \'E\') >= 0) { // consume next character\r\n						isInteger = false;\r\n						unicodeAsBackSlash = false;\r\n						if (((currentCharacter = source[currentPosition++]) == \'\\\\\')\r\n								&& (source[currentPosition] == \'u\')) {\r\n							getNextUnicodeChar();\r\n						} else {\r\n							if (withoutUnicodePtr != 0) {\r\n								withoutUnicodeBuffer[++withoutUnicodePtr] = currentCharacter;\r\n							}\r\n						}\r\n\r\n						if ((currentCharacter == \'-\')\r\n								|| (currentCharacter == \'+\')) { // consume next character\r\n							unicodeAsBackSlash = false;\r\n							if (((currentCharacter = source[currentPosition++]) == \'\\\\\')\r\n									&& (source[currentPosition] == \'u\')) {\r\n								getNextUnicodeChar();\r\n							} else {\r\n								if (withoutUnicodePtr != 0) {\r\n									withoutUnicodeBuffer[++withoutUnicodePtr] = currentCharacter;\r\n								}\r\n							}\r\n						}\r\n						if (!Character.isDigit(currentCharacter))\r\n						throw new InvalidInputException(INVALID_FLOAT);\r\n						while (getNextCharAsDigit());\r\n					}\r\n					if (getNextChar(\'f\', \'F\') >= 0)\r\n					return TokenNameFloatingPointLiteral;\r\n					if (getNextChar(\'d\', \'D\') >= 0 || !isInteger)\r\n					return TokenNameDoubleLiteral;\r\n					return TokenNameIntegerLiteral;\r\n				}\r\n			} else {\r\n				/* carry on */\r\n			}\r\n		}\r\n\r\n		while (getNextCharAsDigit());\r\n\r\n		if ((!dotPrefix) && (getNextChar(\'l\', \'L\') >= 0))\r\n		return TokenNameLongLiteral;\r\n\r\n		if ((!dotPrefix) && (getNextChar(\'.\'))) { //decimal part that can be empty\r\n			while (getNextCharAsDigit());\r\n			floating = true;\r\n		}\r\n\r\n		//if floating is true both exponant and suffix may be optional\r\n\r\n		if (getNextChar(\'e\', \'E\') >= 0) {\r\n			floating = true;\r\n			// consume next character\r\n			unicodeAsBackSlash = false;\r\n			if (((currentCharacter = source[currentPosition++]) == \'\\\\\')\r\n					&& (source[currentPosition] == \'u\')) {\r\n				getNextUnicodeChar();\r\n			} else {\r\n				if (withoutUnicodePtr != 0) {\r\n					withoutUnicodeBuffer[++withoutUnicodePtr] = currentCharacter;\r\n				}\r\n			}\r\n\r\n			if ((currentCharacter == \'-\')\r\n					|| (currentCharacter == \'+\')) { // consume next character\r\n				unicodeAsBackSlash = false;\r\n				if (((currentCharacter = source[currentPosition++]) == \'\\\\\')\r\n						&& (source[currentPosition] == \'u\')) {\r\n					getNextUnicodeChar();\r\n				} else {\r\n					if (withoutUnicodePtr != 0) {\r\n						withoutUnicodeBuffer[++withoutUnicodePtr] = currentCharacter;\r\n					}\r\n				}\r\n			}\r\n			if (!Character.isDigit(currentCharacter))\r\n			throw new InvalidInputException(INVALID_FLOAT);\r\n			while (getNextCharAsDigit());\r\n		}\r\n\r\n		if (getNextChar(\'d\', \'D\') >= 0)\r\n		return TokenNameDoubleLiteral;\r\n		if (getNextChar(\'f\', \'F\') >= 0)\r\n		return TokenNameFloatingPointLiteral;\r\n\r\n		//the long flag has been tested before\r\n\r\n		return floating ? TokenNameDoubleLiteral : TokenNameIntegerLiteral;\r\n	}\r\n	/**\r\n* Search the line number corresponding to a specific position\r\n*\r\n*/\r\n	public final int getLineNumber(int position) {\r\n\r\n		if (lineEnds == null)\r\n		return 1;\r\n		int length = linePtr+1;\r\n		if (length == 0)\r\n		return 1;\r\n		int g = 0, d = length - 1;\r\n		int m = 0;\r\n		while (g <= d) {\r\n			m = (g + d) /2;\r\n			if (position < lineEnds[m]) {\r\n				d = m-1;\r\n			} else if (position > lineEnds[m]) {\r\n				g = m+1;\r\n			} else {\r\n				return m + 1;\r\n			}\r\n		}\r\n		if (position < lineEnds[m]) {\r\n			return m+1;\r\n		}\r\n		return m+2;\r\n	}\r\n	public final void setSource(char[] source){\r\n		//the source-buffer is set to sourceString\r\n\r\n		if (source == null) {\r\n			this.source = CharOperation.NO_CHAR;\r\n		} else {\r\n			this.source = source;\r\n		}\r\n		startPosition = -1;\r\n		eofPosition = source.length;\r\n		initialPosition = currentPosition = 0;\r\n		containsAssertKeyword = false;\r\n		withoutUnicodeBuffer = new char[this.source.length];\r\n\r\n	}\r\n\r\n	public String toString() {\r\n		if (startPosition == source.length)\r\n		return \"EOF\\n\\n\" + new String(source); //$NON-NLS-1$\r\n		if (currentPosition > source.length)\r\n		return \"behind the EOF :-( ....\\n\\n\" + new String(source); //$NON-NLS-1$\r\n\r\n		char front[] = new char[startPosition];\r\n		System.arraycopy(source, 0, front, 0, startPosition);\r\n\r\n		int middleLength = (currentPosition - 1) - startPosition + 1;\r\n		char middle[];\r\n		if (middleLength > -1) {\r\n			middle = new char[middleLength];\r\n			System.arraycopy(\r\n			source, \r\n			startPosition, \r\n			middle, \r\n			0, \r\n			middleLength);\r\n		} else {\r\n			middle = CharOperation.NO_CHAR;\r\n		}\r\n		\r\n		char end[] = new char[source.length - (currentPosition - 1)];\r\n		System.arraycopy(\r\n		source, \r\n		(currentPosition - 1) + 1, \r\n		end, \r\n		0, \r\n		source.length - (currentPosition - 1) - 1);\r\n		\r\n		return new String(front)\r\n		+ \"\\n===============================\\nStarts here -->\" //$NON-NLS-1$\r\n		+ new String(middle)\r\n		+ \"<-- Ends here\\n===============================\\n\" //$NON-NLS-1$\r\n		+ new String(end); \r\n	}\r\n	public final String toStringAction(int act) {\r\n		switch (act) {\r\n		case TokenNameIdentifier :\r\n			return \"Identifier(\" + new String(getCurrentTokenSource()) + \")\"; //$NON-NLS-1$ //$NON-NLS-2$\r\n		case TokenNameabstract :\r\n			return \"abstract\"; //$NON-NLS-1$\r\n		case TokenNameboolean :\r\n			return \"boolean\"; //$NON-NLS-1$\r\n		case TokenNamebreak :\r\n			return \"break\"; //$NON-NLS-1$\r\n		case TokenNamebyte :\r\n			return \"byte\"; //$NON-NLS-1$\r\n		case TokenNamecase :\r\n			return \"case\"; //$NON-NLS-1$\r\n		case TokenNamecatch :\r\n			return \"catch\"; //$NON-NLS-1$\r\n		case TokenNamechar :\r\n			return \"char\"; //$NON-NLS-1$\r\n		case TokenNameclass :\r\n			return \"class\"; //$NON-NLS-1$\r\n		case TokenNamecontinue :\r\n			return \"continue\"; //$NON-NLS-1$\r\n		case TokenNamedefault :\r\n			return \"default\"; //$NON-NLS-1$\r\n		case TokenNamedo :\r\n			return \"do\"; //$NON-NLS-1$\r\n		case TokenNamedouble :\r\n			return \"double\"; //$NON-NLS-1$\r\n		case TokenNameelse :\r\n			return \"else\"; //$NON-NLS-1$\r\n		case TokenNameextends :\r\n			return \"extends\"; //$NON-NLS-1$\r\n		case TokenNamefalse :\r\n			return \"false\"; //$NON-NLS-1$\r\n		case TokenNamefinal :\r\n			return \"final\"; //$NON-NLS-1$\r\n		case TokenNamefinally :\r\n			return \"finally\"; //$NON-NLS-1$\r\n		case TokenNamefloat :\r\n			return \"float\"; //$NON-NLS-1$\r\n		case TokenNamefor :\r\n			return \"for\"; //$NON-NLS-1$\r\n		case TokenNameif :\r\n			return \"if\"; //$NON-NLS-1$\r\n		case TokenNameimplements :\r\n			return \"implements\"; //$NON-NLS-1$\r\n		case TokenNameimport :\r\n			return \"import\"; //$NON-NLS-1$\r\n		case TokenNameinstanceof :\r\n			return \"instanceof\"; //$NON-NLS-1$\r\n		case TokenNameint :\r\n			return \"int\"; //$NON-NLS-1$\r\n		case TokenNameinterface :\r\n			return \"interface\"; //$NON-NLS-1$\r\n		case TokenNamelong :\r\n			return \"long\"; //$NON-NLS-1$\r\n		case TokenNamenative :\r\n			return \"native\"; //$NON-NLS-1$\r\n		case TokenNamenew :\r\n			return \"new\"; //$NON-NLS-1$\r\n		case TokenNamenull :\r\n			return \"null\"; //$NON-NLS-1$\r\n		case TokenNamepackage :\r\n			return \"package\"; //$NON-NLS-1$\r\n		case TokenNameprivate :\r\n			return \"private\"; //$NON-NLS-1$\r\n		case TokenNameprotected :\r\n			return \"protected\"; //$NON-NLS-1$\r\n		case TokenNamepublic :\r\n			return \"public\"; //$NON-NLS-1$\r\n		case TokenNamereturn :\r\n			return \"return\"; //$NON-NLS-1$\r\n		case TokenNameshort :\r\n			return \"short\"; //$NON-NLS-1$\r\n		case TokenNamestatic :\r\n			return \"static\"; //$NON-NLS-1$\r\n		case TokenNamesuper :\r\n			return \"super\"; //$NON-NLS-1$\r\n		case TokenNameswitch :\r\n			return \"switch\"; //$NON-NLS-1$\r\n		case TokenNamesynchronized :\r\n			return \"synchronized\"; //$NON-NLS-1$\r\n		case TokenNamethis :\r\n			return \"this\"; //$NON-NLS-1$\r\n		case TokenNamethrow :\r\n			return \"throw\"; //$NON-NLS-1$\r\n		case TokenNamethrows :\r\n			return \"throws\"; //$NON-NLS-1$\r\n		case TokenNametransient :\r\n			return \"transient\"; //$NON-NLS-1$\r\n		case TokenNametrue :\r\n			return \"true\"; //$NON-NLS-1$\r\n		case TokenNametry :\r\n			return \"try\"; //$NON-NLS-1$\r\n		case TokenNamevoid :\r\n			return \"void\"; //$NON-NLS-1$\r\n		case TokenNamevolatile :\r\n			return \"volatile\"; //$NON-NLS-1$\r\n		case TokenNamewhile :\r\n			return \"while\"; //$NON-NLS-1$\r\n\r\n		case TokenNameIntegerLiteral :\r\n			return \"Integer(\" + new String(getCurrentTokenSource()) + \")\"; //$NON-NLS-1$ //$NON-NLS-2$\r\n		case TokenNameLongLiteral :\r\n			return \"Long(\" + new String(getCurrentTokenSource()) + \")\"; //$NON-NLS-1$ //$NON-NLS-2$\r\n		case TokenNameFloatingPointLiteral :\r\n			return \"Float(\" + new String(getCurrentTokenSource()) + \")\"; //$NON-NLS-1$ //$NON-NLS-2$\r\n		case TokenNameDoubleLiteral :\r\n			return \"Double(\" + new String(getCurrentTokenSource()) + \")\"; //$NON-NLS-1$ //$NON-NLS-2$\r\n		case TokenNameCharacterLiteral :\r\n			return \"Char(\" + new String(getCurrentTokenSource()) + \")\"; //$NON-NLS-1$ //$NON-NLS-2$\r\n		case TokenNameStringLiteral :\r\n			return \"String(\" + new String(getCurrentTokenSource()) + \")\"; //$NON-NLS-1$ //$NON-NLS-2$\r\n\r\n		case TokenNamePLUS_PLUS :\r\n			return \"++\"; //$NON-NLS-1$\r\n		case TokenNameMINUS_MINUS :\r\n			return \"--\"; //$NON-NLS-1$\r\n		case TokenNameEQUAL_EQUAL :\r\n			return \"==\"; //$NON-NLS-1$\r\n		case TokenNameLESS_EQUAL :\r\n			return \"<=\"; //$NON-NLS-1$\r\n		case TokenNameGREATER_EQUAL :\r\n			return \">=\"; //$NON-NLS-1$\r\n		case TokenNameNOT_EQUAL :\r\n			return \"!=\"; //$NON-NLS-1$\r\n		case TokenNameLEFT_SHIFT :\r\n			return \"<<\"; //$NON-NLS-1$\r\n		case TokenNameRIGHT_SHIFT :\r\n			return \">>\"; //$NON-NLS-1$\r\n		case TokenNameUNSIGNED_RIGHT_SHIFT :\r\n			return \">>>\"; //$NON-NLS-1$\r\n		case TokenNamePLUS_EQUAL :\r\n			return \"+=\"; //$NON-NLS-1$\r\n		case TokenNameMINUS_EQUAL :\r\n			return \"-=\"; //$NON-NLS-1$\r\n		case TokenNameMULTIPLY_EQUAL :\r\n			return \"*=\"; //$NON-NLS-1$\r\n		case TokenNameDIVIDE_EQUAL :\r\n			return \"/=\"; //$NON-NLS-1$\r\n		case TokenNameAND_EQUAL :\r\n			return \"&=\"; //$NON-NLS-1$\r\n		case TokenNameOR_EQUAL :\r\n			return \"|=\"; //$NON-NLS-1$\r\n		case TokenNameXOR_EQUAL :\r\n			return \"^=\"; //$NON-NLS-1$\r\n		case TokenNameREMAINDER_EQUAL :\r\n			return \"%=\"; //$NON-NLS-1$\r\n		case TokenNameLEFT_SHIFT_EQUAL :\r\n			return \"<<=\"; //$NON-NLS-1$\r\n		case TokenNameRIGHT_SHIFT_EQUAL :\r\n			return \">>=\"; //$NON-NLS-1$\r\n		case TokenNameUNSIGNED_RIGHT_SHIFT_EQUAL :\r\n			return \">>>=\"; //$NON-NLS-1$\r\n		case TokenNameOR_OR :\r\n			return \"||\"; //$NON-NLS-1$\r\n		case TokenNameAND_AND :\r\n			return \"&&\"; //$NON-NLS-1$\r\n		case TokenNamePLUS :\r\n			return \"+\"; //$NON-NLS-1$\r\n		case TokenNameMINUS :\r\n			return \"-\"; //$NON-NLS-1$\r\n		case TokenNameNOT :\r\n			return \"!\"; //$NON-NLS-1$\r\n		case TokenNameREMAINDER :\r\n			return \"%\"; //$NON-NLS-1$\r\n		case TokenNameXOR :\r\n			return \"^\"; //$NON-NLS-1$\r\n		case TokenNameAND :\r\n			return \"&\"; //$NON-NLS-1$\r\n		case TokenNameMULTIPLY :\r\n			return \"*\"; //$NON-NLS-1$\r\n		case TokenNameOR :\r\n			return \"|\"; //$NON-NLS-1$\r\n		case TokenNameTWIDDLE :\r\n			return \"~\"; //$NON-NLS-1$\r\n		case TokenNameDIVIDE :\r\n			return \"/\"; //$NON-NLS-1$\r\n		case TokenNameGREATER :\r\n			return \">\"; //$NON-NLS-1$\r\n		case TokenNameLESS :\r\n			return \"<\"; //$NON-NLS-1$\r\n		case TokenNameLPAREN :\r\n			return \"(\"; //$NON-NLS-1$\r\n		case TokenNameRPAREN :\r\n			return \")\"; //$NON-NLS-1$\r\n		case TokenNameLBRACE :\r\n			return \"{\"; //$NON-NLS-1$\r\n		case TokenNameRBRACE :\r\n			return \"}\"; //$NON-NLS-1$\r\n		case TokenNameLBRACKET :\r\n			return \"[\"; //$NON-NLS-1$\r\n		case TokenNameRBRACKET :\r\n			return \"]\"; //$NON-NLS-1$\r\n		case TokenNameSEMICOLON :\r\n			return \";\"; //$NON-NLS-1$\r\n		case TokenNameQUESTION :\r\n			return \"?\"; //$NON-NLS-1$\r\n		case TokenNameCOLON :\r\n			return \":\"; //$NON-NLS-1$\r\n		case TokenNameCOMMA :\r\n			return \",\"; //$NON-NLS-1$\r\n		case TokenNameDOT :\r\n			return \".\"; //$NON-NLS-1$\r\n		case TokenNameEQUAL :\r\n			return \"=\"; //$NON-NLS-1$\r\n		case TokenNameEOF :\r\n			return \"EOF\"; //$NON-NLS-1$\r\n			default :\r\n			return \"not-a-token\"; //$NON-NLS-1$\r\n		}\r\n	}\r\n}','Public Class','eclipse.jdt.core','org.eclipse.jdt.internal.core.util.PublicScanner',2,7,0,'',NULL),(11,'M','lpl','public BenchmarkResults benchmark(int seeds, int depth, int threads, int maxPerHost, long topN, boolean delete, String plugins) throws Exception {\r\n	Configuration conf = getConf();\r\n	conf.set(\"http.proxy.host\", \"localhost\");\r\n	conf.setInt(\"http.proxy.port\", 8181);\r\n	conf.set(\"http.agent.name\", \"test\");\r\n	conf.set(\"http.robots.agents\", \"test,*\");\r\n	if (!plugins.equals(\"default\")) {\r\n		conf.set(\"plugin.includes\", plugins);\r\n	}\r\n	conf.setInt(Generator.GENERATOR_MAX_COUNT, maxPerHost);\r\n	conf.set(Generator.GENERATOR_COUNT_MODE, Generator.GENERATOR_COUNT_VALUE_HOST);\r\n	JobConf job = new NutchJob(getConf());    \r\n	FileSystem fs = FileSystem.get(job);\r\n	Path dir = new Path(getConf().get(\"hadoop.tmp.dir\"),\r\n	\"bench-\" + System.currentTimeMillis());\r\n	fs.mkdirs(dir);\r\n	Path rootUrlDir = new Path(dir, \"seed\");\r\n	fs.mkdirs(rootUrlDir);\r\n	createSeeds(fs, rootUrlDir, seeds);\r\n\r\n	if (LOG.isInfoEnabled()) {\r\n		LOG.info(\"crawl started in: \" + dir);\r\n		LOG.info(\"rootUrlDir = \" + rootUrlDir);\r\n		LOG.info(\"threads = \" + threads);\r\n		LOG.info(\"depth = \" + depth);      \r\n	}\r\n	BenchmarkResults res = new BenchmarkResults();\r\n	res.delete = delete;\r\n	res.depth = depth;\r\n	res.plugins = plugins;\r\n	res.seeds = seeds;\r\n	res.threads = threads;\r\n	res.topN = topN;\r\n	Path crawlDb = new Path(dir + \"/crawldb\");\r\n	Path linkDb = new Path(dir + \"/linkdb\");\r\n	Path segments = new Path(dir + \"/segments\");\r\n	res.elapsed = System.currentTimeMillis();\r\n	Injector injector = new Injector(getConf());\r\n	Generator generator = new Generator(getConf());\r\n	Fetcher fetcher = new Fetcher(getConf());\r\n	ParseSegment parseSegment = new ParseSegment(getConf());\r\n	CrawlDb crawlDbTool = new CrawlDb(getConf());\r\n	LinkDb linkDbTool = new LinkDb(getConf());\r\n	\r\n	// initialize crawlDb\r\n	long start = System.currentTimeMillis();\r\n	injector.inject(crawlDb, rootUrlDir);\r\n	long delta = System.currentTimeMillis() - start;\r\n	res.addTiming(\"inject\", \"0\", delta);\r\n	int i;\r\n	for (i = 0; i < depth; i++) {             // generate new segment\r\n		start = System.currentTimeMillis();\r\n		Path[] segs = generator.generate(crawlDb, segments, -1, topN, System\r\n		.currentTimeMillis());\r\n		delta = System.currentTimeMillis() - start;\r\n		res.addTiming(\"generate\", i + \"\", delta);\r\n		if (segs == null) {\r\n			LOG.info(\"Stopping at depth=\" + i + \" - no more URLs to fetch.\");\r\n			break;\r\n		}\r\n		start = System.currentTimeMillis();\r\n		fetcher.fetch(segs[0], threads);  // fetch it\r\n		delta = System.currentTimeMillis() - start;\r\n		res.addTiming(\"fetch\", i + \"\", delta);\r\n		if (!Fetcher.isParsing(job)) {\r\n			start = System.currentTimeMillis();\r\n			parseSegment.parse(segs[0]);    // parse it, if needed\r\n			delta = System.currentTimeMillis() - start;\r\n			res.addTiming(\"parse\", i + \"\", delta);\r\n		}\r\n		start = System.currentTimeMillis();\r\n		crawlDbTool.update(crawlDb, segs, true, true); // update crawldb\r\n		delta = System.currentTimeMillis() - start;\r\n		res.addTiming(\"update\", i + \"\", delta);\r\n		start = System.currentTimeMillis();\r\n		linkDbTool.invert(linkDb, segs, true, true, false); // invert links\r\n		delta = System.currentTimeMillis() - start;\r\n		res.addTiming(\"invert\", i + \"\", delta);\r\n		// delete data\r\n		if (delete) {\r\n			for (Path p : segs) {\r\n				fs.delete(p, true);\r\n			}\r\n		}\r\n	}\r\n	if (i == 0) {\r\n		LOG.warn(\"No URLs to fetch - check your seed list and URL filters.\");\r\n	}\r\n	if (LOG.isInfoEnabled()) { LOG.info(\"crawl finished: \" + dir); }\r\n	res.elapsed = System.currentTimeMillis() - res.elapsed;\r\n	CrawlDbReader dbreader = new CrawlDbReader();\r\n	dbreader.processStatJob(crawlDb.toString(), conf, false);\r\n	return res;\r\n}','Public Method','nutch','org.apache.nutch.tools.Benchmark.benchmark',1,5,0,'',NULL),(12,'M','lpl','@Override\r\n  public FSDataOutputStream create(Path f, FsPermission permission,\r\n      boolean overwrite, int bufferSize, short replication, long blockSize,\r\n      Progressable progress) throws IOException {\r\n    return super.create(swizzleParamPath(f), permission,\r\n        overwrite, bufferSize, replication, blockSize, progress);\r\n  }','Public Method','hive','org.apache.hadoop.fs.ProxyFileSystem.create',2,9,0,'',NULL),(13,'C','gc','/*\r\n *  Licensed to the Apache Software Foundation (ASF) under one or more\r\n *  contributor license agreements.  See the NOTICE file distributed with\r\n *  this work for additional information regarding copyright ownership.\r\n *  The ASF licenses this file to You under the Apache License, Version 2.0\r\n *  (the \"License\"); you may not use this file except in compliance with\r\n *  the License.  You may obtain a copy of the License at\r\n *\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n *  Unless required by applicable law or agreed to in writing, software\r\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\r\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n *  See the License for the specific language governing permissions and\r\n *  limitations under the License.\r\n *\r\n */\r\npackage org.apache.tools.ant.types.optional;\r\n\r\nimport org.apache.tools.ant.BuildException;\r\nimport org.apache.tools.ant.taskdefs.condition.Condition;\r\n\r\n/**\r\n * A condition that lets you include script.\r\n * The condition component sets a bean \"self\", whose attribute \"value\"\r\n * must be set to true for the condition to succeed, false to fail.\r\n * The default is \'false\'\r\n */\r\npublic class ScriptCondition extends AbstractScriptComponent implements Condition {\r\n\r\n    /**\r\n     * result field\r\n     */\r\n    private boolean value = false;\r\n\r\n    /**\r\n     * Is this condition true?\r\n     *\r\n     * @return true if the condition is true\r\n     *\r\n     * @throws org.apache.tools.ant.BuildException\r\n     *          if an error occurs\r\n     */\r\n    public boolean eval() throws BuildException {\r\n        initScriptRunner();\r\n        executeScript(\"ant_condition\");\r\n        return getValue();\r\n    }\r\n\r\n    /**\r\n     * get the current value of the conditon\r\n     * @return true if the condition\r\n     */\r\n    public boolean getValue() {\r\n        return value;\r\n    }\r\n\r\n    /**\r\n     * set the value of the condition.\r\n     * This is used by the script to pass the return value.\r\n     * It can be used by an attribute, in which case it sets the default\r\n     * value\r\n     * @param value the value to set the condition to\r\n     */\r\n    public void setValue(boolean value) {\r\n        this.value = value;\r\n    }\r\n}','Public Class','ant','org.apache.tools.ant.types.optional.ScriptCondition',1,7,1,NULL,NULL),(14,'M','lm','/**\r\n     * Is this condition true?\r\n     *\r\n     * @return true if the condition is true\r\n     *\r\n     * @throws org.apache.tools.ant.BuildException\r\n     *          if an error occurs\r\n     */\r\n    public boolean eval() throws BuildException {\r\n        initScriptRunner();\r\n        executeScript(\"ant_condition\");\r\n        return getValue();\r\n    }','Public Method','ant','org.apache.tools.ant.types.optional.ScriptCondition',1,4,1,NULL,NULL),(15,'M','lpl','/**\r\n     * Executes the proxied task.\r\n     *\r\n     * @exception BuildException if the project could not be set\r\n     * or the method could not be executed.\r\n     */\r\n    public void execute() throws BuildException {\r\n        try {\r\n            Method setLocationM = proxy.getClass().getMethod(\r\n                \"setLocation\", new Class[] {Location.class});\r\n            if (setLocationM != null) {\r\n                setLocationM.invoke(proxy, new Object[] {getLocation()});\r\n            }\r\n        } catch (NoSuchMethodException e) {\r\n            // ignore this if the class being used as a task does not have\r\n            // a set location method.\r\n        } catch (Exception ex) {\r\n            log(\"Error setting location in \" + proxy.getClass(),\r\n                Project.MSG_ERR);\r\n            throw new BuildException(ex);\r\n        }\r\n\r\n        try {\r\n            Method setProjectM = proxy.getClass().getMethod(\r\n                \"setProject\", new Class[] {Project.class});\r\n            if (setProjectM != null) {\r\n                setProjectM.invoke(proxy, new Object[] {getProject()});\r\n            }\r\n        } catch (NoSuchMethodException e) {\r\n            // ignore this if the class being used as a task does not have\r\n            // a set project method.\r\n        } catch (Exception ex) {\r\n            log(\"Error setting project in \" + proxy.getClass(),\r\n                Project.MSG_ERR);\r\n            throw new BuildException(ex);\r\n        }\r\n\r\n        try {\r\n            DispatchUtils.execute(proxy);\r\n        } catch (BuildException be) {\r\n            throw be;\r\n        } catch (Exception ex) {\r\n            log(\"Error in \" + proxy.getClass(), Project.MSG_VERBOSE);\r\n            throw new BuildException(ex);\r\n        }\r\n    }','Public Method','ant','org.apache.tools.ant.TaskAdapter',2,5,1,NULL,NULL),(16,'C','gc','/*******************************************************************************\r\n * Copyright (c) 2000, 2003 IBM Corporation and others.\r\n * All rights reserved. This program and the accompanying materials \r\n * are made available under the terms of the Common Public License v1.0\r\n * which accompanies this distribution, and is available at\r\n * http://www.eclipse.org/legal/cpl-v10.html\r\n * \r\n * Contributors:\r\n *     IBM Corporation - initial API and implementation\r\n *******************************************************************************/\r\npackage org.eclipse.jdt.internal.eval;\r\n\r\nimport java.util.Map;\r\n\r\nimport org.eclipse.jdt.internal.compiler.Compiler;\r\nimport org.eclipse.jdt.internal.compiler.ICompilerRequestor;\r\nimport org.eclipse.jdt.internal.compiler.IErrorHandlingPolicy;\r\nimport org.eclipse.jdt.internal.compiler.IProblemFactory;\r\nimport org.eclipse.jdt.internal.compiler.env.INameEnvironment;\r\n\r\n/**\r\n * A compiler that compiles code snippets. \r\n */\r\npublic class CodeSnippetCompiler extends Compiler {\r\n	\r\n	EvaluationContext evaluationContext;\r\n	int codeSnippetStart;\r\n	int codeSnippetEnd;\r\n	\r\n	/**\r\n	 * Creates a new code snippet compiler initialized with a code snippet parser.\r\n	 */\r\n	public CodeSnippetCompiler(\r\n		INameEnvironment environment,\r\n		IErrorHandlingPolicy policy,\r\n		Map settings,\r\n		ICompilerRequestor requestor,\r\n		IProblemFactory problemFactory,\r\n		EvaluationContext evaluationContext,\r\n		int codeSnippetStart,\r\n		int codeSnippetEnd) {\r\n		super(environment, policy, settings, requestor, problemFactory);\r\n		this.parser =\r\n			new CodeSnippetParser(\r\n				problemReporter,\r\n				evaluationContext,\r\n				this.options.parseLiteralExpressionsAsConstants,\r\n				codeSnippetStart,\r\n				codeSnippetEnd);\r\n		this.parseThreshold = 1;\r\n		// fully parse only the code snippet compilation unit\r\n	}\r\n	\r\n	/* (non-Javadoc)\r\n	 * @see org.eclipse.jdt.internal.compiler.Compiler#initializeParser()\r\n	 */\r\n	public void initializeParser() {\r\n		this.parser =\r\n			new CodeSnippetParser(\r\n				this.problemReporter,\r\n				this.evaluationContext,\r\n				this.options.parseLiteralExpressionsAsConstants,\r\n				this.codeSnippetStart,\r\n				this.codeSnippetEnd);\r\n		}\r\n}','Public Class','eclipse.jdt.core','org.eclipse.jdt.internal.eval.CodeSnippetCompiler',2,7,1,NULL,NULL);
/*!40000 ALTER TABLE `ms_task` ENABLE KEYS */;
UNLOCK TABLES;
/*!40103 SET TIME_ZONE=@OLD_TIME_ZONE */;

/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;

-- Dump completed on 2020-02-02 14:09:59
